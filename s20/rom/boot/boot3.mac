;
; Слой 3 - эмулятор пульта, тест TMEM
;_______________________________________________________________________
;
		.ASECT
		.	= 173000
		.if	ne, 1
BGSL3:
		.word	-1, -1, -1
		.	= BGSL3+6
		
;_______________________________________________________________________
;
; Команды эмулятора состоят из двух символов и,	если нужно, восьмеричного числа
; ввод которого	завершается символом <ВК> или "*":
;	L N<ВК>		- ввод адреса равного N
;	E		- чтение ячейки	с ранее	введенным адресом
;	D ADR N<BK>	- запись числа N по ранее введенному адресу
;			  (его значение	"ADR" выводит эмулятор)
;	S <BK>		- старт	с ранее	введенного адреса
;
; Вторым символом команд L, E, D является пробел
; Перед	повторным выполнением команд E и D алрес корректируется	на +2, пока
; повторяется одна и та	же команда (последовательность E, D, E,	D ... адрес не
; изменяет
;
; Восьмеричное число N может состоять из любого	числа цифр, после ввода	<BK>
; используются младшие 16 бит введенного числа.	Если цифр введено меньше шести,
; левые	биты заполняются нулями. Если введен символ отличный от	0...7 или <BK>,
; то выполнение	команды	прерывается
;
; Вызов	загрузчика через эмулятор выполняется командой:
;	ИУN<BK>
; или	ИУN*
; где ИУ - имя устройства из приведенной выше таблицы, N - номер устройства или
; смещение загрузки для	загрузчика с перфоленты	PR. N=0	можно опустить.
; (например, 177400 для	СМ1420.5410). Для загрузки устройства, имеющего	нестандартный
; базовый  адрес, используеьтся	команда:
;	ИУAAAAAN<BK>
; или	ИУAAAAAN*
; где AAAAA - пять страших цифр	базового адреса	устройства загрузки
;     N	- номер	устройства
;
; Загрузку с нестандартного базового адреса можно выполнить для	устройств  DK,
; DP, DR, MT, MM. Например, по команде DK170121<BK> будет выполнена загрузка
; с первого накопителя устройства СМ1420.5410, имеющего	базовый	адрес 170120
;
; Если команда оканчивается <BK>, то перезагрузкой выполняются тесты и
; очищаются первые 28К слов памяти. Если команда заканчивается "*", то тесты
; не выполняются и память сохранаяется
;
EX:		mov	R5, R0			; пересылка в R0 для печати
		mov	PC, R1			;
		bne	PUTCR			; печать ВК, ПС, заполняющих символов
		mov	PC, R1			;
		bne	PUTNUM			; печать модержимого R5
		bne	CONSEM			;
		halt				;
						;
		.word	173000			; стартовый адрес
		.word	000343			; и перемычки
						;
CONSEM:		mov	PC, R1			;
		bne	PUTCR			;
		mov	#77, R2			; символ "?" для печати
		mov	PC, R3			;
		bne	PUTCHR			; печать "?"
;_______________________________________________________________________
;
; Подпрограмма получения команды с клавиатуры
;
READ:		mov	PC, R3			;
		bne	46$			; получение первого символа команды
		add	R2, R2			; сдвиг	первого	символа	в старший байт R2
		add	R2, R2			;
		add	R2, R2			;
		add	R2, R2			;
		add	R2, R2			;
		add	R2, R2			;
		add	R2, R2			;
		add	R2, R2			;
		mov	R2, R1			; пересылка в R1
		mov	PC, R3			;
46$:		bne	GETCHR			; получение второго символа команды
		add	R1, R2			; полная команда в R2
		mov	R4, R1			; сохранение старой команды в R1
		cmp	(PC)+, R2		; команда "L"?
		.ascii	<40>"L"			;
		beq	LA			;
		cmp	R4, R2			; команда повторяется?
		bne	4$			; нет
		add	#2, R5			; продвижение адреса
 4$:		mov	R2, R4			; запоминане команды в R4
		cmp	(PC)+, R2		; команда "E"?
		.ascii	<40>"E"			;
		bne	5$			; нет
		mov	R5, R0			; пересылка R5 в R0 для	печати
		mov	PC, R1			;
		bne	PUTNUM			; печать адреса
		mov	(R5), R0		; пересылка содержимого	адреса для печати
		mov	#EX+6, PC		; переход на печать адреса
						; и переход в эмулятор
5$:		cmp	(PC)+, R2		; команда "D"?
		.ascii	<40>"D"			;
		beq	DE			; да, выполняем
		cmp	(PC)+, R2		; команда "S"?
		.ascii	<15>"S"			;
		bne	6$			; нет
		mov	#START,	PC		; да, переход по адресу	в R5
6$:		mov	#CHECK,	PC		; на поиск загрузчика по слоям
LA:		mov	PC, R1			;
		bne	GETNUM			; получение адреса для команды "L"
		mov	R0, R5			; пересылка адреса в R5
KBDCLR:		bic	R4, R4			; обнуление регистра R4
		beq	CONSEM			; переходим снова в эмулятор
DE:		mov	R5, R0			; пересылка адреса для печати
		mov	PC, R1			;
		bne	PUTNUM			; печать адреса
		mov	PC,R1			;
		bne	GETNUM			; получение слова
		mov	R0, (R5)		; запись слова по адресу
		mov	#CONSEM, PC		; переходим снова в эмулятор
;_______________________________________________________________________
;
; печать ВК, ПС
;
PUTCR:		mov	#010012, R2		; счетчик байт и символ	ПС
1$:		mov	PC, R3			;
		bne	PUTCHR			; печать символа
		bic	#377, R2		; очистка R2 от	символа
		add	#-1000,	R2		; уменьшение счетчика
		beq	X1RTN			; возврат если счетчик исчерпан
		add	#015, R2		; занесение символа "BK"
		bne	1$			; младший байт в R2
;_______________________________________________________________________
;
; Получение символа с консоли
;
GETCHR:		mov	@#177560, SP		;
		bic	#177577, SP		; есть готовность клавиатуры?
		beq	GETCHR			; клавиатура не	готова
		mov	@#177562, R2		; передача символа в R2
		bic	#177600, R2		;
;_______________________________________________________________________
;
; Печать символа на консоли
;
PUTCHR:		mov	@#177564, SP		;
		bic	#177577, SP		; есть готовность печати?
		beq	PUTCHR			; консоль не готова
		mov	R2, @#177566		; выдача символа на печать
X3RTN:		add	#2 ,R3			;
		mov	R3, PC			; выход	из подпрограммы
;_______________________________________________________________________
;
; Получение восьмеричного числа
;
GETNUM:		bic	R0, R0			; очистка R0
2$:		mov	PC, R3			;
		bne	GETCHR			; получение очередного символа
		cmp	#15, R2			; получен код <BK>?
		beq	X1RTN			; да. выходим
		cmp	#52 ,R2			; получен код "*"?
		beq	X1RTN			; да, выходим
		mov	R2, SP			; пересылка символа в R6
		BIC	#7, SP			; очистка младших битов
		cmp	#60 ,SP			; правильный символ?
		bne	KBDCLR			; нет, начнем заново
		bic	#177770, R2		; выделение трех введенных битов
		add	R0, R0			; сдвиг старого кода влево
		add	R0, R0			;
		add	R0, R0			;
		add	R2, R0			; присоединение новых трех битов
		mov 	#2$, PC			; на получение следующего символа
;_______________________________________________________________________
;
; Печать восьмеричного числа
;
PUTNUM:		mov	R0, SP			; исходное число в R6
		mov	#60, R2			; константа для формирования символа
		bic	#77777, SP		; станший разряд единичный?
		beq	30$			; нет
		add	#1, R2			; формирование цифры для печати
30$:		add	R0, R0			; сдвиг исходного числа влево
		add	#1, R0			; вдвигаем 1 в младший разряд
31$:		mov	PC, R3			;
		bne	PUTCHR			; печать очередной цифры
		mov	#14, R2			; константа для формирования символа
		mov	R0, SP			;
		bic	#77777, SP		; очередной бит единичный?
		beq	33$			;
		add	#1, R2			; формирование цифры для печати
33$:		add	R0, R0			; сдвиг исходного числа влево
		mov	R0, SP			; пересылка в R6
		add	R2, R2			; сдвиг бита цифры влево
		bic	#77777, SP		; очередной бит цифры единичный?
		beq	34$			;
		add	#1, R2			; формирование цифры
34$:		add	R0, R0			; сдвиг исходного числа влево
		mov	R0, SP			; пересылка в R6
		add	R2, R2			; сдвиг бита цифры влево
		bic	#77777, SP		; очередной бит единичный?
		beq	35$			;
		add	#1, R2			; формирование очередной цифры
35$:		add	R0, R0			; сдвиг исходного числа влево
		beq	X1RT			; если коичество битов 16
		bne	31$			; на получение очередной цифры
X1RT:		mov	#40, R2			; печать пробела
		mov	PC, R3			;
		bne	PUTCHR			;
X1RTN:		add	#2, R1			;
		mov	R1, PC			; возврат из подпрограммы
;_______________________________________________________________________
;
; Обработка ошибки теста памяти
;
MEMERR:		add	#-2, R0			; коррекция адреса
		mov	R0, R4			; сохранение адреса
		mov	PC, R1			;
		bne	PUTCR			;
		mov	PC, R1			;
		bne	PUTNUM			; печать адреса
		mov	(R4)+, R0		;
		mov	PC, R1			;
		bne	PUTNUM			; печать результата
		mov	R5, R0			;
		mov	PC, R1			;
		bne	PUTNUM			; печать эталона
S50$:		mov	PC, R3			;
		bne	GETCHR			; ожидание ввода
;_______________________________________________________________________
;
; Возврат в тест памяти после ошибки
;
		mov	R4, R0			; восстановление адреса
		add	R5, R4			;
		add	#-1, R4			; идет ли информационный тест?
		bne	S53$			; возврат в адресный тест
		beq	S55$			; возврат в информационный тест
;_______________________________________________________________________
;
; Адресный тест памяти
; При ошибке выводится: адрес результат эталон
; Для продолжения введине любой символ
;
		ENDMEM	= 160000		;
TMEM:		bic	R0, R0			; установка начального адреса
51$:		mov	R0, R5			;
		mov	R5, (R0)+		; запись адреса в ячейку
		cmp	#ENDMEM, R0		; конечный адрес памяти?
		bne	51$			; нет, продолжаем
						;
						; Чтение и проверка записанного
		bic	R0, R0			; установка начального адреса
S52$:		mov	R0, R5			;
		cmp	(R0)+, R5		; сравнение и продвижение адреса
		bne	MEMERR			; переход на печать ошибки
S53$:		cmp	#ENDMEM, R0		; конечный адрес памяти?
		bne	S52$			; нет, продолжаем
;_______________________________________________________________________
;
; Информационный тест памяти
; Информация обратная адресу
;
		bic	R0, R0			; установка начального адреса
S54$:		mov	#-1, R5			;
		bic	R0, R5			; формирование эталона
		mov	R5, 0(R0)		; запись эталона в память
		cmp	(R0)+, R5		; сравнение и продвижение адреса
		bne	MEMERR			; переход на печать ошибки
S55$:		bic	R2, R2			;
		mov	R2, -2(R0)		; 104~CTKA nPOBE~EHHO0 94E~K~
		cmp	#ENDMEM, R0		; конечный адрес памяти?
		bne	S54$			; нет, продолжаем
						;
						; выход из теста памяти
		cmp	#S50$, R3		; была ли печать?
		beq	JMPEM			; была, возврат в эмулятор
		mov	R3, R0			; восстановление в R0 номера устройства
GOBOOT:		add	#2, R4			; коррекция адреса загрузчика
		mov	R4, R5			; R5 стартовый адрес загрузчика
		bne	START			; выход на загрузку
;_______________________________________________________________________
;
; Возврат в эмулятор
;
RETEM:		mov	R1, R4			; восстаном старую команду
JMPEM:		mov	#CONSEM, PC		; возврат в эмулятор
		.word	0			;
;_______________________________________________________________________
;
; Выход на Т2 и ТМЕМ перед загрузкой
;
		.	= BGSL3+724		;
S60$:		cmp	#15, R2			; если ввод команды закончен не <BK>
		bne	GOBOOT			; то тесты перед загрузкой не выполнять
		mov	R0, R3			; сохранение номера устройства в R3
 		mov	#200, @#173024		; переход во второй слой на тест Т2
		.word	-1, -1			;
;_______________________________________________________________________
;
; Поиск адреса начала загрузчика
;
		.	= BGSL3+746		;
CHECK:		mov	#0, @#173024		; переход в нулевой слой
;_______________________________________________________________________
;
; Загрузчик найден
; Прием с клавиатуры номер устройства
;
		mov 	#S60$-2, R1		; после ввода возврат на 60$
		mov	#GETNUM, PC		; ввод номера устройства
		.word	-1, -1, -1, -1		;
;_______________________________________________________________________
;
; Выполнение команды "START" и выход на загрузку
START:		reset				
;
; Возврат из нулевого слоя, если загрузчик не найден
;
		bne RETEM
		.dsabl	LSB
;_______________________________________________________________________
;
; Дамп,	прочитанный из реальной	машины,	совпадает с результатом	компиляции (кроме 173024)
;
	.iff
		.word	177777, 177777, 177777, 010500, 010701, 001103, 010701, 001167
		.word	001003, 000000, 173000, 000343, 010701, 001073, 012702, 000077
		.word	010703, 001114, 010703, 001012, 060202, 060202, 060202, 060202
		.word	060202, 060202, 060202, 060202, 010201, 010703, 001066, 060102
		.word	010401, 022702, 046040, 001430, 020402, 001002, 062705, 000002
		.word	010204, 022702, 042440, 001006, 010500, 010701, 001120, 011500
		.word	012707, 173014, 022702, 042040, 001414, 022702, 051415, 001002
		.word	012707, 173774, 012707, 173746, 010701, 001052, 010005, 040404
		.word	001713, 010500, 010701, 001073, 010701, 001042, 010015, 012707
		.word	173030, 012702, 010012, 010703, 001021, 042702, 000377, 062702
		.word	177000, 001531, 062702, 000015, 001366, 013706, 177560, 042706
		.word	177577, 001773, 013702, 177562, 042702, 177600, 013706, 177564
		.word	042706, 177577, 001773, 010237, 177566, 062703, 000002, 010307
		.word	040000, 010703, 001352, 022702, 000015, 001475, 022702, 000052
		.word	001472, 010206, 042706, 000007, 022706, 000060, 001310, 042702
		.word	177770, 060000, 060000, 060000, 060200, 012707, 173322, 010006
		.word	012702, 000060, 042706, 077777, 001402, 062702, 000001, 060000
		.word	062700, 000001, 010703, 001322, 012702, 000014, 010006, 042706
		.word	077777, 001402, 062702, 000001, 060000, 010006, 060202, 042706
		.word	077777, 001402, 062702, 000001, 060000, 010006, 060202, 042706
		.word	077777, 001402, 062702, 000001, 060000, 001401, 001343, 012702
		.word	000040, 010703, 001263, 062701, 000002, 010107, 062700, 177776
		.word	010004, 010701, 001226, 010701, 001312, 012400, 010701, 001307
		.word	010500, 010701, 001304, 010703, 001230, 010400, 060504, 062704
		.word	177777, 001013, 001425, 040000, 010005, 010520, 022700, 160000
		.word	001373, 040000, 010005, 022005, 001341, 022700, 160000, 001372
		.word	040000, 012705, 177777, 040005, 010560, 000000, 022005, 001326
		.word	040202, 010260, 177776, 022700, 160000, 001363, 022703, 173566
		.word	001406, 010300, 062704, 000002, 010405, 001030, 010104, 012707
		.word	173030, 000000, 022702, 000015, 001365, 010003, 012737, 000200
		.word	173024, 177777, 177777, 012737, 000000, 173024, 012701, 173722
		.word	012707, 173320, 177777, 177777, 177777, 177777, 000005, 001346
	.endc
;_______________________________________________________________________
;
		.end
