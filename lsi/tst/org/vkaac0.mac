;
;			IDENTIFICATION
;			--------------
;
; PRODUCT CODE:		AC-8186C-MC
; PRODUCT NAME:		CVKAAC0	CSI-11 BSC INST
; PRODUCT DATE:		01-NOVEMBER-1978
; MAINTAINER:		DIAGNOSTIC ENGINEERING
; AUTHOR:		PERVEZ A. ZAKI
; MODIFIED BY:		BARRY SUSSMAN 01-NOV-77	A
;			BARRY SUSSMAN 01-NOV-77	A
;
; The information in this document is subject to change	without
; notice and should not	be construed as	a commitment by	Digital
; Equipment Corporation. Digital Equipment Corporation assumes no
; responsibility for any error that may	appear in this document.
;
; No responsibility is assumed for the use or reliability of
; software on equipment	that is	not supplied by	Digital	or its
; affiliated companies.
;
; Copyright (c)	1975, 1978 by Digital Equipment	Corporation
;
; The following	are trademarks of Digital Equipment Corporation:
;
;  DIGITAL	PDP		UNIBUS		MASSBUS
;  DEC		DECUS		DECTAPE
;_____________________________________________________________________________
;
;			CONTENTS
;			--------
; 1.	Abstract
; 2.	Requirements
; 2.1	Equipment
; 2.2	Storage
; 2.3	Preliminary programs
; 3.	Loading	procedure
; 4.	Starting procedure
; 4.1	Starting address
; 4.2	Program	and/or operator	action
; 5.	Operating procedure
; 6.	Errors
; 6.1	Error reporting
; 6.2	Error recovery
; 7.	Restrictions
; 8.	Miscellaneous
; 8.1	Execution time
; 8.2	Stack pointer
; 8.3	Pass counter
; 8.4	Test number
; 8.5	Power fail
; 9.	Program	description
;_____________________________________________________________________________
;
; 1.	Abstract
;
;	This program tests the LSI-11 basic instruction	set
;	in all modes. The diagnostic is	designed to run	under
;	both APT and ACT systems
;
; 2.	Requirements
; 2.1	Equipment
;
;	LSI-11 standard	computer and 4K	of memory
;
; 2.2	Storage
;
;	Program	storage	- the routines use memory 0-17500
;
; 2.3	Preliminary programs
;
;	None
;
; 3.	Loading	procedure
;
;	Use standard procedure for abs tapes.
;
; 4.	Starting procedure
; 4.1	Starting address
;
;	After loading the program it should always be started at 200.
;	if it is desired to save the pass counter then clear the
;	location $TESTN	(i.e. location 102) and	restart	from 450 otherwise
;	the program can	be restarted at	200. If	it is desired to go to a test
;	other than test	#0 then	place the test number in location $TESTN
;	and restart the	program	at 450,	in which case the program will halt
;	at location 464	and will wait for the operator to place	the
;	starting address of the	desired	test in	PC (R7)	and type a P.
;
; 4.2	Program	and/or operator	action
;
;	1) Place LTC switch in off position.
;	2) Load	program	into memory using abs loader.
;	3) Type	200G (there are	no switch settings and this diagnostic
;	   does	not use	software switch	location $SWREG)
;	4) The program will loop and "END PASS"	will be	typed after
;	   the first pass and then every 377 passes. However type out
;	   will	be suppressed if bit 5 of location $ENVM is high
;	5) A minimum of	two passes should always be run.
;
; 5.	Operating procedure
; 5.1	Operating mode
;
;	An 8-bit byte $ENVM (i.e. location 117)	has been used to define
;	the operating mode. All	typeouts can be	suppressed by making
;	bit 5 of byte $ENVM high. In other words by placing a 20000 in
;	location 116.
;
; 5.2	Trap catcher
;
;	A ".+2"	- "HALT" sequence is repeated from 0-776 to catch
;	any unexpected traps. Thus any unexpected traps	or interrupts
;	will halt at the vector	+2.
;
; 6.	Errors
; 6.1	Error reporting
;
;	On finding an error the	processor will come to a halt after
;	placing	the error number in location $FATAL (i.e. location 100).
;	In most	cases the comments besides the halts tell what was being
;	checked. In some cases the test	can get	to a halt via 2	ways:
;
;		1) wrong test sequence
;		2) error in actual test
;
;	When a halt does occur it is recommended that the test sequence
;	location (i.e. location	102) be	checked	to verify that it matches
;	the present test number. If it doesn't,	then the halt occurred
;	because	the test sequence was not correct otherwise the	halt is
;	due to an error	in the test.
;
; 6.2	Error recovery
;
;	Restart	at 200 or 450 (see sec 4.1)
;
; 7.	Restrictions
;
;	None
;
; 8.	Miscellaneous
; 8.1	Execution time
;
;	Execution time of the diagnostic is less than a	second,	first
;	"END PASS" will	be typed out within a second and every consecutive
;	"END PASS" will	be typed out within 20 seconds (see sec	4.2)
;
;	When running under apt in a script, the	first pass run time
;	and subsequent pass run	times are one (1) second.
;
; 8.2	Stack pointer
;
;	Stack is initially set to 450
;
; 8.3	Pass count
;
;	A 16-bit location "$PASS" (i.e.	location 104) is used to keep
;	pass count. It can be cleared by restarting the	program	at 200
;
; 8.4	Test number
;
;	A 16-bit location "$TESTN" (i.e. location 102) is used to keep track
;	of the test number, upper byte of this location	gives the iteration
;	number and the lower byte the test that	was being executed
;
; 8.5	Power fail
;
;	The diagnostic can be power failed with	no errors. To use,
;	start the diagnostic as	usual and power	down then up at	any time.
;	The program should type	"POWER"	and restart at 450 with	test #0.
;	However	the diagnostic will not	recover	if it is stored	in a
;	memory not capable of holding data with	power down
;
; 9.	Program	description
;
;	This program tests all the basic instructions of the LSI-11 (except
;	trap-type) which includes control chip,	data chip, micROMs, PLA
;	and other circuitry on the LSI-11 CPU module. Trap diagnostic
;	should also be run make	sure that the basic LSI-11 is functional.
;	This diagnostic	does not make a	pass with T-bit	set.
;_____________________________________________________________________________
;
		HOEP	= 0			; halt on end-of-pass
;_____________________________________________________________________________
;
; LSI-11 macro instruction exerciser
;
		.asect
		.nlist	mc, md,	cnd
		.list	me
		.title	CVKAAC
;_____________________________________________________________________________
;
; Copyright (c)	1975, 1978  Digital Equipment Corp.
; Maynard, Mass. 01754
;
; Program by Pervez Zaki
;
; This program was assembled using the PDP-11 maindec sysmac
; package (maindec-11-dzqac-c3), Jan 19, 1977.
;
		$tn	= 1			;
		$swr	= 160000		; halt on error,
		.	= 0			; loop on test
						; inhibit error	typeout
;_____________________________________________________________________________
;
; Trap catchers	of .+2 and halt	in locations 0 thru 776	(it is nlisted)
; Hooks	required by act11
;
;		$svpc	= .			; save PC
;		.	= 46			; set loc 46 to	address
;		$endad				; of $endad in $eop
;		.	= 52			;
;		.word	0			;
;		.	= $svpc			; restore PC
;						;
		R0	= %0			;
		R1	= %1			;
		R2	= %2			;
		R3	= %3			;
		R4	= %4			;
		R5	= %5			;
		SP	= %6			;
		PC	= %7			;
						;
		clnz	= 254			;
		errnm	= 1			;
		nops	= 260			;
		sevc	= 263			;
		senvc	= 273			;
		$tn	= 0			;
		.type	= iot			;
;_____________________________________________________________________________
;
		.macro	jmpR0			; MACRO-11 generates an	error Z
		.word	000120			; jmp (R0)+ works differently
		.endm				; on PDP-11 models
						;
		.macro	jsrR0			;
		.word	004720			; jsr PC, (R0)+
		.endm				;
						;
		.macro	movR0p			;
		.word	010020			; mov R0, (R0)+
		.endm				;
						;
		.macro	movR0m			;
		.word	010040			; mov R0, -(R0)
		.endm				;
						;
		.macro	addR0			;
		.word	060020			; add R0, (R0)+
		.endm				;
;_____________________________________________________________________________
;
		.macro	vect, offset, adr, val	;
		.	= offset		;
	.if	nb, <adr>			;
		.word	adr			;
	.iff					;
		.word	.+2			;
	.endc					;
	.if	nb, <val>			;
		.word	val			;
	.iff					;
		.word	0			;
	.endc					;
		.endm				;
;_____________________________________________________________________________
;
		.nlist
		vect	0			;
		vect	4			;
		vect	10			;
		vect	14			;
		vect	20, type		; type out the message
		vect	24, 200			; power	fail entry
		vect	30			;
		vect	34			;
		vect	40			;
		vect	44, $apthd, $endad	;
		vect	50			;
		vect	54			;
		vect	60			;
		vect	64			;
		vect	70			;
		.list				;
;_____________________________________________________________________________
;
; APT mailbox-etable
;
		. = 74				;
		.word	76			; overlapping with vector
		.even				;
$mail:				;		; apt mailbox
$msgty:		.word	0	; amsgty	; message type code
$fatal:		.word	0	; afatal	; fatal	error number
$testn:		.word	0	; atestn	; test number
$pass:		.word	0	; apass		; pass count
$devct:		.word	0	; adevct	; device count
$unit:		.word	0	; aunit		; I/O unit number
$msgad:		.word	0	; amsgad	; message address
$msglg:		.word	0	; amsglg	; message length
$etable:			;		; apt environment table
$env:		.byte	0	; aenv		; environment byte
$envm:		.byte	0	; aenvm		; environment mode bits
$swreg:		.word	0	; aswreg	; apt switch register
$uswr:		.word	0	; auswr		; user switches
$cpuop:		.word	0	; acpuop	; cpu type, options
						; bits 15-11=cpu type
						;	11/04=01, 11/05=02
						;	11/20=03, 11/40=04
						;	11/45=05, 11/70=06
						;	PDQ=07,	Q=10
						; bit 10 - real	time clock
						; bit 9	- floating point
$etend:						; bit 8	- memory management
;_____________________________________________________________________________
;
; APT parameter	block
; Set locations	24 and 44 as required for apt (set above by vect macro)
;
;		.$x	= .			; save current location
;		.	= 24			; set power fail to start
;		200				; of program for apt start up
;		.	= 44			; point	to apt indirect	address
;		$apthd				; point	to apt header block
;		.	= .$x			; reset	location counter
;
; Setup	apt parameter block as defined in the apt-pdp11	diagnostic
; interface spec.
;
$apthd:
$hibts:		.word	0			; two high bits	of 18 bit mailbox
$mbadr:		.word	$mail			; address of apt mailbox (0-15)
$tstm:		.word	1			; run time of longest test
$pastm:		.word	1			; run time in secs of 1st pass
$unitm:		.word	0			; additional run time (secs)
						; of a pass for	each add unit
		.word	$etend-$mail/2		; length of mailbox-etable
						;
		. = $apthd			;
adr:						;
		. = adr	+ 2			;
adr1:						;
		. = adr1 + 2			;
adr2:						;
		. = adr2 + 2			;
dummy:						;
		. = dummy + 2			;
temp:						;
		. = temp + 2			;
temp1:						;
		. = temp1 + 2			;
temp2:						;
		. = temp2 + 2			;
						;
tps:		.word	177564			; output TTY status
tpb:		.word	177566			; output TTY buffer
						;
mark2:		mark	2			;
endpas:		.asciz	<15><12>" END PASS"	;
		.even				;
power:		.asciz	<15><12>/POWER/		;
		.even				;
		.blkw	19.			;
;		.	= 20			;
;		type				; type routine
;		0				; generated by vect
;_____________________________________________________________________________
;
; Starting of the program
;
		.	= 200			;
		mov	#pwrdn,	@#24		; service power	down routine
		mov	#$etable, R0		; on any future	power down
2$:		clr	-(R0)			; start	cleaning the stack
		cmp	R0, #$mail		; for initialization
		bhi	2$			;
		jmp	start			;
						;
		vect	230			;
		vect	234			;
		vect	240			;
		vect	244			;
		vect	250			;
		vect	254			;
		vect	260			;
		vect	264			;
		vect	270			;
		vect	274			;
		vect	300			;
		vect	304			;
		vect	310			;
		vect	314			;
		vect	320			;
		vect	324			;
		vect	330			;
		vect	334			;
		vect	340			;
		vect	344			;
		vect	350			;
		vect	354			;
		vect	360			;
		vect	364			;
		vect	370			;
		vect	374			;
		vect	400			;
		vect	404			;
		vect	410			;
		vect	414			;
		vect	420			;
		vect	424			;
		vect	430			;
		vect	434			;
		vect	440			;
		vect	444			;
;_____________________________________________________________________________
;
		.	= 450			;
start:		mov	#start,	SP		; set the stack	pointer
		mov	#$testn, R5		; the address of testn in R5
		tst	(R5)			; check	the sequence counter
		beq	nobit			; if this is the starting of
						; the test then	go to nobit test
		halt				; otherwise halt and wait for
						; the operator to start	at the
						; proper test number
;_____________________________________________________________________________
;
; TEST 0 - check branch	instructions with zero condition codes
;
nobit:		cmp	(R5), #0		; if in	wrong sequence go to
		bne	cc0			; halt at end of the test
1$:		inc	(R5)			;
		ccc				; zero condition codes
		bcs	cc0			; NZVC = 0000
		bvs	cc0			;
		beq	cc0			;
		bmi	cc0			;
		nops				; check	nops instruction
		bcs	cc0			; (opcode 260)
		bvs	cc0			;
		beq	cc0			;
		bmi	cc0			;
		blt	cc0			;
		ble	cc0			;
		blos	cc0			;
		bhi	endcc0			;
						;
cc0:		mov	#1, -(R5)		; one of the above branches
		inc	-(R5)			; failed or wrong sequence
		halt				;
endcc0:		bvc	nbit			;
;_____________________________________________________________________________
;
; TEST 1 - check branch	instructions with N-bit	set
;
nbit:		cmp	(R5), #1		; if in	wrong sequence go to
		bne	cc1			; halt at end of the test
1$:		inc	(R5)			;
		sen				; N-bit	is set,	NZVC = 1000
		bpl	cc1			;
		beq	cc1			;
		bge	cc1			;
		bgt	cc1			;
		bcs	cc1			;
		blos	cc1			;
		blo	cc1			;
		ble	endcc1			;
						;
cc1:		mov	#2, -(R5)		; one of the above branches
		inc	-(R5)			; failed or wrong sequence
		halt				;
endcc1:		bne	vbit			;
;_____________________________________________________________________________
;
; TEST 2 - check branch	instructions with N&V bits set
;
vbit:		cmp	(R5), #2		;
		bne	cc2			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		sen				;
		sev				; V and	N bit set, NZVC	= 1010
		bvc	cc2			;
		beq	cc2			;
		bpl	cc2			;
		bcs	cc2			;
		blt	cc2			;
		ble	cc2			;
		blos	cc2			;
		blo	cc2			;
		bgt	endcc2			;
						;
cc2:		mov	#3, -(R5)		; one of the above branches
		inc	-(R5)			; failed or wrong sequence
		halt				;
endcc2:		bge	cbit			;
;_____________________________________________________________________________
;
; TEST 3 - check branch	instructions with N, V&C bits set
;
cbit:		cmp	(R5), #3		;
		bne	cc3			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		sen				;
		sev				; C, V and N bits are set
		sec				; NZVC = 1011
		beq	cc3			;
		bpl	cc3			;
		bvc	cc3			;
		blt	cc3			;
		ble	cc3			;
		bhi	cc3			;
		bge	zbit			;
						;
cc3:		mov	#4, -(R5)		; one of the above branches
		inc	-(R5)			; failed or wrong sequence
		halt				;
;_____________________________________________________________________________
;
; TEST 4 - check branch	instructions with N, Z,	V&C bits set
;
zbit:		cmp	(R5), #4		;
		bne	cc4			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		sen				;
		sev				;
		sec				;
		sez				; all bits set,	NZVC = 1111
		bne	cc4			;
		bpl	cc4			;
		bvc	cc4			;
		bcc	cc4			;
		blt	cc4			;
		bgt	cc4			;
		bhi	cc4			;
		beq	yescc			;
						;
cc4:		mov	#5, -(R5)		; one of the above branches
		inc	-(R5)			; failed or wrong sequence
		halt				;
;_____________________________________________________________________________
;
; TEST 5 - check branch	instructions with all the condition codes set
;
yescc:		cmp	(R5), #5		;
		bne	cc6			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		scc				; NZVC = 1111
		bpl	cc6			;
		bne	cc6			;
		bvc	cc6			;
		bcc	cc6			;
		nop				; check	nop instruction
		bpl	cc6			;
		bne	cc6			;
		bvc	cc6			;
		bcc	cc6			;
		blos	notcc			;
						;
cc6:		mov	#6, -(R5)		; one of the above branches
		inc	-(R5)			; failed or wrong sequence
		halt				;
;_____________________________________________________________________________
;
; TEST 6 - clear the condition codes
;
notcc:		cmp	(R5), #6		;
		bne	cc5			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		scc				; NZVC = 1111
		clc				; NZVC = 1110
		bcs	cc5			;
		clv				; NZVC = 1100
		bvs	cc5			;
		clz				; NZVC = 1000
		beq	cc5			;
		cln				; NZVC = 0000
		bmi	cc5			;
		bhi	endcc5			;
cc5:		mov	#7, -(R5)		; one of the above branches
		inc	-(R5)			; failed or wrong sequence
		halt				;
endcc5:		bpl	branch			;
;_____________________________________________________________________________
;
; TEST 7 - check upward	and backward branches
;
branch:		cmp	(R5), #7		;
		beq	1$			; if in	wrong sequence
		mov	#10, -(R5)		; go to	halt
		inc	-(R5)			;
		halt				;
1$:		inc	(R5)			;
		br	4$			; check	branch forward
		mov	#11, -(R5)		; and backward
		inc	-(R5)			; forward branch failed
		halt				;
2$:		br	3$			;
		mov	#12, -(R5)		;
		inc	-(R5)			; forward branch failed
		halt				;
3$:		br	5$			;
		mov	#13, -(R5)		;
		inc	-(R5)			;
		halt				; forward branch failed
4$:		br	2$			;
		mov	#14, -(R5)		;
		inc	-(R5)			;
		halt				; backward branch failed
5$:		br	jmp1			;
;_____________________________________________________________________________
;
; TEST 10 - check jmp instructions for mode 1
;
jmp1:		cmp	(R5), #10		;
		bne	endjp1			; if in	wrong sequence go to
1$:		inc	(R5)			; halt at the end of the test
		mov	#2$, R0			; test jump instruction	mode 1
		scc				;
		jmp	(R0)			;
		mov	#15, -(R5)		;
		inc	-(R5)			;
		halt				; jump instruction failed
						;
2$:		bpl	3$			;
		bne	3$			;
		bvc	3$			;
		bcs	4$			;
3$:		mov	#16, -(R5)		;
		inc	-(R5)			;
		halt				; wrong	cc
						;
4$:		cmp	R0, #2$			;
		beq	5$			; continue if R0 is OK
		mov	#17, -(R5)		;
		inc	-(R5)			;
		halt				;
						;
5$:		mov	#jmp2, R0		; test jump instruction	mode 1
		jmp	(R0)			;
						;
endjp1:		mov	#20, -(R5)		;
		inc	-(R5)			; jump instruction failed
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 11 - check jmp instructions for modes 2 and 3
;
jmp2:		cmp	(R5), #11		;
		bne	endjp3			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of test
		mov	#3$, R0			; test jump instruction	mode 2
		scc				;
		jmpR0				; jmp (R0)+
		mov	#21, -(R5)		;
		inc	-(R5)			;
		halt				; jump instruction failed
						;
3$:		bpl	4$			;
		bne	4$			;
		bvc	4$			;
		bcs	5$			;
4$:		mov	#22, -(R5)		;
		inc	-(R5)			;
		halt				; wrong	cc
						;
5$:		cmp	R0, #3$+2		; is there auto	inc?
		beq	6$			;
		mov	#23, -(R5)		;
		inc	-(R5)			;
		halt				; mode 2 failed	for jmp	instruction
						;
6$:		mov   #jmp3, R0			; test jump instruction	mode 2
		jmpR0				; jmp (R0)+
		mov	#24, -(R5)		;
		inc   -(R5)			;
		halt				; jump instruction failed
						;
jmp3:		mov	#3$, temp		; test jump instruction	mode 3
		mov	#4$, temp+2		;
		mov	#temp, R0		;
		scc				;
		jmp	@(R0)+			;
		mov	#25, -(R5)		;
		inc	-(R5)			;
		halt				; jump instruction failed
						;
3$:		cmp	@(R0), 4$		; is there auto	inc?
		beq	4$			;
		mov	#26, -(R5)		;
		inc	-(R5)			;
		halt				; jmp instruction failed in mode 2
						;
4$:		mov	#jmp4, temp		; test jump instruction	mode 3
		mov	#temp, R0		;
		jmp	@(R0)+			;
endjp3:		mov	#27, -(R5)		;
		inc	-(R5)			;
		halt				; lmp error or wrong sequence
;_____________________________________________________________________________
;
; TEST 12 - test jump instruction for mode 4, 5
;
jmp4:		cmp	(R5), #12		;
		bne	endjp5			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		mov	#3$, R0			; test jump instruction	mode 4
		scc				;
		jmp	-(R0)			;
		mov	#30, -(R5)		;
		inc	-(R5)			;
		halt				; jump instruction failed
		br	4$			; jump should land here
						;
3$:		mov	#31, -(R5)		;
		inc	-(R5)			;
		halt				; no auto decrement from jmp4
						;
4$:		cmp	#3$-2, R0		; check	R0
		beq	5$			;
		mov	#32,-(R5)		;
		inc	-(R5)			;
		halt				;
						;
5$:		mov	#jmp5+2, R0		; test jump instruction	mode 4
		jmp	-(R0)			;
		mov	#33, -(R5)		;
		inc	-(R5)			;
		halt				; jump instruction failed
						;
jmp5:		mov	#3$, temp1		; test jump instruction	mode 5
		mov	#temp1,	R0		;
		mov	#4$,temp1-2		;
		jmp	@-(R0)			;
		mov	#34, -(R5)		;
		inc	-(R5)			;
		halt				; jump instruction failed
						;
3$:		mov	#35, -(R5)		;
		inc	-(R5)			;
		halt				; error, no auto decrement
						;
4$:		cmp	#temp1-2, R0		; check	R0
		beq	5$			;
		mov	#36, -(R5)		;
		inc	-(R5)			; jump instruction
		halt				; failed in mode 5
5$:		mov	#3$, temp1		; test jump instruction	mode 5
		mov	#temp1,	R0		;
		mov	#jmp6, temp1-2		;
		jmp	@-(R0)			;
						;
endjp5:		mov	#37, -(R5)		;
		inc	-(R5)			;
		halt				; jump error or	wrong sequence
;_____________________________________________________________________________
;
; TEST 13 - test jmp instruction for mode 6 and	7
;
jmp6:		cmp	(R5), #13		;
		bne	endjp7			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		mov	#1$+6, R3		;
		jmp	-6(R3)			;
		mov	#40, -(R5)		;
		inc	-(R5)			;
		halt				; jump instruction failed
						;
1$:		cmp	R3, #1$+6		; check	R3
		beq	2$			;
		mov	#41, -(R5)		; wrong	value in register after
		inc	-(R5)			; jump mode 6 or jump instruction
		halt				; failed in mode 6
						;
2$:		jmp	3$-.-4(PC)		; test jump instruction	mode 6
		mov	#42, -(R5)		;
		inc   -(R5)			;
		halt				; jump instruction failed
						;
3$:		mov	#jmp7, R3		; jump should land here
		jmp	0(R3)			;
		mov	#43, -(R5)		;
		inc	-(R5)			;
		halt				; jump instruction failed
						;
jmp7:		mov	#temp, R3		;
		mov	#1$, (R3)		;
		jmp	@(R3)			;
		mov	#44, -(R5)		;
		inc	-(R5)			;
		halt				; jump instruction failed
						;
1$:		mov	#3$, (R3)		; test jump instruction	mode 7
		mov	#temp-4, R0		;
		jmp	@4(R0)			;
		mov	#45, -(R5)		;
		inc	-(R5)			;
		halt				; jump instruction failed
						;
3$:		mov	#jsrtst, temp		; continue
		mov	#temp, R0		;
		jmp	@0(R0)			;
						;
endjp7:		mov	#46, -(R5)		;
		inc	-(R5)			;
		halt				; jump error or	sequence error
;_____________________________________________________________________________
;
; TEST 14 - check jsr and mark instructions
;
jsrtst:		cmp	(R5), #14		;
		bne	endjsr			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		mov	#start,	SP		; set up stack pointer
		scc				;
		jsr	PC, 3$			;
1$:		mov	#47, -(R5)		;
		inc	-(R5)			;
		halt				; jsr instruction failed
						;
2$:		cmp	#start,	SP		; has SP been restored?
		beq	jsrm			;
		mov	#50, -(R5)		;
		inc	-(R5)			; SP was not restored by
		halt				; rts instruction
						;
3$:		bpl	4$			;
		bne	4$			;
		bvc	4$			;
		bcs	5$			;
4$:		mov	#51, -(R5)		;
		inc	-(R5)			;
		halt				; wrong	cc
						;
5$:		cmp	#start-2, SP		; was the SP effected?
		beq	6$			;
		mov	#52, -(R5)		;
		inc	-(R5)			; wrong	SP after execution
		halt				; of jsr instruction
						;
6$:		cmp	#1$, (SP)		; is the return	address	1$?
		beq	7$			;
		mov	#53, -(R5)		;
		inc	-(R5)			; SP did not have correct
		halt				; return address after
						; execution of jsr instruction
7$:		mov	#2$, (SP)		; set 2$ as the	return address
		RTS	PC			;
		mov	#54, -(R5)		;
		inc	-(R5)			;
		halt				; rts instruction failed
						;
jsrm:		mov	R5,-(SP)		; mov R5 to stack
		mov	dummy, -(SP)		;
		mov	dummy, -(SP)		;
		mov	mark2, -(SP)		; store	mark 2 on the stack
		mov	R5, R3			; save R5 in R3
		jsr	R4, 10$			;
						;
1$:		mov	#55, -(R5)		;
		inc	-(R5)			;
		halt				; jsr instruction failed
						;
2$:		bpl	3$			;
		bne	3$			;
		bvc	3$			;
		bcs	4$			;
3$:		mov	#56, -(R3)		;
		inc	-(R3)			;
		halt				; wrong	cc
						;
4$:		cmp	#$testn, R5		;
		beq	5$			;
		mov	#57, -(R3)		;
		inc	-(R3)			;
		halt				; mark instruction failed
						;
5$:		cmp	#start,	SP		;
		beq	6$			;
		mov	#60, -(R5)		;
		inc	-(R5)			;
		halt				; mark instruction failed
						;
6$:		mov	#12$, R1		; place	the address of 12$
		jsr	R0, (R1)		; in R1	go to tag 12$
7$:		mov	#61, -(R5)		;
		inc	-(R5)			;
		halt				; jsr instruction failed
		mov	#62, -(R5)		;
		inc	-(R5)			; rts brought the program
		halt				; back in wrong	place
						;
8$:		cmp	#start,	SP		;
		beq	regs			;
		mov	#63, -(R5)		;
		inc	-(R5)			;
		halt				; stack	pointer	was not	reset
						;
10$:		cmp	R4, #1$			; is the return	address	= 1$ ?
		beq	11$			;
		mov	#64, -(R5)		;
		inc	-(R5)			; wrong	return address
		halt				; in linkage register R4
						;
11$:		mov	SP, R5			; set up address in R5
		tst	(R5)+			; at mark 2 instruction
		mov	#2$, (SP)		; set return address
		scc				;
		rts	R5			; return using R5 and in-turn
		mov	#65, -(R5)		; using	mark instruction
		inc	-(R5)			;
		halt				; rts instruction failed
						;
12$:		cmp	R0, #7$			; does R0 contain
		beq	13$			; the return address ?
		mov	#66, -(R5)		;
		inc	-(R5)			; wrong	return address in
		halt				; linkage register R0
						;
13$:		mov	#8$, R0			; set return address at	8$
		rts	R0			;
						;
endjsr:		mov	#67, -(R5)		;
		inc	-(R5)			; rts instruction failed
		halt				; or sequence error
;_____________________________________________________________________________
;
; TEST 15 - check register selection
;
regs:		cmp	(R5), #15		;
		bne	eregs			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		mov	SP, temp		; save the stack pointer
		mov	#1, R0			; load the registers
		mov	#4, R1			;
		mov	#20, R2			;
		mov	#100, R3		;
		mov	#400, R4		;
		clr	SP			;
		add	R0, SP			; add up the registers
		add	R1, SP			;
		add	R2, SP			;
		add	R3, SP			;
		add	R4, SP			;
		add	R5, SP			;
		cmp	#$testn+525, SP		; check	it
		bne	1$			; failed
		mov	temp, SP		; restore stack	pointer
		br	tstb0			; continue
1$:		mov	temp, SP		; restore stack	pointer
eregs:		mov	#70, -(R5)		;
		inc	-(R5)			; register selection failure
		halt				; or sequence error
;
; check	byte instructions, destination mode 0 only
;_____________________________________________________________________________
;
; TEST 16 - new	instructions used in this section are tstb, clrb, movb
;
tstb0:		cmp	(R5), #16		;
		beq	2$			; if in	wrong sequence
		mov	#71, -(R5)		; go to	halt below
		inc	-(R5)			;
		halt				; program is in	wrong sequence
						;
2$:		inc	(R5)			;
		scc				;
		clrb	R0			; clear	the register
		jsr	PC, @#$cc4		; check	for cc = 4
		tstb	R0			; check	it
		jsr	PC, @#$cc4		; check	for cc = 4
		movb	#377, R1		; load the register
		jsr	PC, @#$cc10		; check	for cc = 10
		tstb	R1			; check	it
		jsr	PC, @#$cc10		; check	for cc = 10
;_____________________________________________________________________________
;
; TEST 17 - new	instructions used in this section are cmpb, bisb
;
cmpb0:		cmp	(R5), #17		;
		bne	ecmpb0			; if in	wrong sequence go to
1$:		inc	(R5)			; halt at the end of the test
		scc				;
		bisb	#377, R2		; load register
		jsr	PC, @#$cc11		; check	for cc = 11
		cmpb	#377, R2		; check	compare
		beq	2$			; continue if OK
		mov	#72, -(R5)		;
		inc	-(R5)			; bisb or cmpb
		halt				; instruction failed
						;
2$:		movb	#77, R0			;
		cmpb	R0, R2			; check	it again
		bpl	3$			; continue if OK
		mov	#73, -(R5)		;
		inc	-(R5)			; cmpb instruction failed
		halt				; (wrong cc)
						;
3$:		cmpb	R2, R0			; once more
		bmi	4$			; continue if OK
		mov	#74, -(R5)		;
		inc	-(R5)			; cmpb instruction failed
		halt				; (wrong cc)
						;
4$:		movb	#377, R2		; load register, sign extend
		cmpb	#377, R2		; check	if byte	instruction
		beq	5$			; continue if OK
		mov	#75, -(R5)		;
		inc	-(R5)			;
		halt				; cmpb became cmp instruction
						;
5$:		movb	#377, R2		; load register, sign extend
		cmpb	R2, #377		; check	if byte	instruction
		beq	bicb0			; continue if OK
ecmpb0:		mov	#76, -(R5)		;
		inc	-(R5)			;
		halt				; wrong	cc or wrong sequence
;_____________________________________________________________________________
;
; TEST 20 - new	instructions used in this section are bicb, bitb

bicb0:		cmp	(R5), #20		;
		beq	2$			; if in	wrong sequence
		mov	#77, -(R5)		; go to	hlt below
		inc	-(R5)			;
		halt				; program is in	wrong sequence
						;
2$:		inc	(R5)			;
		movb	#377, R3		; load register
		movb	#252, R0		; place	#252 in	R0
		scc				;
		bicb	R0, R3			; clear	every other bit
		jsr	PC, @#$cc1		; check	for cc = 1
		bitb	R0, R3			; check	it
		beq	4$			; continue if OK
		mov	#100, -(R5)		;
		inc	-(R5)			; bicb or bitb
		halt				; instruction failed
						;
4$:		bitb	#125, R3		; check	it
		jsr	PC, @#$cc1		; check	for cc = 1
		bisb	R0, R3			; set the bits that were cleared
		bmi	6$			;
		mov	#101, -(R5)		;
		inc	-(R5)			;
		halt				; bisb instruction failed
						; clear	all the	bits
6$:		bicb	#177, R3		; except for sign
		jsr	PC, @#$cc11		; check	for cc = 11
		bitb	#377, R3		; check	it
		jsr	PC, @#$cc11		; check	for cc = 11
;_____________________________________________________________________________
;
; TEST 21 - new	instructions used in this section are incb, decb
;
incb0:		cmp	(R5), #21		;
		beq	1$			; if in	wrong sequence
		mov	#102, -(R5)		; go to	halt below
		inc	-(R5)			;
		halt				; program is in	wrong sequence
						;
1$:		inc	(R5)			;
		movb	#177, R4		; R4 = 177
		sec				;
		incb	R4			; add ones into	R4
		jsr	PC, @#$cc13		; check	for cc = 13
		movb	#376, R4		;
		incb	R4			;
		jsr	PC, @#$cc11		; check	for cc = 11
		incb	R4			;
		jsr	PC, @#$cc5		; check	for cc = 5
		incb	R4			;
		jsr	PC, @#$cc1		; check	for cc = 1
		cmpb	#1, R4			; check	it
		beq	2$			; continue if OK
		mov	#103, -(R5)		;
		inc	-(R5)			;
		halt				; incb instruction failed
						;
2$:		sec				;
		decb	R4			; subtract ones	from reg
		jsr	PC, @#$cc5		; check	for cc = 5
		decb	R4			;
		jsr	PC, @#$cc11		; check	for cc = 11
		mov	#200, R4		;
		decb	R4			;
		jsr	PC, @#$cc3		; check	for cc = 3
		decb	R4			;
		jsr	PC, @#$cc1		; check	for cc = 1
;_____________________________________________________________________________
;
; TEST 22 - new	instruction in this section is comb
;
comb0:		cmp	(R5), #22		;
		beq	1$			; if in	wrong sequence
		mov	#104, -(R5)		; go to	halt below
		inc	-(R5)			;
		halt				; program is in	wrong sequence
						;
1$:		inc	(R5)			;
		movb	#252, R3		; load every other bit
		scc				;
		comb	R3			; 1's complement
		jsr	PC, @#$cc1		; check	for cc = 1
		cmpb	#125, R3		; check	it
		beq	2$			; continue if OK
		mov	#105, -(R5)		;
		inc	-(R5)			;
		halt				; comb instruction failed
						;
2$:		scc				;
		comb	R3			; complement back
		jsr	PC, @#$cc11		; check	for cc = 11
		cmpb	#252, R3		; check	it
		beq	3$			; continue if OK
		mov	#106, -(R5)		;
		inc	-(R5)			;
		halt				; comb instruction failed
						;
3$:		mov	#377, R3		;
		scc				;
		comb	R3			;
		jsr	PC, @#$cc5		; check	for cc = 5
;_____________________________________________________________________________
;
; TEST 23 - new	instruction in this section is negb
;
negb0:		cmp	(R5), #23		;
		bne	enegb0			; if in	wrong sequence go to
1$:		inc	(R5)			; halt at the end of the test
		movb	#1, R0			; load the register
		negb	R0			; 2's complement
		jsr	PC, @#$cc11		; check	for cc = 11
		cmpb	#377, R0		; check	it
		beq	2$			; continue if OK
		mov	#107, -(R5)		;
		inc	-(R5)			;
		halt				; negb instruction failed
						;
2$:		mov	#200, R0		;
		negb	R0			; 2's complement
		jsr	PC, @#$cc13		; check	for cc = 13
		cmpb	#200, R0		; check	it
		beq	rolb0			; continue if OK
enegb0:		mov	#110, -(R5)		;
		inc	-(R5)			; wrong	result in R0
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 24 - new	instruction in this section is rolb
;
rolb0:		cmp	(R5), #24		;
		bne	erolb0			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		movb	#40, R1			; load register
		ccc				; clear	flags
		rolb	R1			; shift
		rolb	R1			;
		jsr	PC, @#$cc12		; check	for cc = 12
		cmpb	#200, R1		; check	it
		beq	1$			; continue if OK
		mov	#111, -(R5)		;
		inc	-(R5)			;
		halt				; rolb instruction failed
						;
1$:		rolb	R1			; shift
		jsr	PC, @#$cc7		; check	for cc = 7
		rolb	R1			; shift
		cmpb	#1, R1			; check	it
		beq	rorb0			; continue if OK
erolb0:		mov	#112, -(R5)		;
		inc	-(R5)			; wrong	result in R1
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 25 - new	instruction in this section is rorb
;
rorb0:		cmp	(R5), #25		;
		bne	erorb0			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		movb	#4, R2			; load register
		ccc				; clear	flags
		rorb	R2			; shift
		rorb	R2			;
		cmpb	#1, R2			; check	it
		beq	1$			; continue if OK
		mov	#113, -(R5)		;
		inc	-(R5)			;
		halt				; rorb instruction failed
						;
1$:		rorb	R2			; shift
		jsr	PC, @#$cc7		; check	for cc = 7
		rorb	R2			; shift
		jsr	PC, @#$cc12		; check	for cc = 12
		cmpb	#200, R2		; check	it
		beq	aslb0			; continue if OK
erorb0:		mov	#114, -(R5)		;
		inc	-(R5)			;
		halt				;
;_____________________________________________________________________________
;
; TEST 26 - new	instruction in this section is aslb
;
aslb0:		cmp	(R5), #26		;
		beq	2$			; if in	wrong sequence
		mov	#115, -(R5)		; go to	halt below
		inc	-(R5)			;
		halt				; program is in	wrong sequence
						;
2$:		inc	(R5)			;
		movb	#40, R3			; load register
		ccc				; clear	flags
		aslb	R3			; shift
		aslb	R3			;
		jsr	PC, @#$cc12		; check	for cc = 12
		cmpb	#200, R3		; check	it
		beq	4$			; continue if OK
		mov	#116, -(R5)		;
		inc	-(R5)			;
		halt				; aslb instruction failed
						;
4$:		aslb	R3			; shift
		jsr	PC, @#$cc7		; check	for cc = 7
		aslb	R3			; shift
		jsr	PC, @#$cc4		; check	for cc = 4
;_____________________________________________________________________________
;
; TEST 27 - new	instruction in this section is asrb
;
asrb0:		cmp	(R5), #27		;
		bne	easrb0			; if in	wrong sequence go to
1$:		inc	(R5)			; halt at the end of the test
		movb	#4, R4			; load register
		ccc				; clear	flags
		asrb	R4			; shift
		asrb	R4			;
		cmpb	#1, R4			; check	it
		beq	2$			; continue if OK
		mov	#117, -(R5)		;
		inc	-(R5)			;
		halt				; asrb instruction failed
						;
2$:		asrb	R4			; shift
		jsr	PC, @#$cc7		; check	for cc = 7
		asrb	R4			; shift
		jsr	PC, @#$cc4		; check	for cc = 4
		movb	#202, R3		; load register
		asrb	R3			; shift
		asrb	R3			;
		jsr	PC, @#$cc11		; check	for cc =11
		cmpb	#340, R3		; check	it
		beq	adcb0			; continue if OK
						;
easrb0:		mov	#120, -(R5)		;
		inc	-(R5)			;
		halt				;
;_____________________________________________________________________________
;
; TEST 30 - new	instruction in this section is adcb
;
adcb0:		cmp	(R5), #30		;
		beq	2$			; if in	wrong sequence
		mov	#121,-(R5)		; go to	halt below
		inc	-(R5)			;
		halt				; program is in	wrong sequence
						;
2$:		inc	(R5)			;
		clrb	R0			; clear	the register
		ccc				; clear	flags
		adcb	R0			; add C	bit 0
		jsr	PC, @#$cc4		; check	for cc = 4
		sec				; C = 1
		adcb	R0			; add C	bit = 1
		sec				; C = 1
		adcb	R0			; again
		jsr	PC, @#$cc0		; check	for cc = 0
		cmpb	#2, R0			; check	it
		beq	4$			; continue if OK
		mov	#122, -(R5)		;
		inc	-(R5)			;
		halt				; adcb instruction failed
						;
4$:		movb	#177, R0		; load largest positive	number
		sec				; C = 1
		adcb	R0			; add C	bit = 1
		jsr	PC, @#$cc12		; check	for cc = 12
		cmpb	#200, R0		; check	it
		beq	6$			; continue if OK
		mov	#123, -(R5)		;
		inc	-(R5)			;
		halt				; adcb instruction failed
						;
6$:		movb	#377, R0		; load -1
		sec				; C = 1
		adcb	R0			; add C	bit = 1
		jsr	PC, @#$cc5		; check	for cc	= 5
;_____________________________________________________________________________
;
; TEST 31 - new	instruction in this section is sbcb
;
sbcb0:		cmp	(R5), #31		;
		beq	1$			; if in	wrong sequence go
		mov	#124, -(R5)		; to halt below
		inc	-(R5)			;
		halt				; program is in	wrong sequence
						;
1$:		inc	(R5)			; test is in wrong sequence
		movb	#3, R1			; load register
		ccc				; clear	flags
		sbcb	R1			; subtract C bit = 0
		jsr	PC, @#$cc0		; check	for cc	= 0
		cmpb	#3, R1			; check	it
		beq	2$			; continue if OK
		mov	#125, -(R5)		;
		inc	-(R5)			;
		halt				; sbcb instruction failed
						;
2$:		sec				; C = 1
		sbcb	R1			; subtract C bit = 1
		sec				;
		sbcb	R1			;
		jsr	PC, @#$cc0		; check	for cc = 0
		cmpb	#1, R1			; check	it
		beq	3$			; continue if OK
		mov	#126, -(R5)		;
		inc	-(R5)			;
		halt				;
						;
3$:		sec				;
		sbcb	R1			; subtract C bit = 1
		jsr	PC, @#$cc4		;
		sec				;
		sbcb	R1			;
		jsr	PC, @#$cc11		; check	for cc = 11
		cmpb	#377, R1		; check	it
		beq	4$			; continue if OK
		mov	#127, -(R5)		;
		inc	-(R5)			;
		halt				; sbcb instruction failed
						;
4$:		movb	#200, R1		; load R1
		sec				;
		sbcb	R1			; subtract C bit = 1
		jsr	PC, @#$cc2		; check	for cc = 2
;
; Check	word instructions, destination mode 0 only
;_____________________________________________________________________________
;
; TEST 32 - new	instructions used in this section are tst, clr,	mov
;
tst0:		cmp	(R5), #32		;
		beq	1$			; if in	wrong sequence
		mov	#130, -(R5)		; go to	halt below
		inc	-(R5)			;
		halt				; test is in wrong sequence
						;
1$:		inc	(R5)			;
		scc				;
		clr	R0			; clear	the register
		jsr	PC, @#$cc4		; check	for cc = 4
		tst	R0			; check	it
		jsr	PC, @#$cc4		; check	for cc = 4
		mov	#177777, R4		; load the register
		mov	R4, R1			;
		jsr	PC, @#$cc10		; check	for cc = 10
		tst	R1			; check	it
		jsr	PC, @#$cc10		; check	for cc = 10
		cmp	R4, R1			; check	R1 to contain
		beq	2$			; proper data
		mov	#131, -(R5)		;
		inc	-(R5)			;
		halt				;
						;
2$:		sevc				; set V	& C bits
		mov	R0, R0			;
		jsr	PC, $cc5		;
;_____________________________________________________________________________
;
; TEST 33 - new	instructions used in this section are cmp, bis
;
cmp0:		cmp	(R5), #33		;
		bne	ecmp0			; if in	wrong sequence go to
1$:		inc	(R5)			; halt at the end of the test
		mov	#177777, R0		; load register
		bis	R0, R2			; check	the bis	instruction
		jsr	PC, @#$cc10		; check	for cc 10
		cmp	R0, R2			; check	compare
		beq	2$			; continue if OK
		mov	#132, -(R5)		;
		inc	-(R5)			;
		halt				; bis or cmp instruction failed
						;
2$:		cmp	#77, R2			; check	it again
		bpl	3$			; continue if OK
		mov	#133, -(R5)		;
		inc	-(R5)			; cmp instruction failed
		halt				; (wrong cc)
						;
3$:		cmp	R2, #77			; once more
		bmi	bic0			; continue if OK
ecmp0:		mov	#134, -(R5)		;
		inc	-(R5)			;
		halt				; wrong	cc or wrong sequence
;_____________________________________________________________________________
;
; TEST 34 - new	instructions used in this section are bic, bit
;
bic0:		cmp	(R5), #34		;
		bne	ebic0			; if in	wrong sequence
		inc	(R5)			; go to	halt above
		mov	#177777, R3		; load register
		mov	#temp, R0		; place	the temp address in R0
		mov	#125252, (R0)		; set (R0)
		scc				;
		bic	(R0), R3		; clear	every other bit
		jsr	PC, @#$cc1		; check	for cc = 1
		bit	(R0), R3		; check	it
		beq	1$			; continue if OK
		mov	#135, -(R5)		;
		inc	-(R5)			;
		halt				; bic or bit instruction failed
						;
1$:		bit	#52525,	R3		; check	it
		jsr	PC, @#$cc1		; check	for cc = 1
		bis	#125252, R3		; set the bits that were cleared
		bmi	2$			; continue if OK
		mov	#136, -(R5)		;
		inc	-(R5)			;
		halt				; bit or bis instruction failed
						;
2$:		bic	#77777,	R3		; clear	all except for sign
		jsr	PC, @#$cc11		; check	for cc = 11
		mov	#177777, R0		;
		bit	R0, R3			; check	it
		jsr	PC, @#$cc11		; check	for cc = 11
		sevc				; set V	& C bits
		bic	R0, R0			;
		jsr	PC, @#$cc5		; check	cc = 5
		tst	R0			; check	R0 to contain 0
		beq	inc0			;
ebic0:		mov	#137, -(R5)		;
		inc	-(R5)			;
		halt				; bic failed or	sequence error
;_____________________________________________________________________________
;
; TEST 35 - new	instructions used in this section are inc, dec
;
inc0:		cmp	(R5), #35		;
		beq	2$			; if in	wrong sequence
		mov	#140, -(R5)		; go to	halt below
		inc	-(R5)			;
		halt				; program is in	wrong sequence
2$:		inc	(R5)			;
		mov	#77777,	R4		; R4 = 77777
		sec				;
		inc	R4			; add ones into	R0
		jsr	PC, @#$cc13		; check	for cc = 13
		mov	#177776, R4		;
		inc	R4			;
		jsr	PC, @#$cc11		; check	for cc = 11
		inc	R4			;
		jsr	PC, @#$cc5		; check	for cc = 5
		inc	R4			;
		jsr	PC, @#$cc1		; check	for cc = 1
		cmp	#1, R4			; check	it
		beq	4$			;
		mov	#141, -(R5)		;
		inc	-(R5)			;
		halt				; inc instruction failed
						;
4$:		sec				;
		dec	R4			; subtract ones	from R4
		jsr	PC, @#$cc5		; check	for cc = 5
		dec	R4			;
		jsr	PC, @#$cc11		; check	for cc = 11
		mov	#100000, R4		;
		dec	R4			;
		jsr	PC, @#$cc3		; check	for cc = 3
		dec	R4			;
		jsr	PC, @#$cc1		; check	for cc = 1
;_____________________________________________________________________________
;
; TEST 36 - new	instruction in this section is com
;
com0:		cmp	(R5), #36		;
		beq	1$			; if in	wrong sequence
		mov	#142, -(R5)		; go to	halt below
		inc	-(R5)			;
		halt				; test is in wrong sequence
						;
1$:		inc	(R5)			;
		mov	#125252, R3		; load every other bit
		scc				;
		com	R3			; 1's complement
		jsr	PC, @#$cc1		; check	for cc =  1
		cmp	#52525,	R3		; check	it
		beq	2$			; continue if OK
		mov	#143, -(R5)		;
		inc	-(R5)			;
		halt				; com instruction failed
						;
2$:		scc				;
		com	R3			; complement back
		jsr	PC, @#$cc11		; check	for cc = 11
		cmp	#125252, R3		; check	it
		beq	3$			; continue if OK
		mov	#144, -(R5)		;
		inc	-(R5)			;
		halt				; com instruction failed
						;
3$:		mov	#177777, R3		;
		scc				;
		com	R3			;
		jsr	PC, @#$cc5		; check	for cc = 5
;_____________________________________________________________________________
;
; TEST 37 - new	instruction in this section is neg
;
neg0:		cmp	(R5), #37		;
		bne	eneg0			; if in	wrong sequence go to
1$:		inc	(R5)			; halt at the end of the test
		mov	#1, R0			; load the register
		neg	R0			; 2's complement
		jsr	PC, @#$cc11		; check	for cc = 11
		cmp	#177777, R0		; check	it
		beq	2$			; continue if OK
		mov	#145, -(R5)		;
		inc    -(R5)			;
		halt				; neg instruction failed
						;
2$:		mov	#100000, R0		;
		neg	R0			; 2's complement
		jsr	PC, @#$cc13		; check	for cc = 13
		cmp	#100000, R0		; check	it
		beq	rol0			; continue if OK
						;
eneg0:		mov	#146, -(R5)		;
		inc	-(R5)			; wrong	result in R0
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 40 - new	instruction in this section is rol
;
rol0:		cmp	(R5), #40		;
		bne	erol0			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		mov	#20000,	R1		; load	register
		ccc				; clear	flags
		rol	R1			; shift
		rol	R1			;
		jsr	PC, @#$cc12		; check	for cc = 12
		cmp	#100000, R1		; check	it
		beq	1$			; continue if OK
		mov	#147, -(R5)		;
		inc	-(R5)			;
		halt				; rol instruction failed
						;
1$:		rol	R1			; shift
		jsr	PC, @#$cc7		; check	for cc = 7
		rol	R1			; shift
		cmp	#1, R1			; check	it
		beq	ror0			; continue if OK
erol0:		mov	  #150,	-(R5)		;
		inc	  -(R5)			; wrong	result in R1
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 41 - new	instruction in this section is ror
;
ror0:		cmp	(R5), #41		;
		bne	eror0			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		mov	#4, R2			; load register
		ccc				; clear	flags
		ror	R2			; shift
		ror	R2			;
		cmp	#1, R2			; check	it
		beq	1$			; continue if OK
		mov	#151, -(R5)		;
		inc	-(R5)			;
		halt				; ror instruction failed
						;
1$:		ror	R2			; shift
		jsr	PC, @#$cc7		; check	for cc = 7
		ror	R2			; shift
		jsr	PC, @#$cc12		; check	for cc = 12
		cmp	#100000, R2		; check	it
		beq	asl0			; continue if OK
eror0:		mov	#152, -(R5)		;
		inc	-(R5)			; wrong	result in R2
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 42 - new	instruction in this section is asl
;
asl0:		cmp	(R5), #42		;
		beq	2$			; if in	wrong sequence
		mov	#153, -(R5)		; go to	halt below
		inc   -(R5)			;
		halt				; program is in	wrong sequence
2$:		inc	(R5)			;
		mov	#20000,	R3		; load register
		ccc				; clear	flags
		asl	R3			; shift
		asl	R3			;
		jsr	PC, @#$cc12		; check	for cc = 12
		cmp	#100000, R3		; check	it
		beq	4$			; continue if OK
		mov	#154, -(R5)		;
		inc	-(R5)			;
		halt				; asl instruction failed
4$:		asl	R3			; shift
		jsr	PC, @#$cc7		; check	for cc = 7
		asl	R3			; shift
		jsr	PC, @#$cc4		; check	for cc = 4
;_____________________________________________________________________________
;
; TEST 43 - new	instruction in this section is asr
;
asr0:		cmp	(R5), #43		;
		bne	easr0			; if in	wrong sequence go to
1$:		inc	(R5)			; halt at the end of the test
		mov	#4, R4			; load register
		ccc				; clear	flags
		asr	R4			; shift
		asr	R4			;
		cmp	#1, R4			; check	it
		beq	2$			; continue if OK
		mov	#155, -(R5)		;
		inc	-(R5)			;
		halt				; asr instruction failed
2$:		asr	R4			; shift
		jsr	PC, @#$cc7		; check	for cc = 7
		asr	R4			; shift
		jsr	PC, @#$cc4		; check	for cc = 4
		mov	#100002, R3		; load register
		asr	R3			; shift
		asr	R3			;
		jsr	PC, @#$cc11		; check	for cc = 11
		cmp	#160000, R3		; check	it
		beq	adc0			; continue if OK
easr0:		mov	#156, -(R5)		;
		inc	-(R5)			; wrong	result in R3
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 44 - new	instruction in this section is adc
;
adc0:		cmp	(R5), #44		;
		beq	2$			; if in	wrong sequence
		mov	#157, -(R5)		; go to	halt below
		inc	-(R5)			;
		halt				; program is in	wrong sequence
						;
2$:		inc	(R5)			;
		clr	R0			; clear	the register
		ccc				; clear	flags
		adc	R0			; add C	bit = 0
		jsr	PC, @#$cc4		; check	for cc = 4
		sec				; C = 1
		adc	R0			; add C	bit = 1
		sec				; C = 1
		adc	R0			; again
		jsr	PC, @#$cc0		; check	for cc = 0
		cmp	#2, R0			; check	it
		beq	4$			; continue if OK
		mov	#160, -(R5)		;
		inc	-(R5)			;
		halt				; adc instruction failed
						;
4$:		mov	#77777,	R0		; load largest positive	number
		sec				; C = 1
		adc	R0			; add C	bit = 1
		jsr	PC, @#$cc12		; check	for cc = 12
		cmp	#100000, R0		; check	it
		beq	6$			;
		mov	#161, -(R5)		;
		inc	-(R5)			;
		halt				; adc instruction failed
6$:		mov	#-1, R0			; load -1
		sec				; C = 1
		adc	R0			; add C	bit = 1
		jsr	PC, @#$cc5		; check	for cc = 5
;____________________________________________________________________________
;
; TEST 45 - new	instruction in this section is sbc
;
sbc0:		cmp	(R5), #45		;
		beq	1$			; if in	wrong sequence
		mov	#162, -(R5)		; go to	halt below
		inc	-(R5)			;
		halt				; test is in wrong sequence
						;
1$:		inc	(R5)			;
		mov	#3, R1			; load register
		ccc				; clear	flags
		sbc	R1			; subtract C bit = 0
		jsr	PC, @#$cc0		; check	for cc = 0
		cmp	#3, R1			; check	it
		beq	2$			; continue if OK
		mov	#163, -(R5)		;
		inc	-(R5)			;
		halt				; sbc instruction failed
						;
2$:		sec				; C = 1
		sbc	R1			; subtract C bit = 1
		sec				; C = 1
		sbc	R1			;
		jsr	PC, @#$cc0		; check	for cc = 0
		cmp	#1, R1			; check	it
		beq	3$			; continue if OK
		mov	#164, -(R5)		;
		inc	-(R5)			;
		halt				; sbc instruction failed
						;
3$:		sec				; C = 1
		sbc	R1			; subtract C bit = 1
		jsr	PC, @#$cc4		; check	for cc = 4
		sec				; C = 1
		sbc	R1			; subtract C bit = 1
		jsr	PC, @#$cc11		; check	for cc = 11
		cmp	#-1, R1			; check	it
		beq	4$			; continue if f	OK
		mov	#165, -(R5)		;
		inc	-(R5)			;
		halt				; sbc instruction failed
						;
4$:		mov	#100000, R1		; load R1
		sec				;
		sbc	R1			; subtract C bit = 1
		jsr	PC, @#$cc2		; check	for cc = 2
;_____________________________________________________________________________
;
; TEST 46 - new	instruction in this section is sxt
;
sxt0:		cmp	(R5), #46		;
		bne	esxt0			; if in	wrong sequence go to
1$:		inc	(R5)			; halt at the end of the test
		clr	R2			; clear	register
		scc				;
		clnz				;
		sxt	R2			; sign extend
		jsr	PC, @#$cc5		; check	for cc = 5
		tst	R2			; R2 should still be 0
		beq	2$			; continue if OK
		mov	#166, -(R5)		;
		inc	-(R5)			;
		halt				; sxt instruction failed
						;
2$:		senvc				; set N, V & C bits
		sxt	R2			; sign extend
		jsr	PC, @#$cc11		; check	for cc = 11
		cmp	#-1, R2			; R2 should now	have -1
		beq	swab0			; continue if OK
esxt0:		mov	#167, -(R5)		;
		inc	-(R5)			; wrong	result in R2
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 47 - new	instruction in this section is swab
;
swab0:		cmp	(R5), #47		;
		bne	eswab0			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		mov	#125125, R3		; load bit pattern in R3
		scc				;
		cln				;
		swab	R3			; swap bytes of	register
		jsr	PC, @#$cc10		; check	for cc = 10
		cmp	#52652,	R3		; check	it
		beq	1$			; continue if OK
		mov	#170, -(R5)		;
		inc	   -(R5)		;
		halt				; swab instruction failed
						;
1$:		mov	#377, R3		;
		scc				;
		clz				;
		swab	R3			;
		jsr	PC, @#$cc4		; check	for cc = 4
		cmp	#177400, R3		;
		beq	xor0			;
eswab0:		mov	#171, -(R5)		;
		inc	-(R5)			; wrong	result in R3
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 50 - new	instruction in this section is xor
;
xor0:		cmp	(R5), #50		;
		bne	exor0			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		mov	#-1, R4			; load registers
		mov	#-1, R3			;
		scc				;
		xor	R4, R3			; should produce 0's in	R3
		jsr	PC, @#$cc5		; check	for cc = 5
		mov	#77777,	R3		;
		mov	R4, R0			; place	-1 in R0
		sevc				; set V	& C bits
		clz				;
		xor	R0, R3			;
		jsr	PC, @#$cc11		; check	for cc = 11
		mov	#125252, R2		; load registers
		mov	#52525,	R4		;
		scc				;
		xor	R2, R4			; should produce 1's in	R4
		jsr	PC, @#$cc11		; check	for cc = 11
		cmp	#-1, R4			; check	it
		beq	add0			; continue if OK
exor0:		mov	#172, -(R5)		;
		inc	-(R5)			; wrong	result in R4
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 51 - new	instruction in this section is add
;
add0:		cmp	(R5), #51		;
		bne	eadd0			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		mov	#21421,	R1		; load registers
		add	R1, R1			; add
		jsr	PC, @#$cc0		; check	for cc = 0
		cmp	#43042,	R1		; check	it
		beq	1$			; continue if OK
		mov	#173, -(R5)		;
		inc	-(R5)			;
		halt				; add instruction failed
						;
1$:		mov	#-21421, R0		; load registers
		add	R0, R0			; add
		jsr	PC, @#$cc11		; check	for cc = 11
		cmp	#-43042, R0		; check	it
		beq	2$			; continue it OK
		mov	#174, -(R5)		;
		inc	-(R5)			;
		halt				; add instruction failed
						;
2$:		mov	#100000, R2		; load registers
		add	R2, R2			; add should result as 0's
		jsr	PC, @#$cc7		; check	for cc = 7
		mov	#21421,	R4		; load registers
		mov	#-21421, R1		;
		add	R4, R1			; add should result as 0's
		beq	3$			; continue if OK
		mov	#175, -(R5)		;
		inc	-(R5)			;
		halt				; add instruction failed
						;
3$:		neg	R4			; switch source	and
		mov	#21421,	R1		; destination
		add	R1, R4			; should result	as 0's
		beq	sub0			; continue if OK
eadd0:		mov	#176, -(R5)		;
		inc	-(R5)			; wrong	result in R1
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 52 - new	instruction in this section is sub
;
sub0:		cmp	(R5), #52		;
		beq	2$			; if in	wrong sequence
		mov	#177, -(R5)		; go to	halt below
		inc	-(R5)			;
		halt				; program is in	wrong sequence
						;
2$:		inc	(R5)			;
		mov	#21421,	R2		; load registers
		mov	#-21421, R3		;
		sub	R2, R3			; result should	-43042
		jsr	PC, @#$cc10		; check	for cc = 10
		cmp	#-43042, R3		; check	it
		beq	4$			; continue if OK
		mov	#200, -(R5)		;
		inc	-(R5)			;
		halt				; sub instruction failed
						;
4$:		mov	#21421,	R3		; load register
		mov	R2, R4			; now R4 = 21421
		sub	R4, R3			; result should	0
		beq	6$			;
		mov	#201, -(R5)		;
		inc	-(R5)			;
		halt				; sub instruction failed
						;
6$:		mov	#-1, R3			; load registers
		mov	#77777,	R2		; result should	be 100000
		sub	R3, R2			; and overflow
		jsr	PC, @#$cc13		; check	for cc = 13
		cmp	#100000, R2		; check	it
		beq	8$			; continue if OK
		mov	#202, -(R5)		;
		inc	-(R5)			;
		halt				; sub instruction failed
						;
8$:		mov	#-1 ,R4			;
		sub	R3, R4			;
		jsr	PC, @#$cc4		; check	for cc = 4
;_____________________________________________________________________________
;
; TEST 53 - new	instructions in	this section is	mtps & mfps
;
psw:		cmp	(R5), #53		;
		bne	epsw			; if in	wrong sequence go to
1$:		inc	(R5)			; halt at the end of the test
		mov	#177777, R1		;
		clr	R0			;
		mtps	R0			; set psw to 0
		jsr	PC, @#$cc0		; check	for cc = 0
		mfps	R1			; move psw to R1
		beq	2$			; continue if bit 8 of PSW
		mov	#203, -(R5)		; was extended in R1
		inc	-(R5)			; mtps or mfps
		halt				; instruction failed
						;
2$:		jsr	PC, @#$cc4		; check	for cc = 4
		mov	#377, R0		; set psw to 357 since mtps
		mtps	R0			; does not set T bit
		jsr	PC, @#$cc17		; check	for cc = 17
		mfps	R1			; move psw to R1
		jsr	PC, @#$cc11		; check	for cc = 11
		cmp	#177757, R1		; C bit	should not be effected
		beq	mode0			; check	to see if bit 8	of PSW
						; was extended thru R1
epsw:		mov	#204, -(R5)		;
		inc	-(R5)			; mtps or mfps instruction
		halt				; failed or wrong sequence
;_____________________________________________________________________________
;
; TEST 54 - check modes	0 & 1 using the	movb and mov instructions
;
mode0:		cmp	(R5), #54		;
		bne	emode0			; if in	wrong sequence go to
		inc	(R5)			; hlt at the end of the	test
		movb	#252, R0		; load registers
		movb	R0, R1			;
		movb	R1, R2			;
		cmpb	#252, R2		; check	it
		beq	1$			; OK, continue
		mov	#205, -(R5)		;
		inc	-(R5)			; mov instruction
		halt				; failed in mode 0
						;
1$:		mov	#125252, R0		; load registers
		mov	R0, R1			;
		mov	R1, R2			;
		cmp	#125252, R2		; check	it
		beq	mode1			; OK, continue
		mov	#206, -(R5)		;
		inc	-(R5)			; mov instruction
		halt				; failed in mode 0
						;
mode1:		mov	#temp, R0		; load addresses into regs
		mov	#temp1,	R1		;
		mov	#temp2,	R2		;
		clr	temp2			; start	clean
		movb	#125, (R0)		; load the locations
		movb	(R0), (R1)		; temp ---> temp1
		movb	(R1), (R2)		; temp1	---> temp 2
		cmpb	#125, temp2		; check	it
		beq	1$			; OK, continue
		mov	#207, -(R5)		;
		inc	-(R5)			; mov instruction
		halt				; failed in mode 1
						;
1$:		mov	#52525,	(R0)		; load the locations
		mov	(R0), (R1)		; temp ---> temp1
		mov	(R1), (R2)		; temp1	---> temp2
		cmp	#52525,	temp2		; check	it
		beq	mode2			; OK, continue
						;
emode0:		mov	#210, -(R5)		; mov instruction
		inc	-(R5)			; failed in mode 1
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 55 - check mode 2 using the movb	and mov	instructions
;
mode2:		cmp	(R5), #55		;
		bne	emode2			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		mov	#temp, R0		; load addresses
		mov	#temp1,	R1		;
		mov	#temp2,	R2		;
		clrb	(R2)+			; start	clean
		movb	#252, (R0)		; load the locations
		movb	(R0)+, (R1)+		; temp ---> temp1
		incb	R1			; make it even
		movb	(R1), temp		; move 0's into	temp
		incb	R0			; make it even
		movb	(R0)+, (R1)+		; temp1	---> temp 2
		cmpb	-(R2), #252		; check	it
		bne	1$			; failed
		tstb	temp			; check	it
		beq	2$			; OK, continue
1$:		mov	#211, -(R5)		;
		inc	-(R5)			; instructions
		halt				; failed in mode 2
						;
2$:		tst	-(R1)			;
		clr	(R2)+			; start	clean
		mov	#125252, -(R0)		; load locations
		mov	(R0)+, (R0)+		; temp ---> temp1
		mov	(R0), temp		; 0 ---> temp
		mov	(R1)+, (R1)+		; 125252 ---> temp2
		cmp	-(R2), #125252		; check	it
		bne	emode2			; failed
		tst	temp			; check	it
		beq	mode3			; OK, continue
						;
emode2:		mov	#212, -(R5)		; instructions
		inc	-(R5)			; failed in mode 2
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 56 - check mode 3 using the movb	and mov	instructions
;
mode3:		cmp	(R5), #56		;
		bne	emode3			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		mov	#temp, adr		; load addresses
		mov	#temp1,	adr1		;
		mov	#temp2,	adr2		;
		mov	#adr, R0		; load addresses of addresses
		mov	#adr1, R1		;
		clrb	temp2			; start	clean
		movb	#125, temp		;
		movb	@(R0)+,	@(R1)+		; temp ---> temp1
		movb	@(R1)+,	temp		; temp2	---> temp
		movb	@(R0)+,	@(R0)+		; temp1	---> temp2
		cmpb	#125, temp2		; check	it
		bne	1$			; failed
		tstb	temp			; check	it
		beq	2$			; OK, continue
1$:		mov	#213,-(R5)		;
		inc	-(R5)			; instructions
		halt				; failed in mode 3
						;
2$:		clr	temp2			; start	clean
		mov	#52525,	temp		; load locations
		mov	#adr, R0		; load addresses of addresses
		mov	#adr1, R1		;
		mov	@(R0)+,	@(R0)+		; temp ---> temp1
		mov	@(R0)+,	temp		; temp2	---> temp
		mov	@(R1)+,	@(R1)+		; temp1	---> temp 2
		cmp	#52525,	temp2		; check	it
		bne	emode3			; failed
		tst	temp			; check	it
		beq	mode4			; OK, continue
						;
emode3:		mov	#214, -(R5)		;
		inc	-(R5)			; instructions
		halt				; failed in mode 3
;_____________________________________________________________________________
;
; TEST 57 - check mode 4 using the movb	and mov	instructions
;
mode4:		cmp	(R5), #57		;
		bne	emode4			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		clrb	temp			; start	clean
		mov	#temp, R0		; load addresses
		mov	#temp1,	R1		;
		mov	#temp2,	R2		;
		inc	R2			; adjust the pointer
		cmp	(R2), temp2+1		;
		beq	1$			;
		mov	#215, -(R5)		;
		inc	-(R5)			; instructions
		halt				; failed in mode 4
						;
1$:		movb	#252, -(R2)		; load temp2
		inc	R1			; adjust the pointers
		inc	R2			;
		movb	-(R2), -(R1)		; temp2	---> temp1
		inc	R0			; adjust the pointers
		inc	R2			;
		movb	-(R0), -(R2)		; temp ---> temp2
		incb	R0			; adjust the pointers
		cmp	(R0), temp+1		;
		beq	2$			;
		mov	#216, -(R5)		;
		inc	-(R5)			; instructions
		halt				; failed in mode 4
						;
2$:		incb	R1			;
		movb	-(R1), -(R0)		; temp1	---> temp
		cmpb	#252, temp		; check	it
		bne	3$			; failed
		tstb	temp2			; check	it
		beq	4$			; OK, continue
3$:		mov	#217, -(R5)		;
		inc	-(R5)			; instructions
		halt				; failed in mode 4
						;
4$:		clr	temp			; start	clean
		mov	#temp, R0		; load addresses
		mov	#temp1,	R1		;
		mov	#temp2,	R2		;
		tst	(R2)+			; adjust the pointer
		cmp	(R2), temp2+2		;
		beq	5$			;
		mov	#220, -(R5)		;
		inc	-(R5)			; instructions
		halt				; failed in mode 4
						;
5$:		mov	#125252, -(R2)		; load temp2
		tst	(R1)+			; adjust the pointers
		tst	(R2)+			;
		mov	-(R2), -(R1)		; temp2	---> temp1
		tst	(R0)+			; adjust pointers
		tst	(R2)+			;
		mov	-(R0), -(R2)		; temp ---> temp2
		tst	(R0)+			; adjust the pointers
		tst	(R1)+			;
		mov	-(R1), -(R0)		; temp1	---> temp
		cmp	#125252, temp		; check	it
		bne	emode4			; failed
		tst	temp2			; check	it
		beq	mode5			; OK, continue
						;
emode4:		mov	#221, -(R5)		; instructions
		inc	-(R5)			; failed in mode 4
		halt				; or wrong	sequence
;_____________________________________________________________________________
;
; TEST 60 - check mode 5 using the movb	and mov	instructions
;
mode5:		cmp	(R5), #60		;
		bne	emode5			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		clrb	temp			; start	clean
		mov	#temp, adr		; load addresses
		mov	#temp1,	adr1		;
		mov	#temp2,	adr2		;
		mov	#adr, R0		; load addresses of addresses
		mov	#adr1, R1		;
		mov	#adr2, R2		;
		tst	(R2)+			; adjust the pointer
		movb	#125, @-(R2)		; load temp2
		cmp	(R1)+, (R2)+		; adjust the pointers
		movb	@-(R2),	@-(R1)		; temp 2 ---> temp1
		cmp	(R0)+, (R2)+		; adjust the pointers
		movb	@-(R0),	@-(R2)		; temp ---> temp2
		cmp	(R0)+, (R2)+		; adjust the pointers
		cmpb	@-(R0),	@-(R2)		; check	it
		beq	1$			;
		mov	#222, -(R5)		;
		inc	-(R5)			;
		halt				;
						;
1$:		cmp	(R1)+, (R0)+		; adjust the pointers
		movb	@-(R1),	@-(R0)		; temp1	---> temp
		cmpb	#125, temp		; check	it
		bne	2$			; failed
		tstb	temp2			; check	it
		beq	3$			; OK, continue
2$:		mov	#223, -(R5)		;
		inc	-(R5)			; instructions
		halt				; failed in mode 5
						;
3$:		clr	temp			; start	clean
		mov	#adr, R0		; load addresses of addresses
		mov	#adr1, R1		;
		mov	#adr2, R2		;
		tst	(R2)+			; adjust the pointer
		mov	#52525,	@-(R2)		; load temp2
		cmp	(R1)+, (R2)+		; adjust the pointers
		mov	@-(R2),	@-(R1)		; temp 2 ---> temp1
		cmp	(R0)+, (R2)+		; adjust the pointers
		mov	@-(R0),	@-(R2)		; temp ---> temp 2
		cmp	(R0)+, (R1)+		; adjust the pointers
		mov	@-(R1),	@-(R0)		; temp1	---> temp
		cmp	#52525,	temp		; check	it
		bne	emode5			; failed
		tst	temp2			; check	it
		beq	mode6			; OK, continue
						;
emode5:		mov	#224, -(R5)		; instructions
		inc	-(R5)			; failed in mode 5
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 61 check	mode 6 using the movb and mov instructions
;
mode6:		cmp	(R5), #61		;
		bne	emode6			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		clr	temp2			; start	clean
		mov	#temp, R0		; load addresses
		mov	#temp1,	R1		;
		mov	#temp2,	R2		;
		movb	#252, 0(R0)		; load temp (low byte)
		movb	#252, 1(R0)		; load temp (high byte)
		cmp	#125252, temp		; check	it
		bne	1$			; failed
		movb	1(R0), 0(R2)		; temp(h) ---> temp2(l)
		movb	2(R1), 5(R0)		; temp2(l) --->	temp2(h)
		cmp	#125252, temp2		; check	it
		beq	2$			; OK, continue
1$:		mov	#225, -(R5)		;
		inc	-(R5)			; instructions
		halt				; failed in mode 6
						;
2$:		clr	temp1			; start	clean
		mov	#52525,	0(R0)		; load temp
		mov	-4(R2),	2(R0)		; temp ---> temp1
		cmp	#52525,	temp1		; check	it
		beq	mode7			; OK, continue
						;
emode6:		mov	#226, -(R5)		; instructions
		inc	-(R5)			; failed in mode 6
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 62 - check mode 7 using the movb	and mov	instructions
;
mode7:		cmp	(R5), #62		;
		bne	emode7			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		clr	temp1			; start	clean
		mov	#temp, adr		; load addresses
		mov	#temp1,	adr1		;
		mov	#temp2,	adr2		;
		mov	#adr, R0		; load addresses of addresses
		mov	#adr1, R1		;
		mov	#adr2, R2		;
		movb	#252, @0(R0)		; load temp
		movb	@-4(R2), @2(R0)		; temp ---> temp1
		cmpb	#252, temp1		; check	it
		beq	1$			; OK, continue
		mov	#227, -(R5)		;
		inc	-(R5)			;
		halt				; mode 7 is failing
						;
1$:		mov	#125252, @0(R0)		; load temp
		mov	@-4(R2), @2(R0)		; temp ---> temp1
		cmp	#125252, temp1		; check	it
		beq	tstb1			; OK, continue
						;
emode7:		mov	#230, -(R5)		; instructions
		inc	-(R5)			; failed in mode 7
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 63 - new	instructions used in this section are tstb, clrb, movb
;
tstb1:		cmp	(R5), #63		;
		bne	etstb1			; if in	wrong sequence go to
2$:		inc	(R5)			; halt at the end of the test
		mov	#temp, R0		; load addresses
		mov	#temp1,	R1		;
		scc				;
		clrb	(R0)			; clear	the location
		jsr	PC, @#$cc4		; check	for cc = 4
		tstb	(R0)			; check	it
		jsr	PC, @#$cc4		; check	for cc = 4
		movb	#377, (R1)		; load the location
		jsr	PC, @#$cc10		; check	for cc = 10
		tstb	(R1)			; check	it
		jsr	PC, @#$cc10		; check	for cc = 10
		mov	R0, R2			; R2 is	now pointing to	temp
		movb	#200, 0(R2)		; place	200 in location	temp
		movb	(R2)+, -(R1)		; move 200 location temp1
		cmp	-1(R1),	#100200		; check	the data in temp
		beq	4$			;
		mov	#231, -(R5)		;
		inc	-(R5)			;
		halt				; movb instruction failed
						;
4$:		cmp	R1, R2			; check	the registers
		beq	cmpb1			; for proper value
etstb1:		mov	#232, -(R5)		;
		inc	-(R5)			; movb instruction failed
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 64 - new	instructions used in this section are cmpb, bisb
;
cmpb1:		cmp	(R5), #64		;
		bne	ecmpb1			; if in	wrong sequence go to
1$:		inc	(R5)			; halt at the end of the test
		mov	#temp2,	R1		;
		mov	#temp, R2		; load address
		mov	#77, (R1)		; place	77 in location temp2
		movb	#377, R4		; R4 should contain 177777
		bisb	R4, (R2)		; load location
		jsr	PC,@#$cc10		; check	for cc = 10
		cmpb	R4, (R2)		; check	compare
		beq	2$			; continue if OK
		mov	#233, -(R5)		;
		inc	-(R5)			; bisb or cmpb
		halt				; instruction failed
						;
2$:		cmpb	(R1), (R2)		; check	it again
		bpl	3$			; continue if OK
		mov	#234, -(R5)		;
		inc	-(R5)			; cmpb instruction failed
		halt				; (wrong cc)
						;
3$:		cmpb	(R2), (R1)		; once more
		bmi	bicb1			; continue if OK
ecmpb1:		mov	#235, -(R5)		;
		inc	-(R5)			;
		halt				;
;_____________________________________________________________________________
;
; TEST 65 - new	instructions used in this section are bicb, bitb
;
bicb1:		cmp	(R5), #65		;
		beq	2$			; if in	wrong sequence
		mov	#236, -(R5)		; go to	halt below
		inc	-(R5)			;
		halt				; program is in	wrong sequence
						;
2$:		inc	(R5)			;
		mov	#temp, R3		; load address
		movb	#377, (R3)		; load location
		mov	#temp1,	R0		; place	the address of
		mov	R0, R1			; location temp1 in R0 and R1
		movb	#252,(R1)+		; place	252 in temp1
		scc				;
		bicb	0(R0), (R3)		; clear	every other bit
		jsr	PC, @#$cc1		; check	for cc = 1
		bitb	-1(R1),	(R3)		; check	it
		beq	4$			; continue if OK
		mov	#237, -(R5)		;
		inc	-(R5)			; bicb or bitb
		halt				; instruction failed
						;
4$:		bitb	#125, (R3)		; check	it
		jsr	PC, @#$cc1		; check	for cc = 1
		bisb	-(R1), (R3)		; set bits that	were cleared
		bmi	6$			; continue if OK
		mov	#240, -(R5)		;
		inc	-(R5)			; bitb or bisb
		halt				; instruction failed
						;
6$:		mov	#177, -(SP)		; store	177 on the stack
		bicb	(SP)+, (R3)		; clear	all bits except	sign
		jsr	PC, @#$cc11		; check	for cc = 11
		bitb	#377, (R3)		; check	it
		jsr	PC, @#$cc11		; check	for cc = 11
		mov	R3, R0			; place	address	of temp	in R0
		mov	#temp1,	(R0)		; place	address	of temp1 in temp
		mov	#377, @(R0)+		; write	a 377 in location temp1
		sevc				; set V	& C bits
		bicb	@-(R0),	@(R0)		; bit clear the	contents
		jsr	PC, @#$cc5		; check	for cc = 5
		cmp	(R0)+, #temp1		; make sure that (R0) is
		beq	8$			; pointing to location temp1
		mov	#241, -(R5)		;
		inc	-(R5)			; bicb or cmp instruction
		halt				; failed in the	specific mode
						;
8$:		tst	@-(R0)			; test location	temp1
		beq	10$			;
		mov	#242, -(R5)		;
		inc	-(R5)			;
		halt				; bicb instruction failed
10$:		ccc				;
		bicb	(R0), (R0)		; clear	the location temp
		jsr	PC, @#$cc4		; check	for cc = 4
;_____________________________________________________________________________
;
; TEST 66 - new	instructions used in this section are incb, decb
;
incb1:		cmp	(R5), #66		;
		bne	eincb1			; if in	wrong sequence go to
1$:		inc	(R5)			; halt at the end of the test
		mov	#temp, R4		; load address
		movb	#177, (R4)		; temp location	177
		sec				;
		incb	(R4)			; add ones into	location
		jsr	PC, @#$cc13		; check	for cc = 13
		mov	#376, (R4)		;
		mov	#$cc11,	R0		; make R0 point	to checking
		incb	(R4)+			; routine for cc = 11
		jsrR0				; jsr PC, (R0)+	/ check
		tstb	-(R4)			; decrement R4 by 1
		tst	-(SP)			; and SP by 2
		mov	R4, (SP)+		; temp address on the stack
		clc				; increment the	contents
		incb	@-(SP)			; of location temp
		jsr	PC, @#$cc4		; check	for cc = 4
		cmpb	@(SP)+,	@(R4)+		; restore stack	pointer
		sec				; set C	bit
		incb	-1(R4)			;
		jsr	PC, @#$cc1		; check	for cc = 1
		cmpb	-(R4), #1		; check	it
		beq	2$			; continue if OK
		mov	#243, -(R5)		;
		inc	-(R5)			;
		halt				; incb instruction failed
						;
2$:		sec				;
		decb	(R4)			; subtract ones	from location
		jsr	PC, @#$cc5		; check	for cc = 5
		decb	(R4)+			;
		jsr	PC, -(R0)		; check	for cc = 11
		movb	#200, -1(R4)		;
		decb	-(R4)			;
		jsr	PC, $cc3-$cc11(R0)	; check	for cc = 3
		decb	0(R4)			;
		jsr	PC, @#$cc1		; check	for cc = 1
		cmpb	0(R4), #176		;
		beq	comb1			;
						;
eincb1:		mov	#244, -(R5)		;
		inc	-(R5)			; decb instruction failed
		halt				; or sequence error
;_____________________________________________________________________________
;
; TEST 67 - new	instruction in this section is comb
;
comb1:		cmp	(R5), #67		;
		beq	1$			; if in	wrong sequence
		mov	#245, -(R5)		; go to	halt below
		inc	-(R5)			;
		halt				; test is in wrong sequence
						;
1$:		inc	(R5)			;
		mov	#temp, R3		; load address
		mov	#temp1,	R4		;
		mov	#252, (R4)		;
		movb	(R4)+, (R3)		; load every other bit
		scc				;
		comb	(R3)			; 1's complement
		jsr	PC, @#$cc1		; check	for c =	1
		cmpb	#125, (R3)		; check	it
		beq	2$			; continue if OK
		mov	#246, -(R5)		;
		inc	-(R5)			;
		halt				; comb instruction failed
						;
2$:		scc				;
		comb	(R3)			; complement back
		jsr	PC, @#$cc11		; check	for cc = 11
		mov	R4, R0			;
		cmpb	-1(R0),	(R3)		; check	it
		beq	3$			; continue if OK
		mov	#247, -(R5)		;
		inc	-(R5)			;
		halt				; comb instruction failed
						;
3$:		movb	#377, (R4)+		;
		movb	-(R4), (R3)		; place	377 in (R3)
		scc				;
		comb	(R3)			;
		jsr	PC, @#$cc5		; check	for cc = 5
;_____________________________________________________________________________
;
; TEST 70 - new	instruction in this section is negb
;
negb1:		cmp	(R5), #70		;
		bne	enegb1			; if in	wrong sequence go to
1$:		inc	(R5)			; halt at the end of the test
		mov	#temp, R0		; load address
		movb	#1, (R0)		; load the location
		negb	(R0)			; 2's complement
		jsr	PC, @#$cc11		; check	for cc = 11
		cmpb	#377, (R0)		; check	it
		beq	2$			; continue if OK
		mov	#250, -(R5)		;
		inc	-(R5)			;
		halt				; negb instruction failed
						;
2$:		mov	#200, (R0)		;
		negb	(R0)			; 2's complement
		jsr	PC, @#$cc13		; check	for cc = 13
		cmpb	#200, (R0)		; check	it
		beq	rolb1			; continue if OK
						;
enegb1:		mov	#251, -(R5)		;
		inc	-(R5)			; wrong	result at temp
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 71 - new	instruction in this section is rolb
;
rolb1:		cmp	(R5), #71		;
		bne	erolb1			; if in	wrong sequence go to
		inc	(R5)			; hlt at the end of the	test
		mov	#temp1,	R1		; load address
		movb	#40, (R1)		; load location
		ccc				; clear	flags
		rolb	(R1)			; shift
		rolb	(R1)			;
		jsr	PC, @#$cc12		; check	for cc = 12
		cmpb	#200, (R1)		; check	it
		beq	1$			; continue if OK
		mov	#252, -(R5)		;
		inc	-(R5)			;
		halt				; rolb instruction failed
						;
1$:		rolb	(R1)			; shift
		jsr	PC, @#$cc7		; check	for cc = 7
		rolb	(R1)			; shift
		cmpb	#1, (R1)		; check	it
		beq	rorb1			; continue if OK
						;
erolb1:		mov	#253, -(R5)		;
		inc	-(R5)			; wrong	result at temp1
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 72 - new	instruction in this section is rorb
;
rorb1:		cmp	(R5), #72		;
		bne	erorb1			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		mov	#temp1,	R2		; load address
		movb	#4,(R2)			; load location
		ccc				; clear	flags
		rorb	(R2)			; shift
		rorb	(R2)			;
		cmpb	#1, (R2)		; check	it
		beq	1$			; continue if OK
		mov	#254,-(R5)		;
		inc	-(R5)			;
		halt				; rorb instruction failed
						;
1$:		rorb	(R2)			; shift
		jsr	PC, @#$cc7		; check	for cc = 7
		rorb	(R2)			; shift
		jsr	PC, @#$cc12		; check	for cc = 12
		cmpb	#200, (R2)		; check	it
		beq	aslb1			; continue if OK
						;
erorb1:		mov	#255, -(R5)		;
		inc	-(R5)			; wrong	result at temp1
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 73 - new	instruction in this section is aslb
;
aslb1:		cmp	(R5), #73		;
		beq	2$			; it in	wrong sequence
		mov	#256, -(R5)		; go to	halt below
		inc	-(R5)			;
		halt				; program is in	wrong sequence
						;
2$:		inc	(R5)			;
		mov	#temp1,	R3		; load address
		movb	#40, (R3)		; load location
		ccc				; clear	flags
		aslb	(R3)			; shift
		aslb	(R3)			;
		jsr	PC, @#$cc12		; check	for cc = 12
		cmpb	#200, (R3)		; check	it
		beq	4$			; continue if OK
		mov	#257, -(R5)		;
		inc	-(R5)			;
		halt				; aslb instruction failed
						;
4$:		aslb	(R3)			; shift
		jsr	PC, @#$cc7		; check	for cc = 7
		aslb	(R3)			; shift
		jsr	PC, @#$cc4		; check	for cc = 4
;_____________________________________________________________________________
;
; TEST 74 - new	instruction in this section is asrb
;
asrb1:		cmp	(R5), #74		;
		bne	easrb1			; if in	wrong sequence go to
1$:		inc	(R5)			; hlt at the end of test
		mov	#temp1,	R4		; load addresses
		mov	#temp2,	R3		;
		movb	#4, (R4)		; load location
		ccc				; clear	flags
		asrb	(R4)			; shift
		asrb	(R4)			;
		cmpb	#1, (R4)		; check	it
		beq	2$			; continue if OK
		mov	#260, -(R5)		;
		inc	-(R5)			;
		halt				; asrb instruction failed
						;
2$:		asrb	(R4)			; shift
		jsr	PC, @#$cc7		; check	for cc = 7
		asrb	(R4)			; shift
		jsr	PC, @#$cc4		; check	for cc = 4
		movb	#202, (R3)		; load location
		asrb	(R3)			; shift
		asrb	(R3)			;
		jsr	PC, @#$cc11		; check	for cc = 11
		cmpb	#340, (R3)		; check	it
		beq	adcb1			; continue if OK
						;
easrb1:		mov	#261, -(R5)		;
		inc	-(R5)			; wrong	result at temp2
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 75 - new	instruction in this section is adcb
;
adcb1:		cmp	(R5), #75		;
		beq	2$			; if in	wrong sequence
		mov	#262, -(R5)		; go to	halt below
		inc	-(R5)			;
		halt				; program is in	wrong sequence
						;
2$:		inc	(R5)			;
		mov	#temp2,	R0		; load address
		clrb	(R0)			; clear	the location
		ccc				; clear	flags
		adcb	(R0)			; add C	bit  = 0
		jsr	PC, @#$cc4		; check	for cc = 9
		sec				;
		adcb	(R0)			; add C	bit = 1
		sec				; C = 1
		adcb	(R0)			; again
		jsr	PC, @#$cc0		; check	for cc = 0
		cmpb	#2, (R0)		; check	it
		beq	4$			; continue if OK
		mov	#263, -(R5)		;
		inc	-(R5)			;
		halt				; adcb instruction failed
						;
4$:		movb	#177, (R0)		; load largest positive	byte
		sec				; C = 1
		adcb	(R0)			; add C	bit = 1
		jsr	PC, @#$cc12		; check	for cc = 12
		cmpb	#200, (R0)		; check	it
		beq	6$			; continue if OK
		mov	#264, -(R5)		;
		inc	-(R5)			;
		halt				; adcb instruction failed
						;
6$:		movb	#377, (R0)		;
		sec				;
		adcb	(R0)			; add C	bit = 1
		jsr	PC, @#$cc5		; check	for cc = 5
;_____________________________________________________________________________
;
; TEST 76 - new	instruction in this section is sbcb
;
sbcb1:		cmp	(R5), #76		;
		beq	1$			; if in	wrong sequence
		mov	#265,-(R5)		; go to	halt below
		inc	-(R5)			;
		halt				; test is in wrong sequence
						;
1$:		inc	(R5)			;
		mov	#temp2,	R1		; load address
		movb	#3, (R1)		; load location
		ccc				; clear	flags
		sbcb	(R1)			; subtract C bit = 0
		jsr	PC, @#$cc0		; check	for cc = 0
		cmpb	#3, (R1)		; check	it
		beq	2$			; continue if OK
		mov	#266,-(R5)		;
		inc	-(R5)			;
		halt				; sbcb instruction failed
						;
2$:		sec				; C = 1
		sbcb	(R1)			; subtract C bit = 1
		sec				; C = 1
		sbcb	(R1)			;
		jsr	PC, @#$cc0		; check	for cc = 0
		cmpb	#1, (R1)		; check	it
		beq	3$			; continue if OK
		mov	#267, -(R5)		;
		inc	-(R5)			;
		halt				; sbcb instruction failed
						;
3$:		sec				; C = 1
		sbcb	(R1)			; subtract C bit = 1
		jsr	PC, @#$cc4		; check	for cc = 4
		sec				; C = 1
		sbcb	(R1)			; subtract C bit = 1
		jsr	PC, @#$cc11		; check	for cc = 11
		cmpb	#377, (R1)		; check	it
		beq	4$			; continue if OK
		mov	#270, -(R5)		;
		inc	-(R5)			;
		halt				; sbcb instruction failed
						;
4$:		movb	#200, (R1)		;
		sec				; C = 1
		sbcb	(R1)			; subtract C bit = 1
		jsr PC,	@#$cc2			; check	for cc = 2
;
; check	word instructions, not destination mode	0
;_____________________________________________________________________________
;
; TEST 77 - new	instructions used in this section are tst, clr,	mov
;
tst1:		cmp	(R5), #77		;
		beq	1$			; if in	wrong sequence
		mov	#271, -(R5)		; go to	halt below
		inc	-(R5)			;
		halt				; test is in a wrong sequence
						;
1$:		inc	(R5)			;
		mov	#temp, R1		; load addresses
		mov	#temp1,	R0		;
		scc				;
		clr	(R0)			; clear	the location
		jsr	PC, @#$cc4		; check	for cc = 4
		tst	(R0)+			; check	it
		jsr	PC, @#$cc4		; check	for cc = 4
		movR0m				; mov R0, -(R0)
		mov	#177777, @(R0)+		;
		mov	@-2(R0), (R1)		; load the location
		jsr	PC, @#$cc10		; check	for cc = 10
		tst	(R1)			; check	it
		jsr	PC, @#$cc10		; check	for cc = 10
;_____________________________________________________________________________
;
; TEST 100 - new instructions used in this section are cmp, bis
;
cmp1:		cmp	(R5), #100		;
		bne	ecmp1			; if in	wrong sequence go to
1$:		inc	(R5)			; halt at the end of the test
		mov	#temp1,	R2		; load address
		mov	#temp, R0		; place	the address of temp in R0
		mov	#177777, (R0)+		; place	177777 in location temp
		bis	-(R0), (R2)		; load location
		jsr	PC, @#$cc10		; check	for cc = 10
		cmp	(R2)+, #177777		; check	compare
		beq	2$			; continue if OK
		mov	#272, -(R5)		;
		inc	-(R5)			;
		halt				; cmp or bis  instruction failed
						;
2$:		cmp	R2, #temp1+2		; check	R2 to contain
		beq	3$			; address of temp1+2
		mov	#273, -(R5)		;
		inc	-(R5)			;
		halt				; no auto increment
						;
3$:		cmp	#77, -(R2)		; check	it again
		jsr	PC, @#$cc1		; check	for cc = 1
		cmp	#77777,	(R2)+		;
		jsr	PC, @#$cc13		; check	for cc = 13
		cmp	-(R2), #77777		; once more
		jsr	PC, @#$cc10		; check	for cc = 10
		mov	#52525,	temp2		; set every other bit in temp2
		mov	#temp2,	temp1		; place	the address of temp2
		mov	#adr ,R4		; in location temp1
		mov	#adr1, (R4)		; place	the 125252
		mov	#125252, @(R4)+		; in location	adr1
		bis	@-2(R4), @(R2)+		; set every other bit in temp2
						; and increment	R2 by 2
		mov	R2, R0			; place	address	of temp2 in R0
		cmp	@-(R0),	#177777		; temp2	should contain all 1's
		beq	4$			;
		mov	#274, -(R5)		;
		inc	-(R5)			;
		halt				; cmp or bis instructions failed
						; in modes other than 0
						;
4$:		cmp	R2, #temp1+2		; R2 should contain the	address
		beq	5$			; for temp2 i,e, temp1+2
		mov	#275, -(R5)		;
		inc	-(R5)			;
		halt				; mode 5 is failing
						;
5$:		clr	-(R0)			; place	a 0 in location	temp
		mov	R0, temp2		; place	address	of temp	in temp2
		cmp	(R0)+, (R0)+		; bump R0 by 4
		bis	@-(R0),	@2(R0)		; place	the contents of
		cmp	#temp, temp		; location temp2 at temp
		beq	bic1			;
						;
ecmp1:		mov	#276, -(R5)		;
		inc	-(R5)			; cmp or bis instructions failed
		halt				; or wrong sequence counter
;_____________________________________________________________________________
;
; TEST 101 - new instructions used in this section are bic, bit
;
bic1:		cmp	(R5), #101		;
		bne	ebic1			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		mov	#temp, R3		; load address
		mov	#177777, (R3)		; load location
		mov	#adr, R4		; place	address	of adr in R4
		mov	#adr1, (R4)		; place	address	of adr1	in adr
		mov	(R3), @(R4)+		; load location	adr1
		mov	#temp1,	R0		; place	address	of temp1 in R0
		mov	#125252, (R0)		; set every other bit in temp1
		scc				;
		bic	(R0)+, (R3)		; clear	every other bit
		jsr	PC, @#$cc1		; check	for cc = 1
		bit	-(R0), (R3)		; check	it
		beq	1$			; continue if OK
		mov	#277, -(R5)		;
		inc	-(R5)			;
		halt				; bic or bit instruction failed
						;
1$:		bit	#52525,	(R3)		; check	it
		jsr	PC, @#$cc1		; check	for cc = 1
		bis	0(R0), (R3)		; set the bits that were cleared
		bmi	2$			; continue if OK
		mov	#300, -(R5)		;
		inc	-(R5)			;
		halt				; bit or bis instruction failed
						;
2$:		mov	#77777,	(R0)+		; set all the bits at location
		mov	R0, R2			; temp1	except sign bit
		bic	-2(R2),	(R3)		; try clearing the other bits
		jsr	PC, @#$cc11		; check	for cc = 11
		cmp	R0, #temp1+2		;
		beq	3$			;
		mov	#301, -(R5)		;
		inc	-(R5)			;
		halt				;
						; mov R0, (R0)+
3$:		movR0p				; place	address	of temp2 in temp2
		sevc				; set V	& C bits
		bic	@-(R0),	R0		; clear	R0
		jsr	PC, @#$cc5		; check	for cc = 5
		bit	@-2(R4), (R3)		; check	it
		jsr	PC, @#$cc11		; check	for cc = 11
		mov	#125252, -(SP)		; set every other bit on the stack
		mov	@-2(R4), (R3)+		; set all the bits in temp
		bic	0(SP), -(R3)		; clear	every other bit	in temp
		cmp	(R3)+, #52525		; temp should contain 52525
		beq	4$			;
		mov	#302, -(R5)		;
		inc	-(R5)			;
		halt				; bic failed in	mode 6
						;
4$:		mov	#temp2+2, R0		;
		mov	R3, -(R0)		;
		mov	-(R3), @(R0)+		;
		sevc				; bit test temp1 with stack
		bit	@-(R0),	(SP)+		; and restore stack pointer
		jsr	PC, @#$cc5		; check	for cc = 5
		cmp	SP, #start		; make sure that the SP	is OK
		beq	inc1			;
						;
ebic1:		mov	#303, -(R5)		;
		inc	-(R5)			; stack	pointer	fouled up
		halt				; or sequence error
;_____________________________________________________________________________
;
; TEST 102 - new instructions used in this section are inc, dec
;
inc1:		cmp	(R5), #102		;
		beq	2$			; if in	wrong sequence
		mov	#304, -(R5)		; go to	halt below
		inc	-(R5)			;
		halt				; program is in	wrong sequence
						;
2$:		inc	(R5)			;
		mov	#temp1,	R4		; load address
		mov	#77777,	(R4)		; temp1	= 77777
		sec				;
		inc	(R4)			; add ones into	location
		jsr	PC, @#$cc13		; check	for cc = 13
		mov	#177776, (R4)		;
		mov	#temp, R0		; R0 is	pointing to temp
		mov	#$cc11,	(R0)		; place	the address of routine
						; to check cc in location temp
		inc	(R4)			;
		jsr	PC, @(R0)+		; check	for cc = 11
		inc	(R4)			;
		jsr	PC, @#$cc5		; check	for cc = 5
		inc	(R4)			;
		jsr	PC, @#$cc1		; check	for cc = 1
		cmp	0(R4), #1		; check	it
		beq	4$			; continue if OK
		mov	#305, -(R5)		;
		inc	-(R5)			;
		halt				; inc instruction failed
						;
4$:		sec				;
		dec	(R4)			; subtract ones	from
		jsr	PC, @#$cc5		; check	for cc = 5
		dec	(R4)			;
		jsr	PC, @-2(R0)		; check	for cc = 11
		mov	#100000, (R4)		;
		dec	(R4)			;
		jsr	PC, @#$cc3		; check	for cc = 3
		dec	(R4)			;
		jsr	PC, @#$cc1		; check	for cc = 1
;_____________________________________________________________________________
;
; TEST 103 - new instruction in	this section is	com
;
com1:		cmp	(R5), #103		;
		beq	1$			; if in	wrong sequence
		mov	#306, -(R5)		; go to	halt below
		inc	-(R5)			;
		halt				; test is in wrong sequence
						;
1$:		inc	(R5)			;
		mov	#temp1,	R3		; load address
		mov	#125252, (R3)		; load every other bit
		scc				;
		com	0(R3)			; 1's complement
		jsr	PC, @#$cc1		; check	for cc = 1
		cmp	#52525,	(R3)		; check	it
		beq	2$			; continue if OK
		mov	#307, -(R5)		;
		inc	-(R5)			;
		halt				; com instruction failed
						;
2$:		scc				;
		com	(R3)+			; complement back
		jsr	PC, @#$cc11		; check	fdr cc = 11
		cmp	#125252, -(R3)		; check	it
		beq	3$			; continue if OK
		mov	#310, -(R5)		;
		inc	-(R5)			;
		halt				; com instruction failed
						;
3$:		mov	R3, R0			; R0 is	now pointing
		mov	#177777, (R0)		; to location temp1
		scc				;
		com	(R0)			;
		jsr	PC, @#$cc5		; check	for cc = 5
;_____________________________________________________________________________
;
; TEST 104 - new instruction in	this section is	neg
;
neg1:		cmp	(R5), #104		;
		bne	eneg1			; if in	wrong sequence go to
1$:		inc	(R5)			; halt at the end of the test
		mov	#temp1,	R4		; load address
		mov	#1, (R4)+		; load the location
		mov	R4, R2			;
		mov	#100000, 0(R2)		;
		neg	-(R4)			; 2's complement
		jsr	PC, @#$cc11		; check	for cc = 11
		cmp	#177777, (R4)+		; check	it
		beq	2$			; continue if OK
		mov	#311, -(R5)		;
		inc	-(R5)			;
		halt				; neg instruction failed
						;
2$:		mov	0(R4), -(R4)		; temp1	contains the largest
		neg	(R4)			; negative number
		jsr	PC, @#$cc13		; check	for cc = 13
		cmp	0(R2), (R4)		; check	it
		beq	rol1			; continue if OK
eneg1:		mov	#312, -(R5)		;
		inc	-(R5)			; wrong	result in temp2
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 105 - new instruction in	this section is	rol
;
rol1:		cmp	(R5), #105		;
		bne	erol1			; if in	wrong sequence go to
		inc	(R5)			; hlt at the end of the	test
		mov	#temp2,	R1		; load address
		mov	#20000,	(R1)		; load location
		ccc				; clear	flags
		rol	(R1)+			; shift
		rol	-(R1)			;
		jsr	PC, @#$cc12		; check	for cc = 12
		cmp	#100000, (R1)		; check	it
		beq	1$			; continue if OK
		mov	#313, -(R5)		;
		inc	-(R5)			;
		halt				; rol instruction failed
						;
1$:		rol	0(R1)			; shift
		jsr	PC, @#$cc7		; check	for cc = 7
		mov	R1, R2			; R2 is	now pointing to	temp2
		rol	(R2)			; shift
		cmp	#1, (R1)		; check	it
		beq	ror1			; continue if OK
erol1:		mov	#314, -(R5)		;
		inc	 -(R5)			; wrong	result at temp2
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 106 - new instruction in	this section is	ror

ror1:		cmp	(R5), #106		;
		bne	eror1			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		mov	#temp2,	R2		; load address
		mov	#4, (R2)		; load location
		ccc				; clear	flags
		ror	(R2)			; shift
		ror	(R2)			;
		cmp	#1, (R2)		; check	it
		beq	1$			; continue if OK
		mov	#315, -(R5)		;
		inc	-(R5)			;
		halt				; ror instruction failed
						;
1$:		ror	(R2)			; shift
		jsr	PC, @#$cc7		; check	for cc = 7
		ror	(R2)			; shift
		jsr	PC, @#$cc12		; check	for cc = 12
		cmp	#100000, (R2)		; check	it
		beq	asl1			; continue if OK
eror1:		mov	#316, -(R5)		;
		inc	-(R5)			; wrong	result at temp2
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 107 - new instruction in	this section is	asl
;
asl1:		cmp	(R5), #107		;
		beq	2$			; if in	wrong sequence
		mov	#317, -(R5)		; go to	halt below
		inc	-(R5)			;
		halt				; program is in	wrong sequence
						;
2$:		inc	(R5)			;
		mov	#temp2,	R3		; load address
		mov	#20000,	(R3)		; load location
		ccc				; clear	flags
		asl	(R3)			; shift
		asl	(R3)			;
		jsr	PC, @#$cc12		; check	for cc = 12
		cmp	#100000, (R3)		; check	it
		beq	4$			; continue if OK
		mov	#320, -(R5)		;
		inc	-(R5)			;
		halt				; asl instruction failed
						;
4$:		asl	(R3)			; shift
		jsr	PC, @#$cc7		; check	for cc = 7
		asl	(R3)			; shift
		jsr	PC, @#$cc4		; check	for cc = 4
;_____________________________________________________________________________
;
; TEST 110 - new instruction  in this section is asr
;
asr1:		cmp	(R5), #110		;
		bne	easr1			; if in	wrong sequence go to
1$:		inc	(R5)			; halt at the end of the test
		mov	#temp2,	R4		; load addresses
		mov	#temp, R3		;
		mov	#4, (R4)		; load location
		ccc				; clear	flags
		asr	(R4)			;  shift
		asr	(R4)			;
		cmp	#1, (R4)		; check	it
		beq	2$			; continue if OK
		mov	#321, -(R5)		;
		inc	-(R5)			;
		halt				; asr instruction failed
						;
2$:		asr	(R4)			; shift
		jsr	PC, @#$cc7		; check	for cc = 7
		asr	(R4)			; shift
		jsr	PC, @#$cc4		; check	for cc = 4
		mov	#100002, (R3)		; load location
		asr	(R3)			; shift
		asr	(R3)			;
		jsr	PC, @#$cc11		; check	for cc = 11
		cmp	#160000, (R3)		; check	it
		beq	adc1			; continue if OK
easr1:		mov	#322, -(R5)		;
		inc	-(R5)			; wrong	result in temp
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 111 - new instruction in	this section is	adc
;
adc1:		cmp	(R5), #111		;
		beq	2$			; if in	wrong sequence
		mov	#323, -(R5)		; go to	halt below
		inc	-(R5)			;
		halt				; program is in	wrong sequence
						;
2$:		inc	(R5)			;
		mov	#temp,R0		; load address
		clr	(R0)			; clear	the location
		ccc				; clear	flags
		adc	(R0)			; add C	bit = 0
		jsr	PC, @#$cc4		; check	for cc = 4
		sec				;
		adc	(R0)			; add C	bit = 1
		sec				; C = 1
		adc	(R0)			; again
		jsr	PC, @#$cc0		; check	for cc = 0
		cmp	#2, (R0)		; check	it
		beq	4$			; continue if OK
		mov	#324, -(R5)		;
		inc	-(R5)			;
		halt				; adc instruction failed
						;
4$:		mov	#77777,	(R0)		; load largest positive	number
		sec				; C = 1
		adc	(R0)			; add C	bit = 1
		jsr	PC, @#$cc12		; check	for cc = 12
		cmp	#100000, (R0)		; check	it
		beq	6$			; continue if OK
		mov	#325, -(R5)		;
		inc	-(R5)			;
		halt				; adc instruction failed
						;
6$:		mov	#-1, (R0)		; load -1
		sec				;
		adc	(R0)			; add C	bit = 1
		jsr	PC, @#$cc5		; check	for cc = 5
;_____________________________________________________________________________
;
; TEST 112 - new instruction in	this section is	sbc
;
sbc1:		cmp	(R5), #112		;
		beq	1$			; if in	wrong sequence
		mov	#326, -(R5)		; go to	halt below
		inc	-(R5)			;
		halt				; test is in wrong sequence
						;
1$:		inc	(R5)			;
		mov	#temp, R1		; load address
		mov	#3, (R1)		; load location
		ccc				; clear	flags
		sbc	(R1)			; subtract C bit = 0
		jsr	PC, @#$cc0		; check	for cc = 0
		cmp	#3, (R1)		; check	it
		beq	2$			; continue if OK
		mov	#327, -(R5)		;
		inc	-(R5)			;
		halt				; sbc instruction failed
						;
2$:		sec				;
		sbc	(R1)			; subtract C bit = 1
		sec				; C = 1
		sbc	(R1)			;
		jsr	PC, @#$cc0		; check	for cc = 0
		cmp	#1, (R1)		; check	it
		beq	3$			;
		mov	#330, -(R5)		;
		inc	-(R5)			;
		halt				; sbc instruction failed
						;
3$:		sec				; C = 1
		sbc	(R1)			; subtract C bit = 1
		jsr	PC, @#$cc4		; check	for cc = 4
		sec				; C = 1
		sbc	(R1)			; subtract C bit = 1
		jsr	PC, @#$cc11		; check	for cc = 11
		cmp	#-1, (R1)		; check	it
		beq	4$			; continue if OK
		mov	#331, -(R5)		;
		inc	-(R5)			;
		halt				; sbc instruction failed
						;
4$:		mov	#100000, (R1)		;
		sec				; C = 1
		sbc	(R1)			; subtract C bit = 1
		jsr	PC, @#$cc2		; check	for cc = 2
;_____________________________________________________________________________
;
; TEST 113 - new instruction in	this section is	sxt
;
sxt1:		cmp	(R5), #113		;
		bne	esxt1			; if in	wrong sequence go to
1$:		inc	(R5)			; halt at the end of the test
		mov	#temp1,	R2		; load address
		clr	(R2)			; clear	locations
		scc				;
		clnz				;
		sxt	(R2)			; sign extend
		jsr	PC, @#$cc5		; check	for cc = 5
		tst	(R2)			; location should still	be 0
		beq	2$			; continue if OK
		mov	#332, -(R5)		;
		inc	-(R5)			;
		halt				; sxt instruction failed
						;
2$:		senvc				; set N, V & C bits
		sxt	(R2)			; sign extend
		jsr	PC, @#$cc11		; check	for cc = 11
		cmp	#-1, (R2)		; location should new have -1
		beq	swab1			; continue if OK
esxt1:		mov	#333, -(R5)		;
		inc	-(R5)			; wrong	result in temp1
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 114 - new instruction in	this section is	swab
;
swab1:		cmp	(R5), #114		;
		bne	eswab1			; if in	wrong sequence go to
		inc	(R5)			; halt at the  end of the test
		mov	#temp2,	R3		; load address
		mov	#125125, (R3)		; load bit pattern into	location
		scc				;
		cln				;
		swab	(R3)			; swap bytes of	locations
		jsr	PC, @#$cc10		; check	for cc = 10
		cmp	#52652,	(R3)		; check	it
		beq	1$			; continue if OK
		mov	#334, -(R5)		;
		inc	-(R5)			;
		halt				; swab instruction failed
						;
1$:		mov	#377, (R3)		;
		scc				;
		clz				;
		swab	0(R3)			;
		jsr	PC, @#$cc4		; check	for cc = 4
		cmp	#177400, (R3)		;
		beq	xor1			;
eswab1:		mov	#335 ,-(R5)		;
		inc	-(R5)			; wrong	result in temp2
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 115 - new instruction in	this section is	xor
;
xor1:		cmp	(R5), #115		;
		bne	exor1			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		mov	#-1, R4			; load locations
		mov	#-1, temp1		;
		scc				;
		xor	R4, temp1		; should produce 0's in	temp1
		jsr	PC, @#$cc5		; check	for cc = 5
		mov	#77777,	temp1		;
		mov	#temp1,	R0		; address of temp1 in R0
		sevc				; set V	& C bits
		clz				;
		xor	R4, (R0)		;
		jsr	PC, @#$cc11		; check	for cc = 11
		mov	#125252, R1		; load locations
		mov	#52525,	(R0)+		;
		scc				;
		xor	R1, -(R0)		; should produce 1's in	temp1
		jsr	PC, @#$cc11		; check	for cc = 11
		cmp	#-1, @#temp1		; check	it
		beq	add1			; continue if OK
exor1:		mov	#336, -(R5)		;
		inc	-(R5)			; wrong	result in temp1
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 116 - new instruction in	this section is	add
;
add1:		cmp	(R5), #116		;
		bne	eadd1			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		mov	#temp2,	R0		; load addresses
		mov	#temp, R1		;
		mov	#21421,	temp2		; load locations
		mov	(R0), (R1)		;
		add	(R0), (R1)		; add
		jsr	PC, @#$cc0		; check	for cc 0
		cmp	#43042,	temp		; check	it
		beq	1$			; continue if OK
		mov	#337, -(R5)		;
		inc	-(R5)			;
		halt				; add instruction failed
						;
1$:		clr	(R0)			; clear	location temp2
		addR0				; add R0, (R0)+
		cmp	-(R0), #temp2		;
		beq	2$			;
		mov	#340, -(R5)		;
		inc	-(R5)			; add instruction
		halt				; failed in mode 2
						;
2$:		mov	#-21421, temp2		; load locations
		mov	(R0)+, (R1)		;
		add	-(R0), (R1)		; add
		jsr	PC, @#$cc11		; check	for cc = 11
		cmp	#-43042, temp		; check	it
		beq	3$			; continue if OK
		mov	#341, -(R5)		;
		inc	-(R5)			;
		halt				; add instruction failed
						;
3$:		mov	#100000, temp2		; load locations
		mov	(R0), 0(R1)		;
		add	0(R0), (R1)		; add should result as 1's
		jsr	PC, @#$cc7		; check	for cc = 7
		mov	#21421,	temp1		; load location	temp1
		mov	#temp1,	0(R0)		; address of location temp1 in temp2
		mov	#-21421, (R1)		; load location	temp
		mov	R0, R4			; make R4 point	to location temp2
		add	@0(R4),	(R1)		; add should result as 1's
		jsr	PC, @#$cc5		; check	for cc = 5
		neg	@(R0)+			; negate the contents of temp1
		mov	#21421,	-(SP)		; place	21421 on the stack
		add	@-(R0),0(SP)		; add, should 1's
		jsr	PC ,@#$cc5		; check	for cc = 5
		tst	(SP)+			; check	the stack to contain 0
		beq	4$			; also restore the stack pointer
		mov	#342, -(R5)		;
		inc	-(R5)			; add instruction
		halt				; failed in mode 5
						;
4$:		mov	#137777, temp2		;
		add	#137777, temp2		;
		jsr	PC, @#$cc3		; check	cc = 3
		cmp	#77776,	temp2		;
		beq	sub1			;
eadd1:		mov	#343, -(R5)		;
		inc	-(R5)			; wrong	result at temp
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 117 - new instruction in	this section is	sub
;
sub1:		cmp	(R5), #117		;
		bne	esub1			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		mov	#temp, R2		; load addresses
		mov	#temp1,	R3		;
		mov	#21421,	temp		; load locations
		mov	#-21421, temp1		;
		sub	(R2), (R3)		; result should	-43042
		jsr	PC, @#$cc10		; check	for cc = 10
		cmp	#-43042, temp1		; check	it
		beq	1$			; continue if OK
		mov	#344, -(R5)		;
		inc	-(R5)			;
		halt				; sub instruction failed
						;
1$:		mov	#21421,	temp1		; load location
		sub	(R2), (R3)		; result should	0
		beq	2$			;
		mov	#345, -(R5)		;
		inc	-(R5)			;
		halt				; sub instruction failed
						;
2$:		mov	#-1, temp1		; load locations
		mov	#77777,	temp		; result should	give 100000
		sub	(R3), (R2)		; and overflow
		jsr	PC, @#$cc13		; check	for cc = 13
		cmp	#100000, temp		; check	it
		beq	3$			; continue if	OK
		mov	#346, -(R5)		;
		inc	-(R5)			;
		halt				; sub instruction failed
						;
3$:		mov	#-1, (R2)		;
		sub	(R3), (R2)		;
		jsr	PC, @#$cc4		; check	for cc = 4
		mov	#77777,	temp		;
		sub	#77777,	temp		;
		jsr	PC, @#$cc4		; check	for cc = 4
		tst	temp			;
		beq	sob0			; temp should be 0
						;
esub1:		mov	#347, -(R5)		;
		inc	-(R5)			; slb instruction failed
		halt				; or sequence error
;_____________________________________________________________________________
;
; TEST 120 - new instruction in	this section is	sob
;
sob0:		cmp	(R5), #120		;
		bne	esob0			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		mov	#10., R0		; load registers
		clr	R1			;
1$:		inc	R1			; keep count
		cmp	R1, #10.		;
		ble	2$			;
		mov	#350, -(R5)		;
		inc	-(R5)			;
		halt				; sob instruction failed
						;
2$:		scc				;
		sob	R0, 1$			; sub 1	from  R0 go back to 1$
		jsr	PC, @#$cc17		; check	for cc = 17
		tst	R0			; R0 = 0 ?
		beq	3$			; no, failed
		mov	#351, -(R5)		;
		inc	-(R5)			;
		halt				; sob instruction failed
						;
3$:		cmp	#10., R1		; did it go thru 10 times ?
		beq	4$			; continue if OK
		mov	#352, -(R5)		;
		inc	-(R5)			;
		halt				; sob instruction failed
						;
4$:		mov	#10, R4			; place	10 in R4
5$:		sob	R4, 5$			; stay here until R4 =	0
		tst	R4			;
		beq	pswn0			; continue if OK
esob0:		mov	#353, -(R5)		;
		inc	-(R5)			; sob failed
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; TEST 121 - new instructions in this section are mtps & mfps
;
pswn0:		cmp	(R5), #121		;
		bne	epswn0			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		mov	#temp, R0		; put the address of temp in R0
		mov	#temp1,	R1		; put the address of temp1 in R1
		mov	#177777, (R1)		; temp1	= 177777
		clr	(R0)			; temp = 0
		mtps	(R0)			; PSW =	0
		jsr	PC, @#$cc0		; check	for cc = 0
		mfps	(R1)			;
		jsr	PC, @#$cc4		; check	for cc = 4
		cmp	#177400, (R1)		; check	temp1 to make sure that
		beq	1$			; only the lower byte was affected
		mov	#354, -(R5)		; by mfps
		inc	-(R5)			; mtps or mfps
		halt				; instruction failed
						;
1$:		clr	(R1)			; set PSW to 357 since T bit
		mtps	#377			; can not be set by mtps
		jsr	PC, @#$cc17		; check	for cc = 17
		mfps	temp1			; move PSW to temp1
		jsr	PC, @#$cc11		; check	for cc = 11
		cmp	#357, temp1		;
		beq	btwrd			;
						;
epswn0:		mov	#355, -(R5)		;
		inc	-(R5)			; mfps instruction failed
		halt				; in mode 6 or sequence	error
;_____________________________________________________________________________
;
; TEST 122 - byte instructions requiring word inst, to check
;
btwrd:		cmp	(R5), #122		;
		bne	ebtwrd			; if in	wrong sequence go to
		inc	(R5)			; halt at the end of the test
		clr	R0			;
		scc				;
		movb	#200, R0		; set the highest bit
						; of the lower byte
		jsr	PC, @#$cc11		; check	for cc = 11
		cmp	#177600, R0		; check	for sign
		beq	1$			; extension in R0
		mov	#356, -(R5)		;
		inc	-(R5)			;
		halt				; sign was not extended	in R0
						;
1$:		scc				;
		mov	#177777, R0		;
		movb	#0, R0			; clear	the lower byte of R0
		jsr	PC, @#$cc5		; check	for cc = 5
		tst	R0			; check	R0 for sign extension
		beq	2$			;
		mov	#357, -(R5)		;
		inc	-(R5)			;
		halt				; sign was not extended	in R0
						;
2$:		mov	#temp2,	R4		; R4 is	pointing to temp2
		mov	#377, (R4)		; place	377 in location	temp2
		mov	#start-2, SP		;
		movb	0(R4), (SP)+		; push at 377 on stack
		cmp	#start,	SP		;
		beq	3$			;
		mov	#360, -(R5)		;
		inc	-(R5)			; SP did not get incremented
		halt				; by 2 by a byte instruction
						;
3$:		cmpb	-(SP), #377		; check	location start-2 to
		beq	4$			; contain proper data
		mov	#361, -(R5)		;
		inc	-(R5)			; byte instruction
		halt				; is failing with SP
						;
4$:		cmp	#start-2, SP		; check	that SP	was decremented
		beq	5$			; by 2 by a byte instruction
		mov	#362, -(R5)		;
		inc	-(R5)			;
		halt				; SP was not decremented
						;
5$:		mov	0(R4), temp		; set the lower	byte of	temp
		tst	(SP)+			; restore stack	pointer
		scc				;
		movb	-(SP), temp+1		; set the higher byte of temp
		jsr	PC, @#$cc11		; check	for cc = 11
		cmp	#177777, temp		; check	temp for the correct value
		beq	6$			;
		mov	#363, -(R5)		;
		inc	-(R5)			;
		halt				; temp fouled up
						;
6$:		clr	temp			;
		clc				;
		comb	temp+1			; write	1's in the higher byte
		jsr	PC, @#$cc11		; check	for cc = 11
		cmp	#177400, temp		;
		beq	next			;
						;
ebtwrd:		mov	#364, -(R5)		;
		inc	-(R5)			; wrong	value in temp
		halt				; or wrong sequence
;_____________________________________________________________________________
;
; End of pass routine
;
next:		cmp	(R5), #123		;
		beq	2$			;
		mov	#365, -(R5)		; if in	wrong sequence
		inc	-(R5)			; go to	hlt below
		halt				; program is in	wrong sequence
2$:		inc	$pass			;
		cmpb	$pass, #1		; allow	the type out of	end
		bne	doagn			; of pass every	377 passes
						;
		.type	, endpas		; type end of pass message
.if ne HOEP					;
		halt				; halt on end-of-pass
.endc						;
						;
get42:		mov	@#42, R0		;
		beq	doagn			;
$endad:		jsr	PC, (R0)		;
		nop				;
		nop				;
		nop				;
doagn:		clr	$testn			; prepare to start from	test 0
return:		jmp	start			; start	test over at beginning
;_____________________________________________________________________________
;
; Power	fail routine
;
pwrdn:		mov	#pwrup,	@#24		; go to	power up routine
		halt				; after	the power comes	back
						;
pwrup:		mov	#start,	SP		;
		mov	#pwrdn,	@#24		;
		.type	, power			;
		br	doagn			;
;_____________________________________________________________________________
;
; Type routine
;
type:		bitb	#40, @#$envm		; has the console outputs
		bne	4$			; been suppressed?
		mov	@(SP), R3		; get address of message
						;
1$:		tstb	(R3)			; end of message ?
		beq	4$			; yes, go wrap it up
3$:		tstb	@tps			; ready	for next character ?
		bpl	3$			; no, wait
		movb	(R3)+, @tpb		; load and type	the character
		br	1$			; yes, get the next character
4$:		add	#2, (SP)		; adjust the return PC
		rtt				; return
;_____________________________________________________________________________
;
; Routines to check condition codes
;
$cc0:		ble	1$			;
		bmi	1$			;
		bcc	2$			;
1$:		mov	#366, -(R5)		;
		inc	-(R5)			;
		halt				; wrong	cc, it should
2$:		rts	PC			; have been = 0
						;
$cc1:		ble	1$			;
		bmi	1$			;
		bcs	2$			;
1$:		mov	#367, -(R5)		;
		inc	-(R5)			;
		halt				; wrong	cc, it should
2$:		rts	PC			; have been = 1
						;
$cc2:		bmi	1$			;
		blos	1$			;
		bvs	2$			;
1$:		mov	#370, -(R5)		;
		inc	-(R5)			;
		halt				; wrong	cc, it should
2$:		rts	PC			; have been = 2
						;
$cc3:		bmi	1$			;
		beq	1$			;
		bvc	1$			;
		bcs	2$			;
1$:		mov	#371, -(R5)		;
		inc	-(R5)			;
		halt				; wrong	cc, it should
2$:		rts	PC			; have been = 3
						;
$cc4:		bmi	1$			;
		bne	1$			;
		bvs	1$			;
		bcc	2$			;
1$:		mov	#372, -(R5)		;
		inc	-(R5)			;
		halt				; wrong	cc, it should
2$:		rts	PC			; have been = 4
						;
$cc5:		bmi	1$			;
		bne	1$			;
		bvs	1$			;
		bcs	2$			;
1$:		mov	#373, -(R5)		;
		inc	-(R5)			;
		halt				; wrong	cc, it should
2$:		rts	PC			; have been = 5
						;
$cc7:		bmi	1$			;
		bne	1$			;
		bvc	1$			;
		bcs	2$			;
1$:		mov	#374, -(R5)		;
		inc	-(R5)			;
		halt				; wrong	cc, it should
2$:		rts	PC			; have been = 7
						;
$cc10:		bpl	1$			;
		blos	1$			;
		bvc	2$			;
1$:		mov	#375, -(R5)		;
		inc	-(R5)			;
		halt				; wrong	cc, it should
2$:		rts	PC			; have been = 10
						;
$cc11:		bpl	1$			;
		beq	1$			;
		bvs	1$			;
		bcs	2$			;
1$:		mov	#376, -(R5)		;
		inc	-(R5)			;
		halt				; wrong	cc, it should
2$:		rts	PC			; have been = 11
						;
$cc12:		bpl	1$			;
		blos	1$			;
		bvs	2$			;
1$:		mov	#377, -(R5)		;
		inc	-(R5)			;
		halt				; wrong	cc, it should
2$:		rts	PC			; have been = 12
						;
$cc13:		bpl	1$			;
		ble	1$			;
		bcs	2$			;
1$:		mov	#400, -(R5)		;
		inc	-(R5)			;
		halt				; wrong	cc, it should
2$:		rts	PC			; have been = 13
						;
$cc17:		bpl	1$			;
		bne	1$			;
		bvc	1$			;
		bcs	2$			;
1$:		mov	#401, -(R5)		;
		inc	-(R5)			;
		halt				; wrong	cc, it should
2$:		rts	PC			; have been = 17
;_____________________________________________________________________________
;
		.end
