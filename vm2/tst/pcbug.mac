;
; Тест ошибки предвыборки по адресации @PC
;
; В процессоре 1801ВМ2 есть ошибка микрокода, наблюдается при следующих условиях:
;	- выполняется двухадресная команда
;	- источник имеет метод адресации @PC (17 восьмеричное)
;	- приемник не использует PC (поле регистра приемника !=7)
;	- приемник не использует дополнительные слова инструкции (E(Rn), @E(Rn))
;	- предвыборка из памяти достаточно медленная (много тактов до RPLY/AR)
;	  и не успевает завершиться до момента обработки выборки источника
;
; В момент выборки источника происходит передача адреса источника из регистра PC 
; в регистр адреса для выполнения транзакции чтения @PC, при этом регистр PC
; выдается на шину X АЛУ, код операции АЛУ равен X (просто транслировать 
; аргумент X на выход) с обратной записью результата в PC/PC1/PC2 (одновременно).
; При этом PC2 получает старое значение PC (PC2 уже был обновлен при запуске
; предыдущей предвыборки PC+2). Если в этот момент предыдущая предвыборка
; не завершена, при окончании команды микрокод не будет рестартовать предвыборку
; кодом ЧК (io_cmd) (чтение команды) и извлечение последующих команд будет
; происходить по неверному отстающему значению PC2. Если же предвыборка успела
; завершиться до модификации PC, то микрокод рестартует новую превыборку по PC2
; с признаком ЧК и далее исполнение команд будет корректным
;
; Предложена и реализована коррекция, при выполнении двухадресных команд
; с методом адресации источника @PC и не использовании PC в приемнике, а также
; отсутствии дополнительных слов в инструкции, блокируется запись в PC2,
; тем самым позволяя корректно продолжать предвыборку. Метод более простой
; и предсказуемый с ограниченной областью действия, по сравнению с модификацией
; микрокода и рестартом предвыборки по признаку ЧК (io_rcd)
; 
;_____________________________________________________________________________
;
		.title	pcbug            	; основной тест команд
		.list	meb			;
						;
		R0	= %0			;
		R1	= %1			;
		R2	= %2			;
		R3	= %3			;
		R4	= %4			;
		R5	= %5			;
		SP	= %6			;
		PC	= %7			;
;_____________________________________________________________________________
;
		npass	= 3			; количество проходов теста
						;	
;_____________________________________________________________________________
;
		.macro	vect, offset, adr, val	;
		. 	= offset		;
	.if 	nb, <adr>			;
		.word	adr			;
	.iff					;
		.word	.+2			;
	.endc 					;
	.if	nb, <val>			;
		.word	val			;
	.iff            			;
		.word	0			;
	.endc					;
		.endm				;
						;
		.macro	error, num		; вывод кода ошибки в
		jsr	PC, octerr		; восьмеричном виде
		.word	num			; аргумент расположен
		.endm				; за инструкцией вызова
;_____________________________________________________________________________
;
		.asect      			;
		. = 0				;
						; вектор начального пуска
		vect	0, entry		; для процессора 1801ВМ2
;_____________________________________________________________________________
;
		vect	4			;
		vect	10			;
		vect	14			;
		vect	20			;
		vect	24			;
		vect	30			;
		vect	34			;
		vect	40			;
		vect	44			;
		vect	50			;
		vect	54			;
		vect	60			;
		vect	64			;
		vect	70			;
		vect	74			;
		vect	100			;
		vect	104			;
		vect	110			;
		vect	114			;
		vect	120			;
		vect	124			;
		vect	130			;
		vect	134			;
		vect	140			;
		vect	144			;
		vect	150			;
		vect	154			;
		vect	160			;
		vect	164			;
		vect	170			;
		vect	174			;
;_____________________________________________________________________________
;
		.	= 200			; начальная точка входа в тест
		.blkw	100			;
stack:						;
entry:		mov	#stack,	SP		;
		mtps	#340			; запретили прерывания
		jmp	tst1			; выбираем нужный тест
						;
;_____________________________________________________________________________
;
tst0:		br	1$			;
		nop				;
		nop				;
		nop				;
1$:		mov	#1, R0			;
		mov	#2, R1			;
		mov	#2$, R2			;
		inc	R2			;
		mov	#010104, R3		;
		mov	R3, @R2			;
2$:		mov	R0, R4			;
		halt				;
;_____________________________________________________________________________
;
tst1:		mov	#1, R0			;
		mov	#2, R1			;
		mov	#3, R2			;
		mov	#4, R3			;
		mul	R0, R4			;
		mov	@PC, R4			;
		inc	R0			;
		inc	R1			;
		inc	R2			;
		inc	R3			;
		halt				;
;_____________________________________________________________________________
;
tst2:		mov	#1, R0			;
		mov	#2, R1			;
		mov	#3, R2			;
		mov	#4, R3			;
		mul	R0, R4			;
		mov	@PC, PC			;
1$:		.word	2$			;
		dec	R0			;
		dec	R1			;
		dec	R2			;
		dec	R3			;
		halt				;
2$:		inc	R0			;
		inc	R1			;
		inc	R2			;
		inc	R3			;
		halt				;
;_____________________________________________________________________________
;
tst3:		mov	#1, R0			;
		mov	#2, R1			;
		mov	#3, R2			;
		mov	#4, R3			;
		mul	R0, R4			;
		mov	@PC, 2(R1)		;
		inc	R0			;
		inc	R1			;
		inc	R2			;
		inc	R3			;
		halt				;
;_____________________________________________________________________________
;
tst4:		mov	#1, R0			; проверка одноадрсной команды
		mov	#2, R1			; запись в PC/PC1/PC2 при извлечении
		mov	#3, R2			; источника формируется, но микрокод
		mov	#4, R3			; продолжает выполнение с признаком
		mul	R0, R4			; чтение команды, при котором
		tst	@PC			; устанавливается корректное
		inc	R0			; значение регистра PC2 для
		inc	R1			; предвыборки следующей команды
		inc	R2			;
		inc	R3			;
		halt				;
;_____________________________________________________________________________
;
		.end				;
