; Originally was compiled by MACY-11, an assembler running on the PDP-10.
; The source is adapted to be translated by regular MACRO-11.
;
;			IDENTIFICATION
;			--------------
;
; Product code:		AC-F2418-MC
; Product name:		CJKDCB0	KEF11-AA DIAG #1
; Date:			Nov-79
; Maintainer:		Diagnostic Engineering
;
; The information in this document is subject to change	without	notice
; and should not be construed as a commitment by Digital Equipment
; Corporation. Digital Equipment Corporation assumes no	responsibility
; for any errors that may appear in this document.
;
; The software described in this document is furnished to the purchaser
; under	a license for use on a single computer system and can be copied
; (with	inclusion of Digital's copyright notice) only for use in such
; system, except as may	otherwise be provided in writing by Digital.
;
; Digital equipment corporation	assumes	no responsibility for the use
; or reliability of its	software on equipment that is not supplied by
; Digital.
;
; Copyright (c)	1979 Digital Equipment Corp., Maynard, Mass. 01754
;
; Program history:
;
; Date		    Revision	Reason for revision
;
; June,	1979		A	First release. This program was	assembled
;				using the PDP-11 maindec sysmac	package
;				(maindec-11-dzqac-c3), Jan 19, 1977.
; November, 1979	B	Corrections were made to multi-tester
;				support	code.
;_____________________________________________________________________________
;
;			CONTENTS
;			--------
; 1.0	Abstract.
; 2.0	Requirements.
; 2.1	Equipment.
; 2.2	Storage.
; 2.3	Preliminary programs.
; 3.0	Loading	procedure.
; 4.0	Starting procedure.
; 4.1	Control	switch settings.
; 4.2	Starting address.
; 4.3	Program	and operator interaction.
; 5.0	Operating procedure.
; 5.1	Operational switch settings.
; 5.3	Operator action.
; 6.0	Errors.
; 6.1	Summary.
; 6.2	Error recovery.
; 7.0	Restrictions.
; 7.1	Starting restrictions.
; 7.2	Operating restrictions.
; 8.0	Miscellaneous.
; 8.1	Execution times.
; 8.2	Stack pointer.
; 8.3	Pass count.
; 8.4	T-bit trapping.
; 8.5	Software switch	register.
; 8.6	ACT, APT and XXDP compatibility.
; 9.0	Program	description.
; 9.1	CJKDCB
; 10.0	Listing
; 10.1	CJKDCB
;
; 1.0	Abstract
;
;	The two	programs:
;
;	CJKDCB,	CJKDDB
;
;	Are design to detect and report	logic faults in	the
;	F-11 MMU and floating point chip set. The
;	design is an attempt to	reach all mirco-code locations.
;	Tests are partitioned into two stand-alone programs
;	described below.
;
;	Note that error	reports	in these programs are based
;	upon the knowledge that	all previous tests (CPU, MMU) have
;	been run and in	most case that there is	only a single
;	point fault exists. If the programs or tests
;	are not	run in order then error	messages may not be
;	accurate.
;
;	A. CJKDCB
;
;	CJKDCB tests: (floating	point test 1)
;		ldfps
;		stfps
;		cfcc
;		setf, setd, seti and setl
;		stst
;		ldf and	ldd (all source	modes)
;		std (mode 0 and	1)
;		addf, addd and subd (most conditions)
;		addf, addd and subd (all conditions not
;				tested in dffpa)
;		cmpd and cmpf
;		divd and divf
;		muld and mulf
;		modd and modf
;
;	B. CJKDDA
;
;	CJKDDA tests: (floating	point test 2)
;
;		stf and	std (all modes)
;		stcfd and stcdf
;		clrd and clrf
;		negf and negd
;		absf and absd
;		tstf and tstd
;		negf, absf and tstf (all source	modes)
;		negf, absf and tstf (all source	modes)
;		ldfps (all source modes)
;		ldcif and ldclf
;		ldcid and ldcld
;		ldexp
;		stfps (all destination modes)
;		stcfl and stcfi
;		stcdl and stcdi
;		stexp
;		stst
;
; 2.0	Requirements
;
; 2.1	Equipment
;
;	A processor with the DCF11-AA, KTF11-AA	and KEF11-A chip set.
;
; 2.2	Storage
;
;	Both programs require a	memory system of at
;	least 16k to load and run.
;
; 2.3	Preliminary programs
;
;	These two diagnostics will assume that the
;	basic central processor	is faultless, therefore
;	when in	doubt run the DCF11-AA processor diag-
;	nostics	before these floating point diagnostics.
;
; 3.0	Loading	procedure
;
;	The programs will be supplied on the 11/23
;	diagnostic media. Refer	to the XXDP operating
;	manual for further information.
;
; 4.0	Starting procedure
;
; 4.1	Control	switch settings
;
;	See section 5.1
;
; 4.2	Program	and operator action
;
;	1.	Load program into memory
;	2.	Load address 200
;	3.	Set console switches (if console is present)
;	4.	Press start
;		on first pass the program
;		will identify itself. Note that	if there is
;		no physical console the	program	will request
;		the operator for initial value for the
;		software switch	register (see section 8.5).
;		If running under ACT, APT or chain this	does
;		not apply.
;	5.	The program will loop and an end of pass will
;		be typed at the	end of every pass.
;
; 5.0	Operating procedure
;
; 5.1	Operational switch settings
;
;	The switch setting are:
;
;			Octal
;	sw<15>=1...	100000	Halt on	error
;	sw<14>=1...	 40000	Loop on	current	test
;	sw<13>=1...	 20000	Inhibit	error type outs
;	sw<12>=1...	 10000	Inhibit	T-bit trapping
;	sw<11>=1...	  4000	Inhibit	iterations
;	sw<10>=1...	  2000	Ring TTY bell on error
;	sw<9>=1....	  1000	Loop on	error
;	sw<8>=1....	   400	Loop on	test specified in sw<6>
;				through	sw<0>
;
; 6.0	Errors
;
; 6.1	Summaries
;
;	When an	error is encountered, an error message accompanied
;	by the error PC	are typed.
;	There are four standard	error messages used, describing
;	the probable cause of failure, such as:	probably bad MMU chip;
;	bad FP1	chip; bad hybrid FP chip; floating point error.
;
; 6.2	Error recovery
;
;	sw<15:9>=0...	Most errors will cause execution to
;			go to the start	of the next test
;			after the message is typed. A few
;			tests are in sections. In these
;			tests an error will cause execution
;			to go to the next section after	the
;			message	is typed.
;
;	sw<15>=1...	The program will halt after typing
;			the error message. Pressing the
;			console	continue will cause the
;			program	to continue as if sw<15>=0.
;
; 7.0	Restrictions
;
;	None
;
; 8.0	Miscellaneous
;
; 8.1	Execution times
;
;	Less than 2 seconds for	each program on	any pass.
;
; 8.2	Stack pointer
;
;	The stack pointer is initialized to 1100 in each of
;	the two	programs.
;
; 8.3	Pass count
;
;	The program makes one pass for each end	of pass
;	message	typed. The end of pass message describes
;	the total number of passes completed.
;
; 8.4	T-bit trapping
;
;	If sw<12>=0 each program will run with trace traps
;	on every other pass. First pass	will not enable
;	trace traps. Note sw<12>=1 disables T-bit traps.
;
; 8.5	Software switch	register
;
;	Each of	the two	programs will run with or without
;	a console switch register. If a	physical console
;	switch register	is present on the system, then these
;	programs will go ahead and use it for the switch
;	functions described in 5.1 above. If however there
;	is no console switch register on the system a
;	software switch	register will be used. This
;	software switch	register can be	examined or modified
;	at any time by the user	if he types Control-G while
;	the program is running.	This Control-G will cause
;	the contents of	the software switch register to	be
;	typed on the TTY and ask the user for a	new value.
;	when the user types a value and	carriage return	then
;	the program will resume	testing	at the same point at
;	which it left off when the user	typed Control-G.
;	note that when not running under act, apt or chain
;	the user will be asked for a software switch
;	register value after loading address 200 and
;	starting the program the first time the	program	is
;	run after loading (only	if no console switch
;	register is on the system).
;
; 8.6	ACT, APT and XXDP compatibilty
;
;	These programs are fully compatible with:
;		APT
;		ACT
;		XXDP monitor and chain programs.
;
; 9.0	Program	description
;
; Test 1	ldfps, stfps and data paths test
;
;		This is	a test of the ldfps (load floating point
;		status)	and stfps (store floating point	status)
;		instructions. Various pattern are used and run
;		through	the floating point status register.
;		only dm0 and sm0 are used. Note	that a
;		mask must be used because some of the fps bits
;		cannot be set.
;
; Test 2	cfcc test
;
;		This is	a test of the copy condition codes
;		instruction, cfcc.
;
; Test 3	setf, setd, seti and setl test
;
;		This is	a test of the setf, setd, seti and setl
;		instructions. Each instruction is executed with	the
;		fps containing all ones	and also with the fps clear.
;		the result of each situation is	checked.
;
; Test 4	Illegal	FPP op codes and stst test
;
;		This is	a test of the FPP operation codes:
;			170003
;			170004
;			170010
;			170013
;			170014
;			170077
;		These are illegal instructions and with	interrupts
;		enabled	should cause a trap to 244. Also tested
;		here is	the instruction: stst R1, which	should put
;		the fec	code 2 in R1, after any	of the above op
;		codes is executed.
;
; Test 5	fid, interrupt disable,	bit test
;
;		This is	a test of fps bit 14 (fid) or floating
;		interrupt disable. An illegal instruction is
;		executed with fid=1. No	interrupt should occur.
;
; Test 6	ldd and	std, with src and dst mode 1 test
;
;		This is	a test of both the instruction:
;			ldd	(R0), ac0
;		and the	instruction:
;			std	ac0, (R0)
;		most of	the
;		failures are isolated to the src or dst	flows. Note
;		that the integrity of ac0 has not been assured.
;		This means that	in some	cases it will be impossible
;		to isolate certain data	pattern	failures to either
;		the flows or this accumulator.
;
; Test 7	fsrc mode 0 test
;
;		This is	a test of fsrc mode zero using the ldd and
;		ldf instructions.
;
; Test 10	fdst mode 0 test
;
;		This is	a test of the store instructions. std and
;		stf, with fdst mode 0.
;
; Test 11	Accumulators data patterns test
;
;		This is	a test of the floating point processor
;		accumulators.
;		Each accumulator is tested in two ways:
;			1. Test	pattern	generated by floating a
;			one across a field of zeroes.
;			2. Test	pattern	generated by floating a
;			zero across a field of ones.
;		Each of	accumulators ac0 through ac5 is	tested.
;
; Test 12	FPP accumulators dual address test
;
;		This test performs a dual addressing test on the
;		floating accumulators. Note that accumulator zero
;		is used	to access all the others.
;
; Test 13	fsrc mode 0 with illegal accumulator test
;
;		This is	a test of fsrc mode 0 with accumulators	6
;		and 7. Use of either of	these non-existent
;		accumulators should result in a	trap to	244 with
;		fec=2 (illegal FPP instruction).
;
; Test 14	fsrc mode 2 test
;
;		This is	a test of fsrc mode 2, auto increment mode.
;
; Test 15	fsrc mode 4 test
;
;		This is	a test of fsrc mode 4, auto decrement mode.
;
; Test 16	fsrc mode 2, with fd=0,	test
;
;		This is	a test of fsrc mode 2 with fd=0, (auto
;		increment)
;
; Test 17	fsrc mode 2 with gr7, immediate	mode, test
;
;		This is	a test of fsrc mode 2 using gr7	(the PC).
;		This is	immediate mode.
;
; Test 20	fsrc mode 3 test
;
;		This is	a test of fsrc mode 3, auto increment deferred
;
; Test 21	fsrc mode 5 test
;
;		This is	a test of fsrc mode 5, auto decrement deferred.
;
; Test 22	fsrc mode 6 test
;
;		This is	a test of fsrc mode 6, index mode
;
; Test 23	fsrc mode 7 test
;
;		This is	a test of fsrc mode 7, index deferred mode.
;
; Test 24	(but ezbt y8), (but enbt) and (but fiuv) test
;
;		This is	a test of the (but ezbt	y8) fork, the (but
;		enbt) fork and (but fiuv) fork in the load
;		instruction flows.
;		Each of	the patterns:
;			0
;			+num
;			-num
;			-0
;		is loaded twice. Once with ac>0	then with ac=0.
;		After each load	the fps	is check to insure that
;		control	was passed through with	the forks properly.
;
; Test 25	addf, addd, subf and subd with fsrc=ac=0 test
;
;		This is	a test of add and sub with fsrc=ac=0
;
; Test 26	addd and sub with fsrc=0
;
;		This is	a test of add and sub with fsrc=0.
;
; Test 27	subd with ac=0 test
;
;		This is	a test of subd with ac=0, both positive	and
;		negative fsrc's	are tried.
;
; Test 30	addd with ac=0 test
;
;		Positive and negative fsrc's are tried.
;
; Test 31	addf and addd with e(ac)=e(fsrc) and (but ft) test
;
;		This is	a test of the add instruction with the
;		operands having	equal exponents. The (buf ft) fork
;		in the round/trunk flows is also tested.
;
; Test 32	addf and addd with e(ac) less than e(fsrc) test
;
;		This is	atest of the addd and addf instructions	and
;		the align ac algorithm flows. The constant (25 for
;		floating, 57 for double) used is checked. Then
;		simple and worst case alignment	situations are
;		tried. Note e(ac) is less then e(fsrc)
;
; Test 33	addf and addd with e(ac) greater than e(fsrc) test
;
;		This is	a test of the addd and addf instructions and
;		the align fsrc algorithm flows.	First the constant
;		used is	checked. Then simple and worst case
;		alignment situations are tried.	Note e(ac) is
;		greater	than e(fsrc).
;
; Test 34	addd with negatve oprands test
;
;		This is	a test of the addd instruction with negative
;		operands. Every	combination of operand signs is
;		tried.
;
; Test 35	subd test
;
;		This is	a test of the subd instruction.	Both a
;		positive and a negative	number is subtracted from it
;		self
;
; Test 36	Normalize algorithm test
;
;		This is	a test of the normalize	flow algorithm.	Two
;		patterns are used, first the minimum situation
;		requiring one left shift and then the maximum
;		situation requiring 56 shifts.
;
; Test 37	Round/trunk test
;
;		This is	a test of the round/trunk flows. In
;		particular two things are tested: first	a condition
;		in which rounding results in the need for
;		renormalization, and second the	PSW condition codes
;		N and Z-bit combinations
;
; Test 40	Over/under test
;
;		This is	a partial test of the over/under flows.	One
;		overflow and two underflow conditions are checked.
;		The remaining underflow	cond. And the remaining
;		overflow cond. Will be checked later using the xxx
;		instruction. Here each condition tested	is checked
;		both with traps	enabled	(fiu=1 or fiv=1) and also
;		with traps disabled (fiu=0 or fiv=0).
;
; Test 41	ldcfd and ldcdf	test
;
;		This is	a test of ldcfd	and ldcdf.
;
; Test 42	cmpd test
;
;		This is	a test of the cmpd instruction.	Note that a
;		subroutine is used to set up operands. Execute the
;		instruction and	check the results.
;
; Test 43	divd with (fsrc=0) and (but fd)	test
;
;		This is	a test of the divd instruction with a zero
;		divisor. The condition is checked with both trap
;		enabled	and traps disabled.
;
; Test 44	divf test
;
;		This is	a test of the divf instruction.	Note that a
;		subroutine is used to set up the operands, execute
;		the instruction	and check results.
;
; Test 45	divd test
;
;		This is	a test of the divd instruction.	Note that a
;		subroutine is used to set up the operands. Execute
;		the instruction	and check the results.
;
; Test 46	mulf test
;
;		This is	a test of the mulf instruction.	It makes
;		use of a subroutine to set up the operands, execute
;		the mulf instruction and check the results.
;
; Test 47	muld test
;
;		This is	a test of the muld instruction.	Note that a
;		subroutine is used to set up the operands, execute
;		the muld instruction and check the results.
;
; Test 50	Under/over flow, using mulf with traps disabled, test
;
;		This is	a test of the overflow and underflow
;		conditions using the mulf instruction with traps
;		disabled. Note that a subroutine is used to set	up
;		the operands. Execute the mulf instruction and check
;		the results.
;
; Test 51	Under/over flow, using muld with traps disabled, test
;
;		This is	a test of the overflow and underflow
;		conditions that	can arrise using the muld
;		instruction with traps disabled. A subroutine is
;		used to	set up the operands. Execute the muld
;		instruction and	check the results.
;
; Test 52	Under/over flow, using mulf with traps enabled,	test
;
;		This is	a test of the underflow	and overflow
;		conditions that	can occur using	the mulf
;		instruction. A subroutine is called to set up the
;		operands, execute the mulf instruction and check the
;		results. Here the particular interrupt,	either
;		overflow or underflow, is enabled so a trap should
;		occur.
;
; Test 53	Under/over flow, using muld wfh	traps enabled, test
;
;		This is	a test of the over flow	and under flow
;		conditions using the muld instruction with traps
;		enabled. A subroutine is used to set up	the
;		operands. Execute the muld instruction and check the
;		results.
;
; Test 54	mode test
;
;		this is	a test of the mode instruction,	which makes
;		use of a subroutine to set up the operands. Execute
;		the modf instruction and check the results.
;
; Test 55	modd test
;
;		This is	a test of the modd instruction.	It makes
;		use of a subroutine to set up the arguments. Execute
;		the instruction	and check the results.
;
; Test 56	Under/over flow, using modf with traps disabled, test
;
;		This is	a test of the modf overflow and	underflow
;		conditions. It makes use of a subroutine to setup
;		the operands, execute the modf instruction and check
;		the results. Traps are disabled	during this test.
;
; Test 57	Under/over flow, using modd with traps disabled, test
;
; Test 60	More microcodes	coverage, test
;
; 10.		Listing
;_____________________________________________________________________________
;
		HOEP	= 0			; halt on end-of-pass
		NOSCO	= 0			; no scope trap	and gtswr
		INSWR	= 000000		; 100000 for halt on error, no gtswr
;_____________________________________________________________________________
;
		.asect				;
		. = 0				; loop on test

		.title	CJKDCB KEF11-A FP DIAG PART 1
		.nlist	cnd, mc, md
		.list	me
;_____________________________________________________________________________
;
		$tn	= 1			;
		$swr	= 160000		; halt on error, loop on test, inhibit error typout
		fpvect	= 244			;
		$swr	= 177400		;
		$swrmsk	= 200			;
		tab	= 11			;
		crlf	= 15			;
;_____________________________________________________________________________
;
		.sbttl	"BASIC DEFINITIONS"

		stack	= 1100			; initial address of the stack pointer
						; .equiv emt, error - basic definition of error	call
.if ne NOSCO					;
		scope	= 240			; nop
.iff						;
		scope	= iot			; .equiv iot, scope - basic definition of scope	call
.endc						;
						;
						; miscellaneous	definitions
		ht	= 11			; code for horizontal tab
		lf	= 12			; code for line	feed
		cr	= 15			; code for carriage return
		crlf	= 200			; code for carriage return-line	feed
		ps	= 177776		; processor status word
						;
		stklmt	= 177774		; stack	limit register
		pirq	= 177772		; program interrupt request register
		dswr	= 177570		; hardware switch register
		ddisp	= 177570		; hardware display register
						;
		type	= 104401		; trap+1 tty typeout routine
		typoc	= 104402		; trap+2 type octal number (with leading zeros)
		typos	= 104403		; trap+3 type octal number (no leading zeros)
		typon	= 104404		; trap+4 type octal number (as per last	call)
		typds	= 104405		; trap+5 type decimal number (with sign)
.if ne INSWR					;
		gtswr	= 240			; nop
.iff						;
		gtswr	= 104406		; trap+7 get soft-swr setting
.endc						;
		ckswr	= 104407		; trap+7 test for change in soft-swr
		rdchr	= 104410		; trap+10 tty type in character	routine
		savreg	= 104411		; trap+11 save R0-R5 routine
		resreg	= 104412		; trap+12 restore R0-R5	routine
		rsetup	= 104413		; trap+13 routine to initialize	at end of each test
		lperr	= 104414		; trap+14 routine to set up loop on error address
						;
						; general purpose register definitions
		R0	= %0			; general register
		R1	= %1			; general register
		R2	= %2			; general register
		R3	= %3			; general register
		R4	= %4			; general register
		R5	= %5			; general register
		R6	= %6			; general register
		R7	= %7			; general register
		SP	= %6			; stack	pointer
		PC	= %7			; program counter
						;
						; priority level definitions
		pr0	= 0			; priority level 0
		pr1	= 40			; priority level 1
		pr2	= 100			; priority level 2
		pr3	= 140			; priority level 3
		pr4	= 200			; priority level 4
		pr5	= 240			; priority level 5
		pr6	= 300			; priority level 6
		pr7	= 340			; priority level 7
						;
		sw15	= 100000		; "switch register" switch definitions
		sw14	= 40000			;
		sw13	= 20000			;
		sw12	= 10000			;
		sw11	= 4000			;
		sw10	= 2000			;
		sw9	= 1000			;
		sw8	= 400			;
		sw7	= 200			;
		sw6	= 100			;
		sw5	= 40			;
		sw4	= 20			;
		sw3	= 10			;
		sw2	= 4			;
		sw1	= 2			;
		sw0	= 1			;
						;
		bit15	= 100000		; data bit definitions (bit0 to	bit15)
		bit14	= 40000			;
		bit13	= 20000			;
		bit12	= 10000			;
		bit11	= 4000			;
		bit10	= 2000			;
		bit9	= 1000			;
		bit8	= 400			;
		bit7	= 200			;
		bit6	= 100			;
		bit5	= 40			;
		bit4	= 20			;
		bit3	= 10			;
		bit2	= 4			;
		bit1	= 2			;
		bit0	= 1			;
						; basic	"CPU" trap vector addresses
		errvec	= 4			; time out and other errors
		resvec	= 10			; reserved and illegal instructions
		tbitvec	= 14			; T-bit
		trtvec	= 14			; trace	trap
		bptvec	= 14			; breakpoint trap (bpt)
		iotvec	= 20			; input/output trap (iot) **scope**
		pwrvec	= 24			; power	fail
		emtvec	= 30			; emulator trap	(emt) **error**
		trapvec	= 34			; "trap" trap
		tkvec	= 60			; tty keyboard vector
		tpvec	= 64			; tty printer vector
		pirqvec	= 240			; program interrupt request vector
;_____________________________________________________________________________
;
		.sbttl "FPP REGISTER DEFINITIONS"

		ac0	= %0			;
		ac1	= %1			;
		ac2	= %2			;
		ac3	= %3			;
		ac4	= %4			;
		ac5	= %5			;
		ac6	= %6			;
		ac7	= %7			;
;_____________________________________________________________________________
;
		.macro	vect, offset, adr, val	;
		.	= offset		;
	.if	nb, <adr>			;
		.word	adr			;
	.iff					;
		.word	.+2			;
	.endc					;
	.if	nb, <val>			;
		.word	val			;
	.iff					;
		.word	0			;
	.endc					;
		.endm				;
;_____________________________________________________________________________
;
; All unused locations from 4-776 contain a ".+2, halt"
; sequence to catch illegal traps and interrupts
; Location 0 contains 0	to catch improperly loaded vectors
;
		.sbttl	"TRAP CATCHER"
		. = 0
						;
		vect	0, 0,			;
		vect	4, 6			;
		vect	10, 12			;
		vect	14, 16			;
		vect	20, 22,			;
		vect	24, 200			; for APT start	up
		vect	30, 32			;
		vect	34, 36			;
		vect	40, 42,			; hooks	required by ACT-11
		vect	44, $apthd, $endad	; set loc.46 to	address	of $endad in .seop
						;
;_____________________________________________________________________________
;
		.sbttl	"ACT11 HOOKS"

		vect	50, 52			; set loc.52 to	zero
		vect	54, 56			;
		vect	60, 62			;
		vect	64, 66			;
		vect	70, 72			;
		vect	74, 76			;
		vect	100, 102		;
		vect	104, 106		;
		vect	110, 112		;
		vect	114, 116		;
		vect	120, 122		;
		vect	124, 126		;
		vect	130, 132		;
		vect	134, 136		;
		vect	140, 142		;
		vect	144, 146		;
		vect	150, 152		;
		vect	154, 156		;
		vect	160, 162		;
		vect	164, 166		;
		vect	170, 172		;
;_____________________________________________________________________________
;
						;
		. = 174				;
dispreg:	.word	0			; software display register
swreg:		.word	INSWR			; software switch register
						;

		.sbttl "STARTING ADDRESS(ES)"

		jmp	@#start			; jump to starting address of program
;_____________________________________________________________________________
;
		vect	204, 206		;
		vect	210, 212		;
		vect	214, 216		;
		vect	220, 222		;
		vect	224, 226		;
		vect	230, 232		;
		vect	234, 236		;
		vect	240, 242		;
		vect	244, 246		;
		vect	250, 252		;
		vect	254, 256		;
		vect	260, 262		;
		vect	264, 266		;
		vect	270, 272		;
		vect	274, 276		;
		vect	300, 302		;
		vect	304, 306		;
		vect	310, 312		;
		vect	314, 316		;
		vect	320, 322		;
		vect	324, 326		;
		vect	330, 332		;
		vect	334, 336		;
		vect	340, 342		;
		vect	344, 346		;
		vect	350, 352		;
		vect	354, 356		;
		vect	360, 362		;
		vect	364, 366		;
		vect	370, 372		;
		vect	374, 376		;
		vect	400, 402		;
		vect	404, 406		;
		vect	410, 412		;
		vect	414, 416		;
		vect	420, 422		;
		vect	424, 426		;
		vect	430, 432		;
		vect	434, 436		;
		vect	440, 442		;
		vect	444, 446		;
		vect	450, 452		;
		vect	454, 456		;
		vect	460, 462		;
		vect	464, 466		;
		vect	470, 472		;
		vect	474, 476		;
		vect	500, 502		;
		vect	504, 506		;
		vect	510, 512		;
		vect	514, 516		;
		vect	520, 522		;
		vect	524, 526		;
		vect	530, 532		;
		vect	534, 536		;
		vect	540, 542		;
		vect	544, 546		;
		vect	550, 552		;
		vect	554, 556		;
		vect	560, 562		;
		vect	564, 566		;
		vect	570, 572		;
		vect	574, 576		;
		vect	600, 602		;
		vect	604, 606		;
		vect	610, 612		;
		vect	614, 616		;
		vect	620, 622		;
		vect	624, 626		;
		vect	630, 632		;
		vect	634, 636		;
		vect	640, 642		;
		vect	644, 646		;
		vect	650, 652		;
		vect	654, 656		;
		vect	660, 662		;
		vect	664, 666		;
		vect	670, 672		;
		vect	674, 676		;
		vect	700, 702		;
		vect	704, 706		;
		vect	710, 712		;
		vect	714, 716		;
		vect	720, 722		;
		vect	724, 726		;
		vect	730, 732		;
		vect	734, 736		;
		vect	740, 742		;
		vect	744, 746		;
		vect	750, 752		;
		vect	754, 756		;
		vect	760, 762		;
		vect	764, 766		;
		vect	770, 772		;
		vect	774, 776		;

		.sbttl "COMMON TAGS"
;_____________________________________________________________________________
;
; This table contains various common storage locations
; used in the program.
;
		. = 1100
$cmtag:						; start	of common tags
		.word	0			;
$tstnm:		.byte	0			; contains the test number
$erflg:		.byte	0			; contains error flag
$icnt:		.word	0			; contains subtest iteration count
$lpadr:		.word	0			; contains scope loop address
$lperr:		.word	0			; contains scope return	for errors
$erttl:		.word	0			; contains total errors	detected
$itemb:		.byte	0			; contains item	control	byte
$ermax:		.byte	1			; contains max.	errors per test
$errpc:		.word	0			; contains PC of last error instruction
$gdadr:		.word	0			; contains address of "good" data
$bdadr:		.word	0			; contains address of "bad" data
$gddat:		.word	0			; contains "good" data
$bddat:		.word	0			; contains "bad" data
		.word	0			; reserved-not to be used
		.word	0			;
$autob:		.byte	0			; automatic mode indicator
$intag:		.byte	0			; interrupt mode indicator
		.word	0			;
swr:		.word	dswr			; address of switch register
display:	.word	ddisp			; address of display register
$tks:		177560				; tty kbd status
$tkb:		177562				; tty kbd buffer
$tps:		177564				; tty printer status reg. address
$tpb:		177566				; tty printer buffer reg. address
$null:		.byte	0			; contains null	character for fills
$fills:		.byte	2			; contains # of	filler characters required
$fillc:		.byte	12			; insert fill chars. after a "line feed"
$tpflg:		.byte	0			; "terminal available" flag (bit<07>=0 - yes)
$regad:		.word	0			; contains the address from
						; which	($reg0)	was obtained
$reg0:		.word	0			; contains (($regad)+0)
$reg1:		.word	0			; contains (($regad)+2)
$reg2:		.word	0			; contains (($regad)+4)
$reg3:		.word	0			; contains (($regad)+6)
$reg4:		.word	0			; contains (($regad)+10)
$reg5:		.word	0			; contains (($regad)+12)
$reg6:		.word	0			; contains (($regad)+14)
$reg7:		.word	0			; contains (($regad)+16)
$reg10:		.word	0			; contains (($regad)+20)
$reg11:		.word	0			; contains (($regad)+22)
$reg12:		.word	0			; contains (($regad)+24)
$reg13:		.word	0			; contains (($regad)+26)
$reg14:		.word	0			; contains (($regad)+30)
$reg15:		.word	0			; contains (($regad)+32)
$reg16:		.word	0			; contains (($regad)+34)
$reg17:		.word	0			; contains (($regad)+36)
$reg20:		.word	0			; contains (($regad)+40)
$reg21:		.word	0			; contains (($regad)+42)
$reg22:		.word	0			; contains (($regad)+44)
$reg23:		.word	0			; contains (($regad)+46)
$tmp0:		.word	0			; user defined
$tmp1:		.word	0			; user defined
$tmp2:		.word	0			; user defined
$tmp3:		.word	0			; user defined
$tmp4:		.word	0			; user defined
$tmp5:		.word	0			; user defined
$tmp6:		.word	0			; user defined
$tmp7:		.word	0			; user defined
$tmp10:		.word	0			; user defined
$tmp11:		.word	0			; user defined
$tmp12:		.word	0			; user defined
$tmp13:		.word	0			; user defined
$tmp14:		.word	0			; user defined
$tmp15:		.word	0			; user defined
$tmp16:		.word	0			; user defined
$tmp17:		.word	0			; user defined
$tmp20:		.word	0			; user defined
$tmp21:		.word	0			; user defined
$tmp22:		.word	0			; user defined
$tmp23:		.word	0			; user defined
$times:		0				; max. number of iterations
$escape:	0				; escape on error address
$bell:		.asciz	<207><377><377>		; code for bell
$ques:		.ascii	/?/			; question mark
$crlf:		.ascii	<15>			; carriage return
$lf:		.asciz	<12>			; line feed

		.sbttl "APT MAILBOX-ETABLE"

		.even				;
$mail:						; APT mailbox
$msgty:		.word	0			; amsgty	- message type code
$fatal:		.word	0			; afatal	- fatal	error number
$testn:		.word	0			; atestn	- test number
$pass:		.word	0			; apass		- pass count
$devct:		.word	0			; adevct	- device count
$unit:		.word	0			; aunit		- I/O unit number
$msgad:		.word	0			; amsgad	- message address
$msglg:		.word	0			; amsglg	- message length
$etable:					;		APT environment	table
$env:		.byte	0			; aenv		- environment byte
$envm:		.byte	0			; aenvm		- environment mode bits
$swreg:		.word	0			; aswreg	- APT switch register
$uswr:		.word	0			; auswr		- user switches
$cpuop:		.word	0			; acpuop	- cpu type, options
						; bits 15-11 - cpu type
						; 11/04=01, 11/05=02, 11/20=03,	11/40=04, 11/45=05
						; 11/70=06, pdq=07, q=10
						; bit 10 - real	time clock
						; bit 9	- floating point processor
						; bit 8	- memory management
imams1:		.byte	0			; high address,	m.s. byte
$mtyp1:		.byte	0			; mem.type, blk#1
						; mem.type byte	- (high	byte)
						; 900 nsec core=001
						; 300 nsec bipolar=002
						; 500 nsec mos=003
$madr1:		.word	0			; high address,	blk#1
						; mem.last addr.=3 bytes, this word and	low of "type" above
$mams2:		.byte	0			; high address,	m.s. byte
$mtyp2:		.byte	0			; mem.type, blk#2
$madr2:		.word	0			; mem.last address, blk#2
$mams3:		.byte	0			; high address,	m.s.byte
$mtyp3:		.byte	0			; mem.type.blk#3
$madr3:		.word	0			; mem.last address, blk#3
$mams4:		.byte	0			; high address,	m.s.byte
$mtyp4:		.byte	0			; mem.type, blk#4
$madr4:		.word	0			; mem.last address, blk#4
$vect1:		.word	0			; interrupt vector#1, bus priority#1
$vect2:		.word	0			; interrupt vector#2, bus priority#2
$base:		.word	0			; base address of equipment under test
$devm:		.word	0			; device map
$cdw1:		.word	0			; controller description word#1
$cdw2:		.word	0			; controller description word#2
$ddw0:		.word	0			; device descriptor word#0
$ddw1:		.word	0			; device descriptor word#1
$ddw2:		.word	0			; device descriptor word#2
$ddw3:		.word	0			; device descriptor word#3
$ddw4:		.word	0			; device descriptor word#4
$ddw5:		.word	0			; device descriptor word#5
$ddw6:		.word	0			; device descriptor word#6
$ddw7:		.word	0			; device descriptor word#7
$ddw8:		.word	0			; device descriptor word#8
$ddw9:		.word	0			; device descriptor word#9
$ddw10:		.word	0			; device descriptor word#10
$ddw11:		.word	0			; device descriptor word#11
$ddw12:		.word	0			; device descriptor word#12
$ddw13:		.word	0			; device descriptor word#13
$ddw14:		.word	0			; device descriptor word#14
$ddw15:		.word	0			; device descriptor word#15
$etend:

		.sbttl "ERROR POINTER TABLE"

; This table contains the information for each error that can occur.
; The information is obtained by using the index number	found in
; location $itemb. This	number indicates which item in the table is pertinent.
; Note1: if $itemb is 0	the only pertinent data	is $errpc.
; Note2: each item in the table	contains 4 pointers explained as follows:
;
;		em				; points to the	error message
;		dh				; points to the	data header
;		dt				; points to the	data
;		df				; points to the	data format
$errtb:						; item number
		.word	em1
		.word	em2
		.word	em3
		.word	em4
;_____________________________________________________________________________
;
		.sbttl	"APT PARAMETER BLOCK"
;
; Setup	APT parameter block as defined in the APT-PDP11	diagnostic
; interface spec.
;
$apthd:						;
$hibts:		.word	0			; two high bits	of 18 bit mailbox addr.
$mbadr:		.word	$mail			; address of APT mailbox (bits 0-15)
$tstm:		.word	10			; run tim of longest test
$pastm:		.word	40			; run time in secs. of 1st pass	on 1 unit (quick verify)
$unitm:		.word	0			; additional runtime (secs) of a pass for each additional unit
		.word	$etend-$mail/2		; length mailbox-etable	(words)
						;
start:
		.sbttl "INITIALIZE THE COMMON TAGS"

						; clear	the common tags	($cmtag) area
		mov	#$cmtag, R6		; first	location to be cleared
		clr	(R6)+			; clear	memory location
		cmp	#swr, R6		; done?
		bne	.-6			; loop back if no
		mov	#stack,	SP		; setup	the stack pointer
; initialize a few vectors
		mov	#$scope, @#iotvec	; iot vector for scope routine
		mov	#340, @#iotvec+2	; level	7
		mov	#$error, @#emtvec	; emt vector for error routine
		mov	#340, @#emtvec+2	; level	7
		mov	#$trap,	@#trapvec	; trap vector for trap calls
		mov	#340, @#trapvec+2	; level	7
		mov	#$pwrdn, @#pwrvec	; power	failure	vector
		mov	#340, @#pwrvec+2	; level	7
		mov	$endct,	$eopct		; setup	end-of-program counter
		clr	$times			; initialize number of iterations
		clr	$escape			; clear	the escape on error address
		movb	#1, $ermax		; allow	one error per test
; initialize the T-bit trap vector. then load location "$rtrn",	in
; the "end-of-pass" ($eop) routine. with a "rti" or "rtf".
		mov	#$rtrn,	@#tbitvec	; set T-bit vector to $rtrn
		mov	#340, @#tbitvec+2	; level	7
		mov	#rti, $rtrn		; set $rtrn to a rti
		mov	#65$, @#resvec		; try to do a rtt
		clr	-(SP)			; dummy	PS
		mov	#64$, -(SP)		; and PC
		rtt				; try the rtt
64$:		mov	#rtt, $rtrn		; rtt is legal - set $rtrn to a	rtt
		br	66$
65$:		add	#10, SP			; rtt illegal -	clean off the stack
66$:		mov	#resvec+2, @#resvec	; restore trap catcher
		clr	$tbit			; clear	T-bit switch
		mov	#., $lpadr		; initialize the loop address for scope
		mov	#., $lperr		; setup	the error loop address
; size for a hardware switch register. If not found or it is
; equal	to a "-1", setup for a software	switch register.
		mov	@#errvec, -(SP)		; save error vector
		mov	#67$, @#errvec		; set up error vector
		mov	#dswr, swr		; setup	for a hardware swich register
		mov	#ddisp,	display		; and a	hardware display register
		cmp	#-1, @swr		; try to reference hardware swr
		bne	69$			; branch if no timeout trap occurred
						; and the hardware swr is not=-1
		br	68$			; branch if no timeout
67$:		mov	#68$, (SP)		; set up for trap return
		rti
68$:		mov	#swreg,	swr		; point	to software swr
		mov	#dispreg, display
69$:		mov	(SP)+, @#errvec		; restore error	vector

		clr	$pass			; clear	pass count
		bitb	#aptsize, $envm		; test user size under apt
		beq	70$			; yes, use non-apt switch
		mov	#$swreg, swr		; no, use apt switch register
70$:

		.sbttl "TYPE PROGRAM NAME"

	; type the name	of the program if first	pass
		inc	#-1			; first	time?
		bne	71$			; branch if no
		cmp	#$endad, @#42		; ACT-11?
		beq	71$			; branch if yes
		type	, 72$			; type asciz string

		.sbttl "GET VALUE FOR SOFTWARE SWITCH REGISTER"

		tst	@#42			; are we running under XXDP/ACT?
		bne	73$			; branch if yes
		cmpb	$env, #1		; are we running under APT?
		beq	73$			; branch if yes
		cmp	swr, #swreg		; software switch reg selected?
		bne	74$			; branch if no
		gtswr				; get soft-swr settings
		br	74$
73$:		movb	#1, $autob		; set auto-mode	indicator
74$:
		br	71$			; get over the asciz
72$:		.asciz	<CRLF>/CJKDCB, KEF11-A FP DIAGNOSTIC PART 1/<CRLF>
		.even				;
71$:						;

loop:
		mov	#stack,	SP		; set ip stack pointer
		mov	#1$, @#4		; set up for timeout if	no multi-tester
		mov	#340, @#6
		mov	#2, @#164000		; set "go" on muiti-testep
		mov	#6, @#4			; restore trap catcher
		clr	@#6
1$:
;_____________________________________________________________________________
;
; TEST 1 - ldfps, steps	and data paths test
; This is a test of the	ldfps (load floating point status) and stfps
; (store floating point	status)	instructions. A	count pattern is generated
; and run through the floating point status register.
; dm0 and sm0 are used.
; Note that a mask must	be used	because	some of	the fps	bits cannot
; be set.
;
tst1:		scope
		lperr				; set up the loop on error address.
		mov	#-1, R0			; initialize the count pattern.
		mov	#aerr1,	@#fpvect	; set up for unable to decode
		mov	#aerr2,	@#10		; FPP instruction trap to 244 or 10.
		mov	#aerr3,	@#errvect	; if either instruction
						; fails	to go through the
						; correct src or dst mode an
						; odd address trap will	occur.
a1:
a11:		mov	R0, R4
		bic	#30020,	R4
		ldfps	R4			; test instruction.
		mov	#-1, R1
a12:		stfps	R1			; test instruction.
		mov	#fpspur, @#fpvect	; set up for unexpected	traps.
		mov	R0, R4			; mask off unsettable bits.
		bic	#30020,	R4
		mov	#cpspur, @#errvect
		mov	#cptwo,	@#10
		cmp	R4, R1			; compare data expected	with
						; the data read.
		beq	a2			; if not equal go report error.
		emt	+4
a2:		mov	#1, R0			; next pattern will be all zero
		sob	R0, a1			; decrement count pattern
		br	adone			; until	it is zero.

; unable to decode FPP instruction. trapped to 244.
aerr1:		mov	(SP), @#$tmp2		; save PC of trap.
		cmp	(SP)+, (SP)+
1$:		emt	+4
		br	adone

; unable to decode instruction.	trapped	to 10.
aerr2:		cmp	(SP), #a11+2		; did trap occur of FPP	instruction?
		beq	1$
		cmp	(SP), #a12+2
		beq	1$
		jmp	@#cptwo			; if not FPP instruction tncn
						; report spurious trap to 10.
1$:		mov	(SP), @#$tmp2		; otherwise report ir decode error.
		cmp	(SP)+, (SP)+
2$:		emt	+4
		br	adone

; trap to 4 handler:
aerr3:		cmp	(SP), #a11+2		; did the trap occur on	the
		beq	1$			; ldfps	instruction?
		cmp	(SP), #a12+2		; or the stfps instruction?
		beq	2$
		jmp	@#cpspur		; if neither then report
						; unexpected trap to 4.
1$:		mov	(SP), @#$tmp2
		cmp	(SP)+, (SP)+
15$:		emt	+4
		br	adone
2$:		mov	(SP), @#$tmp2
		cmp	(SP)+, (SP)+
25$:		emt	+4
adone:
		rsetup				; Go initialize	the fps	and stack; and
						; see if the user has expressed
						; the desire to	change the software
						; virtual console switch register (has
						; the user typed Control-G?).
;_____________________________________________________________________________
;
; TEST 2 - cfcc	test
; This is a test of the	copy condition codes instruction, cfcc.
;
tst2:		scope
		lperr				; set up the loop on error address.
		mov	#17, R0			; R0 contains to test pattern.
b1:
		ldfps	R0			; load the test	pattern
b2:
		cfcc				; copy condition codes.
		mov	@#ps, R3		; see if pattern transfered.
		bic	#177760, R3
		cmp	R0, R3
		bne	berr
b3:		sob	R0, b1
		br	bdone

berr:
		stfps	R1			; was fps modified by cfcc?
		mov	#b2, @#$tmp2
		cmp	R0, R1
		bne	berr1
		mov	R3, @#$tmp3
		mov	R0, @#$tmp4
1$:		emt	+1
		br	b3

berr1:
		mov	R0, @#$tmp3
		mov	R1, @#$tmp4
1$:		emt	+1
		br	b3
bdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 3 - setf, setd. seti and	setl test
; This is a test of the	setf. setd, seti and setl instructions.
; Each instruction is executed with the	fps containing
; all ones and also with the fps clear.	The result of each
; situation is checked.
; $temp2 contains instruction tried to perform
; $bddat contains bad fps contain.
;
tst3:		scope
		lperr				; set up the loop on error address.
		mov	#760, @#$tmp5
c1:		mov	#202, @#$tmp7
		clr	R0
		ldfps	R0			; clear	the fps.
		mov	#c15, @#$tmp2
c15:		setf				; test instruction.
		stfps	R1			; get result.
		clr	R2
		cmp	R2, R1			; did an error occur?
		beq	1$
		mov	R1, @#$bddat		; store	bad data
		emt	+1
1$:
		lperr				; set up the loop on error address.
c2:		mov	#147757, R0
		ldfps	R0			; put 147757 is	fps
		mov	#c25, @#$tmp2
c25:		setf				; clear	fd bit.
		stfps	R1			; get result
		mov	#147557, R2
		cmp	R1, R2			; result correct.
		beq	1$
		mov	R1, @#$bddat		; store	bad data
		emt	+1
1$:
		lperr				; set up the loop on error address.
c3:		mov	#203, @#$tmp7
		mov	#147757, R0
		ldfps	R0			; load 147757 into fps.
		mov	#c35, @#$tmp2
c35:		setd				; setd fd bit.
		stfps	R1
		mov	#147757, R2
		cmp	R1, R2			; result correct?
		beq	1$
		mov	R1, @#$bddat		; store	bad data
		emt	+1
1$:
		lperr				; set up the loop on error address.
c4:		clr	R0
		ldfps	R0			; clear	fps.
		mov	#c45, @#$tmp2
c45:		setd				; set fd bit.
		stfps	R1			; get result.
		mov	#200, R2
		cmp	R1, R2			; result correct?
		beq	1$
		mov	R1, @#$bddat		; store	bad data
		emt	+1
1$:
		lperr				; set up the loop on error address.
c5:		mov	#204, @#$tmp7
		clr	R0
		ldfps	R0			; clear	fps
		mov	#c55, @#$tmp2
c55:		seti				; clear	fl bit.
		stfps	R1			; get result.
		clr	R2
		cmp	R2, R1			; result correct?
		beq	1$
		mov	R1, @#$bddat		; store	bad data
		emt	+1
1$:
		lperr				; set up the loop on error address.
c6:		mov	#147757, R0
		ldfps	R0			; put 147757 into fps
		mov	#c65, @#$tmp2
c65:		seti				; clear	fl bit.
		stfps	R1			; get the result.
		mov	#147657, R2
		cmp	R1, R2			; result correct?
		beq	1$
		mov	R1, @#$bddat		; store	bad data
		emt	+1
1$:
		lperr				; set up the loop on error address.
c7:		mov	#205, @#$tmp7
		mov	#147757, R0
		ldfps	R0			; set fps to 147757.
		mov	#c75, @#$tmp2
c75:		setl				; set fl bit.
		stfps	R1			; get the result.
		mov	#147757, R2
		cmp	R1, R2			; result correct?
		beq	1$
		mov	R1, @#$bddat		; store	bad data
		emt	+1
1$:
		lperr				; set up the loop on error address.
c8:		clr	R0
		ldfps	R0			; clear	fps.
		mov	#c85, @#$tmp2
c85:		setl				; set fl bit.
		stfps	R1
		mov	#100, R2
		cmp	R1, R2			; result correct.
		beq	1$
		mov	R1, @#$bddat		; store	bad data
		emt	+1
1$:
cdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 4 - illegal FPP op codes	and stst test
; This is a test of the	FPP operation codes:
;		170003
;		170004
;		170010
;		170013
;		170014
;		170077
; these	are illegal instructions and (with interrupts enabled)
; should cause a trap to 244.
; Also tested here is the instruction:
;		stst R1
; which	should put the fec code	2 in R1, after any of the above
; op codes is executed.
;
tst4:		scope
		lperr				; set up the loop on error address.
		mov	#170003, R5		; initial op code.
		mov	#derr2,	@#errvect
		mov	#derr1,	@#fpvect
d1:		clr	R0
		ldfps	R0			; clear	fps.
		clr	R2
		mov	R5, @#d2		; set up the illegal instruction.
		mov	R5, @#$tmp5
		mov	#d2, @#$tmp2
d2:		.word	0
d3:		cfcc
		inc	R2
d4:		inc	R2
		stfps	R1			; report failure. did not trap.
		mov	R1, @#$tmp3
1$:		emt	+1
d5:		cmp	#170010, R5		; compute next op code
		bne	d6
		mov	#170013, R5
		br	d1
d6:		cmp	#170077, R5
		bne	d7
		br	ddone
d7:		inc	R5
		br	d1

derr1:		cmp	#d3, (SP)		; did trap occur on test instruction?
		beq	1$
		jmp	@#fpspur
1$:		cmp	(SP)+, (SP)+
		stfps	R1			; get the fps and see if it is
		cmp	#100000, R1		; set correctly.
		beq	3$
		mov	#100000, @#$tmp3
		mov	R1, @#$tmp4
2$:		emt	+1
3$:		mov	#1, R4
d8:		stst	R4			; get the fec code. note that
						; if the destination mode is
						; improperly decoded an	odd
						; address trap to 4 should occur.
		cmp	#2, R4			; was fec correct?
		bne	d9
		br	d5
d9:						; report stst failure
		mov	#d8, @#$tmp3
		mov	R4, @#$tmp4
1$:		emt	+1
		br	d5

derr2:		cmp	#d8+2, (SP)		; did the trap occur on	the
		beq	d10			; stst instruction?
		jmp	@#cpspur
d10:
		mov	(SP), @#$tmp2
		cmp	(SP)+, (SP)+
1$:		emt	+1
		br	d5
ddone:
		rsetup
;_____________________________________________________________________________
;
; TEST 5 - fid,	interrupt disable, bit test
; This is a test of fps	bit 14 (fid) or	floating interrupt disable.
; an illegal instruction is executed with fid=1. No interrupt should
; occur.
;
tst5:		scope
		lperr				; set up the loop on error address.
		mov	#eerr2,	@#fpvect	; setup	for the	interrupt.
e1:		mov	#40000,	R0
		ldfps	R0			; set fid.
		mov	#e3, @#$tmp2
e2:
e3:		.word	170020			; illegal FPP instruction.
e4:		cfcc
		stfps	R1			; see if error was detected.
		cmp	#140000, R1
		bne	eerr0
		stst	R4			; see if fec=2
		cmp	#2, R4
		bne	eerr1
		br	edone
eerr0:						; report fps incorrectly set.
		mov	R1, @#$tmp3
		mov	#140000, @#$tmp4
1$:		emt	+1
		br	edone
eerr1:						; report fec not 2.
		mov	R5, @#$tmp3
		mov	R4, @#$tmp4
1$:		emt	+1
		br	edone
eerr2:		cmp	(SP), #e4		; did the illegal instruction trap?
		beq	1$
		jmp	@#fpspur
1$:
		mov	(SP), @#$tmp2
		cmp	(SP)+, (SP)+
		stfps	R1
		mov	R1, @#$tmp3
2$:		emt	+1
edone:
		rsetup
;_____________________________________________________________________________
;
; TEST 6 - ldd and std,	with src and dst mode 1, test
; This is a test of both the instruction:
;		ldd	(R0), ac0
; and the instruction:
;		std	ac0, (R0)
; Most of the failures are isolated to the src or dst flows. Note
; that the integrity of	ac0 has	not been assured. This means that
; in some cases	it will	be impossible to isolate certain data pattern
; failures to either the flows or this accumulator.
;
tst6:		scope
f1:
		lperr				; set up the loop on error address.
		mov	#f3, @#$tmp2
		clr	R0
		ldfps	R0
		setd
		mov	#fdat10, R1		; set up the load data.
		mov	#fxdat0, R2
		mov	#10, R3
f2:		mov	(R2)+, (R1)+
		sob	R3, f2
		mov	#fdat14, R0		; setup	R0 for the ldd (R0), ac0.
		mov	#ferr20, @#errvect	; if the src flows fail	then
						; an odd address may occur.
		clr	R3
f3:		ldd	(R0), ac0
f4:		inc	R3
		inc	R3
		cmp	R0, #fdat14		; was R0 affected?
		beq	f5
		jmp	@#ferr1
f5:		cmp	R3, #2			; see if the PC	was adversely
		beq	1$			; affected during the instruction.
		jmp	@#ferr2
1$:		mov	#fdat10, R1		; make sure the	source data was
		mov	#fxdat0, R2		; not affected.
		mov	#10, R3
2$:		cmp	(R1)+, (R2)+
		beq	3$
		jmp	@#ferr0
3$:		sob	R3, 2$
		stfps	R1			; make sure the	fps is correct.
		cmp	#200, R1
		beq	f6
		jmp	@#ferr11
f6:
		lperr				; set up the loop on error address.
		mov	#f10, @#$tmp2
		mov	#-1, R3
		mov	#10, R4
		mov	#fdat00, R5		; set up the output data buffer.
f7:		mov	R3, (R5)+
		sob	R4, f7
		mov	#fdat04, R0		; set up R0 for	dst mode 1 reg 0.
		mov	#ferr25, @#errvect	; if the dst flows fail	an odd
						; address could	occur.
		clr	R3
f10:		std	ac0, (R0)		; test instruction.
f11:		inc	R3
		inc	R3
		cmp	R0, #fdat04		; was R0 modified?
		beq	f12
		jmp	@#ferr3
f12:		cmp	R3, #2			; was the PC affected correctly?
		beq	f135
		jmp	ferr4
f135:		mov	#fdat00, R1
		mov	#fxdat0, R2
		cmp	(R1)+, (R2)+		; see if the data was output
		beq	f13			; to the target	area correctly.
		jmp	@#ferr5
f13:		cmp	(R1)+, (R2)+
		beq	f14
		jmp	@#ferr5
f14:		cmp	(R1)+, (R2)+
		beq	f15
		jmp	@#ferr5
f15:		cmp	(R1)+, (R2)+
		beq	f16
		jmp	@#ferr5
f16:		cmp	(R1)+, (R2)+
		beq	f17
		jmp	@#ferr10
f17:		cmp	(R1)+, (R2)+
		beq	f20
		jmp	@#ferr6
f20:		cmp	(R1)+, (R2)+
		beq	f21
		jmp	ferr7
f21:		cmp	(R1)+, (R2)+
		beq	f22
		jmp	@#ferr10
f22:		clr	R1
		stfps	R1			; make sure fps	is correct.
		cmp	#200, R1
		beq	f23
		jmp	@#ferr11
f23:		jmp	@#fdone

ferr0:						; source data affected by
		mov	#fxdat0, @#$tmp3	; the ldd instruction.
		mov	#fxdat0+12, @#$tmp4
		mov	#fdat10, @#$tmp5
		mov	#fdat10+12, @#$tmp6
1$:		emt	+1
		jmp	@#fdone

ferr1:		mov	#fdat14, @#$tmp4	; fsrc flows failure.
		mov	R0, @#$tmp3
		mov	#762, @#$tmp5
		mov	#321, @#$tmp7
		cmp	#fdat10, R0		; fsrc mode 4?
		bne	1$
		mov	#324, @#$tmp6
		br	4$
1$:		cmp	#fdat14+10, R0		; fsrc modf 2?
		bne	2$
		mov	#322, @#$tmp6
		br	4$
2$:
3$:
		emt	+1			; R0 was modi fed, ldd
		jmp	@#fdone
4$:
5$:
		emt	+1			; R0 was modifed, ldd
		jmp	@#fdone

ferr2:		mov	#f4, R1			; the PC was incorrectly affected
						; during the instruction.
fer2:		mov	R1, @#$tmp4
		sub	#4, R1
		asl	R3
		add	R3, R1
		mov	R1, @#$tmp3
1$:		emt	+1
		jmp	@#fdone

ferr4:		mov	#f11, R1
		br	fer2

ferr3:		mov	#fdat04, @#$tmp4	; failure in the fdst flows.
		mov	R0, @#$tmp3
		mov	#527, @#$tmp5
		mov	#641, @#$tmp7
		cmp	#fdat00, R0		; dst mode 4?
		bne	1$
		mov	#644, @#$tmp6
		br	4$
1$:		cmp	#fdat04+10, R0		; dst mode 2?
		bne	2$
		mov	#642, @#$tmp6
		br	4$
2$:
3$:		emt	+1			; R0 was modified. std
		jmp	@#fdone
4$:
5$:		emt	+1			; R0 was modified. std
		jmp	@#fdone

ferr5:						; failure of std.
		mov	R0, @#$tmp3
		mov	#fdat00, @#$tmp4
		mov	#fdat07, @#$tmp5
		mov	#fxdat0, @#$tmp6
1$:		emt	+3			; output bad, std
		jmp	@#fdone

ferr6:		mov	#fdat05, R1		; did (but gr7)	fail in	the fdst
		mov	#-1, R2			; flows?
		mov	#3, R3
1$:		cmp	R2, (R1)+
		bne	5$
		sob	R3, 1$
						; report failure of (but gr7) in
		mov	R0, @#$tmp3		; the fdst flows.
		mov	#412, @#$tmp5
		mov	#147, @#$tmp6
		mov	#145, @#$tmp7
2$:		emt	+1
		jmp	@#fdone
5$:		mov	#fdat05, R1		; did (but gr7)	fail in	the src	flows?
		mov	#3, R3
6$:		tst	(R1)+
		beq	7$
		jmp	@#ferr10
7$:		sob	R3, 6$
						; report failime of (but gr7) in
		mov	R0, @#$tmp3		; the fsrc flows.
		mov	#207, @#$tmp5
		mov	#176, @#$tmp6
		mov	#174, @#$tmp7
10$:		emt	+1
		jmp	@#fdone

ferr7:		mov	#fdat06, R1		; did (but fd) fail in the fdst	flows?
		mov	#-1, R2
		mov	#2, R3
1$:		cmp	R2, (R1)+
		bne	5$
		sob	R3, 1$
						; report failure of (but fd) in	the
		mov	R0, @#$tmp3		; fdst flows.
		mov	#707, @#$tmp5
		mov	#244, @#$tmp6
		mov	#245, @#$tmp7
2$:		emt	+1
		jmp	@#fdone
5$:		mov	#fdat06, R1		; did (but fd) fail in the fsrc	flows?
		mov	#2, R3
6$:		tst	(R1)+
		beq	7$
		jmp	@#ferr10
7$:		sob	R3, 6$
						; report failure of (but fd) in	the
		mov	R0, @#$tmp3		; fsrc flows.
		mov	#441, @#$tmp5
		mov	#76, @#$tmp6
		mov	#77, @#$tmp7
10$:		emt	+3			; bad data
		jmp	@#fdone

ferr10:						; report data error.
		mov	R0, @#$tmp3
		mov	#fdat04, @#$tmp4
		mov	#fdat07, @#$tmp5
		mov	#fxdat4, @#$tmp6
1$:		emt	+1
		jmp	@#fdone

ferr11:						; report bad fps.
		mov	R1, @#$tmp3
		mov	#200, @#$tmp4
1$:		emt	+1
		jmp	@#fdone

ferr20:		mov	#null, @#$tmp15		; the execution	of the ldd
		clr	@#$tmp10		; caused a trap	to 4, because
		mov	(SP), @#$tmp2		; a fsrc flow failure resulted
		mov	#fdat14, @#$tmp3	; in an	odd address.
		mov	#321, @#$tmp7
		mov	#762, @#$tmp5
		cmp	(SP), #f4+2		; see if fsrc mode 6 or	7 was
		beq	ferr21			; executed.
		cmp	R0, #fdat13		; fsrc mode 5?
		bne	2$
						; report fsrc flow failure to
		mov	#325, @#$tmp6		; mode 5.
		cmp	(SP)+, (SP)+
1$:		emt	+1
		br	fdone
2$:		cmp	R0, #fdat15		; fsrc mode 3?
		beq	3$
		jmp	@#cpspur
3$:						; report fsrc flow failure to
		mov	#323, @#$tmp6		; mode 3.
		cmp	(SP)+, (SP)+
4$:		emt	+1
		br	fdone

ferr21:		cmp	(SP)+, (SP)+		; report fsrc flow failure to
						; mode 6 or mode 7.
		mov	#326, @#$tmp6
		mov	#327, @#$tmp10
1$:		emt	+1
		br	fdone

ferr25:		mov	#null, @#$tmp15		; the execution	of the std instruction
		clr	@#$tmp10		; trapped to 4,	because	a failure
		mov	#fdat04, @#$tmp3		; in the fdst flows resulted
		mov	(SP), @#$tmp2		; in an	odd address.
		mov	#527, @#$tmp5
		mov	#641, @#$tmp7
		cmp	(SP), #f10+2		; flow failure to fdst mode 6 or 7?
		beq	ferr26
		cmp	R0, #fdat03		; did fdst flow	fail to	mode 5?
		bne	2$
						; report flow failure to fdst
		mov	#645, @#$tmp6		; mode 5.
		cmp	(SP)+, (SP)+
1$:		emt	+1
		br	fdone
2$:		cmp	R0, #fdat05		; did fdst flow	fail to	mode 3?
		beq	3$
		jmp	@#cpspur
3$:						; report fdst flow failed to mode 3.
		mov	#643, @#$tmp6
		cmp	(SP)+, (SP)+
4$:		emt	+1
		br	fdone

ferr26:						; report fdst flow failure to mode
		mov	#646, @#$tmp6
		mov	#647, @#$tmp10
		cmp	(SP)+, (SP)+
1$:		emt	+1
		br	fdone

fdat10:		-1
fdat11:		-1
fdat12:		-1
fdat13:		-1
fdat14:		-1
fdat15:		-1
fdat16:		-1
fdat17:		-1
		-1
fdat00:		-1
fdat01:		-1
fdat02:		-1
fdat03:		-1
fdat04:		-1
fdat05:		-1
fdat06:		-1
fdat07:		-1
		-1
fxdat0:		-1
fxdat1:		-1
fxdat2:		-1
fxdat3:		-1
fxdat4:		052525
fxdat5:		031463
fxdat6:		007417
fxdat7:		000477
fdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 7 - fsrc	mode 0 test
; This is a test of fsrc mode zero using the ldd and ldf instructions.
;
tst7:		scope
		lperr				; set up the loop on error address.
i1:
		setd				; set fd.
		mov	#idat10, R0
		mov	#ipat10, R1
		mov	#4, R2
i2:		mov	(R1)+, (R0)+		; set up the input data	buffer.
		sob	R2, i2
		mov	#idat10, R0		; load ac1
		ldd	(R0), ac1
		mov	#ipat20, R0		; load ac0
		ldd	(R0), ac0
		mov	#1, R1			; in case the fsrc flows fail
		mov	#ierr0,	@#errvect	; an odd address trap to 4 may occur.
		mov	#i3, @#$tmp2
i3:		ldd	ac1, ac0		; test instruction.
i4:		nop
i5:		nop
		mov	#idat00, R0
		std	ac0, (R0)		; get ac0. the results.
		mov	#idat00, R0		; see if data is correct.
		mov	#idat10, R1
		mov	#4, R2
i6:		cmp	(R0)+, (R1)+
		beq	i105
		mov	#idat02, R0		; see if (but fd) failed.
		mov	#2, R2
i7:		tst	(R0)+
		beq	i10
		mov	#idat02, R0
		mov	#2, R2
1$:		cmp	#-1, (R0)+
		beq	2$
		jmp	@#ierr1
2$:		sob	R2, 1$
		br	i106
i10:		sob	R2, i7
i106:		jmp	@#ierr2
i105:		sob	R2, i6
; now test the load instruction	with fsrc mode zero and	fd clear.
i11:
		lperr				; set up the loop on error address.
i12:		mov	#ipat10, R0
		mov	#idat10, R1
		mov	#4, R2
i13:		mov	(R0)+, (R1)+
		sob	R2, i13
		mov	#idat10, R0		; set up ac1
		ldd	(R0), ac1
		mov	#ipat20, R0		; set up ac0
		ldd	(R0), ac0
		mov	#1, R1
		mov	#i14, @#$tmp2
		setf				; clear	fd.
i14:		ldf	ac1, ac0		; test instruction.
i15:		nop
i16:		nop
		stfps	R0			; see if fps is	still clear.
		cmp	#4, R0
		beq	i17
		jmp	@#ierr3
i17:						; reset	to double mode.
		setd
		mov	#idat00, R0
		std	ac0, (R0)		; get ac0
		mov	#-1, @#idat12
		mov	#-1, @#idat13
		mov	#idat00, R0
		mov	#idat10, R1
		mov	#4, R2
i20:		cmp	(R0)+, (R1)+		; see if ac0 was correct.
		beq	i23
		cmp	@#idat02, @#ipat12	; did (but fd) fail?
		beq	i22
i21:		jmp	@#ierr1
i22:		cmp	@#idat03, @#ipat13
		bne	i21
		jmp	@#ierr4
i23:		sob	R2, i20
		br	idone			; no errors.

; if an	odd address trap occurs	come here to analyse the fsrc failure.
ierr0:		cmp	#i4, (SP)		; make sure the	trap occurred
		beq	1$			; on the instruction being tested.
		cmp	#i5, (SP)
		beq	1$
		cmp	#i15, (SP)
		beq	1$
		cmp	#i16, (SP)
		beq	1$
		jmp	@#cpspur
1$:		mov	(SP), @#$tmp2		; report failure.
		mov	#627, @#$tmp3
		mov	#320, @#$tmp4
		cmp	(SP)+, (SP)+
2$:		emt	+1
		br	idone

; report data error.
ierr1:
		mov	#idat10, @#$tmp4
		mov	#idat00, @#$tmp5
1$:		emt	+4
		br	idone

; report failure of (but fd)
ierr2:		mov	#153, @#$tmp5
		mov	#434, @#$tmp6
		mov	#435, @#$tmp7
ierr25:
1$:		emt	+1
		br	idone
ierr4:		mov	#153, @#$tmp5
		mov	#435, @#$tmp6
		mov	#434, @#$tmp7
		br	ierr25

; report incorrect fps after load instruction.
ierr3:
		mov	#i14, @#$tmp2
		mov	R0, @#$tmp3
		mov	#4, @#$tmp4
1$:		emt	+1
		br	idone

ipat10:		0
ipat11:		170360
ipat12:		016161
ipat13:		052525
ipat20:		-1
ipat21:		-1
ipat22:		-1
ipat23:		-1
idat00:		0
idat01:		0
idat02:		0
idat03:		0
idat10:		0
idat11:		0
idat12:		0
idat13:		0
idone:
		rsetup
;_____________________________________________________________________________
;
; TEST 10 - fdst mode 0	test
; This is a test of the	store instructions. std	and stf, with fdst mode	0.
;
tst10:		scope
t1:
		lperr				; set up the loop on error address.
		setd				; set fd
		mov	#tpat10, R0
		mov	#tdat10, R1
		mov	#4, R2
t2:		mov	(R0)+, (R1)+		; set up the input data	buffer.
		sob	R2, t2
		mov	#tdat10, R0		; load ac0
		ldd	(R0), ac0
		mov	#tpat20, R0		; load ac1
		ldd	(R0), ac1
		mov	#1, R1			; if the (but fdst) fork fails
		mov	#terr0,	@#errvect	; an odd address trap could result.
		mov	#t3, @#$tmp2
t3:		std	ac0, ac1
t4:		nop
t5:		nop
		mov	#tdat00, R0
		std	ac1, (R0)		; get the data.
		mov	#tdat00, R3		; see if the data is correct.
		mov	#tdat10, R4
		mov	#4, R5
t6:		cmp	(R3)+, (R4)+
		beq	t105
		mov	#tdat02, R3		; did (but fd) fail?
		mov	#2, R5
t7:		tst	(R3)+
		beq	t10
		jmp	@#terr1
t10:		sob	R5, t7
		jmp	@#terr2
t105:		sob	R5, t6

; now test the stf ac0,	ac1 instruction.
t11:
		lperr				; set up the loop on error address.
t12:		mov	#tpat10, R0		; set up the input data	buffer.
		mov	#tdat10, R1
		mov	#4, R2
t13:		mov	(R0)+, (R1)+
		sob	R2, t13
		mov	#tdat10, R0		; set up ac0
		ldd	(R0), ac0
		mov	#tpat20, R0		; set up ac1
		ldd	(R0), ac1
		mov	#1, R1
		mov	#t14, @#$tmp2
		setf				; clear	fd
t14:		stf	ac0, ac1
t15:		nop
t16:		nop
		clr	R0
		stfps	R0			; see if fps is	clear.
		cmp	#10, R0
		beq	t17
		br	terr3
t17:
		setd				; set fd.
		mov	#tdat00, R0
		std	ac1, (R0)		; pick up ac1.
		mov	#-1, @#tdat12
		mov	#-1, @#tdat13
		mov	#tdat00, R3
		mov	#tdat10, R4
		mov	#4, R5
t20:		cmp	(R3)+, (R4)+		; was the data transferred correctly?
		beq	t23
		cmp	@#tdat02, @#tpat12	; did (but fd) fail.
		beq	t22
t21:		br	terr1
t22:		cmp	@#tdat03, @#tpat13
		bne	t21
		br	terr4
t23:		sob	R5, t20
		br	tdone

; trap here through vector 4 if	an odd address occurs.
terr0:		cmp	#t4, (SP)		; make sure the	trap was on
		beq	1$			; an instruction being tested.
		cmp	#t5, (SP)
		beq	1$
		cmp	#t15, (SP)
		beq	1$
		cmp	#t16, (SP)
		beq	1$
		jmp	@#cpspur
1$:		mov	(SP), @#$tmp2
		cmp	(SP)+, (SP)+
		mov	#527, @#$tmp3
		mov	#640, @#$tmp4
2$:		emt	+1
		br	tdone

; report data failure.
terr1:
		mov	#tdat10, @#$tmp4
		mov	#tdat00, @#$tmp5
1$:		emt	+1
		br	tdone

; report failure of (but fd).
terr2:		mov	#160, @#$tmp6
		mov	#161, @#$tmp7
terr25:		mov	#640, @#$tmp5
1$:		emt	+12
		br	tdone
terr4:		mov	#161, @#$tmp6
		mov	#160, @#$tmp7
		br	terr25

; report incorrect fps after store instruction.
terr3:
		mov	#t15, @#$tmp2
		mov	R0, @#$tmp3
		mov	#10, @#$tmp4
1$:		emt	+1
		br	tdone

tpat10:		0
tpat11:		170360
tpat12:		016161
tpat13:		052525
tpat20:		-1
tpat21:		-1
tpat22:		-1
tpat23:		-1
tdat00:		0
tdat01:		0
tdat02:		0
tdat03:		0
tdat10:		0
tdat11:		0
tdat12:		0
tdat13:		0
tdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 11 - accumulators data patterns test
; This is a test of the	floating point processor accumulators.
; Each accumulator is tested in	two ways:
; 1. Test pattern generated by floating	a one across
; a field of zeroes.
; 2. Test pattern generated by floating	a zero across
; a field of ones.
; Each of accumulators ac0 through ac5 is tested.
;
tst11:		scope
		setd				; set fd.
; test accumulator 0 with floating one
		mov	#g1, @#$tmp2
		mov	#gpat00, R0
		mov	#gdat00, R1
		lperr				; set up the loop on error address.
		jsr	pc, @#gsetup		; load test pattern.
		mov	#102, R3
g1:
		ldd	(R0), ac0
		std	ac0, ac0
		ldd	ac0, ac0		; store	the test pattern.
		std	ac0, (R1)
		jsr	pc, @#gcmp		; compare the data read	with
						; that which was written.
		tst	@#gflag1
		bne	g2
		com	@#gflag1
		sec
		br	g3
g2:		clc
g3:		rol	6(R0)			; generate the next test pattern.
		rol	4(R0)
		rol	2(R0)
		rol	(R0)
		jsr	pc, @#greset		; reset	default	pattern	in output
						; buffer.
		sob	R3, g1

; test accumulator 0 with floating zero
		mov	#g4, @#$tmp2
		mov	#gpat10, R0
		mov	#gdat00, R1
		lperr				; set up the loop on error address.
		jsr	pc, @#gsetup		; load test pattern.
		mov	#102, R3
g4:
		ldd	(R0), ac0
		std	ac0, ac0
		ldd	ac0, ac0		; store	the test pattern.
		std	ac0, (R1)
		jsr	pc, @#gcmp		; compare the data read	with
						; that which was written.
		tst	@#gflag1
		bne	g5
		com	@#gflag1
		clc
		br	g6
g5:		sec
g6:		rol	6(R0)			; generate the next test pattern.
		rol	4(R0)
		rol	2(R0)
		rol	(R0)
		jsr	pc, @#greset		; reset	default	pattern	in output
						; buffer.
		sob	R3, g4

; test accumulator 1 with floating one
		mov	#g7, @#$tmp2
		mov	#gpat00, R0
		mov	#gdat00, R1
		lperr				; set up the loop on error address.
		jsr	pc, @#gsetup		; load test pattern.
		mov	#102, R3
g7:
		ldd	(R0), ac0
		std	ac0, ac1
		ldd	ac1, ac0		; store	the test pattern.
		std	ac0, (R1)
		jsr	pc, @#gcmp		; compare the data read	with
						; that which was written.
		tst	@#gflag1
		bne	g10
		com	@#gflag1
		sec
		br	g11
g10:		clc
g11:		rol	6(R0)			; generate the next test pattern.
		rol	4(R0)
		rol	2(R0)
		rol	(R0)
		jsr	pc, @#greset		; reset	default	pattern	in output
						; buffer.
		sob	R3, g7

; test accumulator 1 with floating zero
		mov	#g12, @#$tmp2
		mov	#gpat10, R0
		mov	#gdat00, R1
		lperr				; set up the loop on error address.
		jsr	pc, @#gsetup		; load test pattern.
		mov	#102, R3
g12:
		ldd	(R0), ac0
		std	ac0, ac1
		ldd	ac1, ac0		; store	the test pattern.
		std	ac0, (R1)
		jsr	pc, @#gcmp		; compare the data read	with
						; that which was written.
		tst	@#gflag1
		bne	g13
		com	@#gflag1
		clc
		br	g14
g13:		sec
g14:		rol	6(R0)			; generate the next test pattern.
		rol	4(R0)
		rol	2(R0)
		rol	(R0)
		jsr	pc, @#greset		; reset	default	pattern	in output
						; buffer.
		sob	R3, g12

; test accumulator 2 with floating one
		mov	#g15, @#$tmp2
		mov	#gpat00, R0
		mov	#gdat00, R1
		lperr				; set up the loop on error address.
		jsr	pc, @#gsetup		; load test pattern.
		mov	#102, R3
g15:
		ldd	(R0), ac0
		std	ac0, ac2
		ldd	ac2, ac0		; store	the test pattern.
		std	ac0, (R1)
		jsr	pc, @#gcmp		; compare the data read	with
						; that which was written.
		tst	@#gflag1
		bne	g16
		com	@#gflag1
		sec
		br	g17
g16:		clc
g17:		rol	6(R0)			; generate the next test pattern.
		rol	4(R0)
		rol	2(R0)
		rol	(R0)
		jsr	pc, @#greset		; reset	default	pattern	in output
						; buffer.
		sob	R3, g15

; test accumulator 2 with floating zero
		mov	#g20, @#$tmp2
		mov	#gpat10, R0
		mov	#gdat00, R1
		lperr				; set up the loop on error address.
		jsr	pc, @#gsetup		; load test pattern.
		mov	#102, R3
g20:
		ldd	(R0), ac0
		std	ac0, ac2
		ldd	ac2, ac0		; store	the test pattern.
		std	ac0, (R1)
		jsr	pc, @#gcmp		; compare the data read	with
						; that which was (mitten.
		tst	@#gflag1
		bne	g21
		com	@#gflag1
		clc
		br	g22
g21:		sec
g22:		rol	6(R0)			; generate the next test pattern.
		rol	4(R0)
		rol	2(R0)
		rol	(R0)
		jsr	pc, @#greset		; reset	default	pattern	in output
						; buffer.
		sob	R3, g20

; test accumulator 3 with floating one
		mov	#g23, @#$tmp2
		mov	#gpat00, R0
		mov	#gdat00, R1
		lperr				; set up the loop on error address.
		jsr	pc, @#gsetup		; load test pattern.
		mov	#102, R3
g23:
		ldd	(R0), ac0
		std	ac0, ac3
		ldd	ac3, ac0		; store	the test pattern.
		std	ac0, (R1)
		jsr	pc, @#gcmp		; compare the data read	with
						; that which was written.
		tst	@#gflag1
		bne	g24
		com	@#gflag1
		sec
		br	g25
g24:		clc
g25:		rol	6(R0)			; generate the next test pattern.
		rol	4(R0)
		rol	2(R0)
		rol	(R0)
		jsr	pc, @#greset		; reset	default	pattern	in output
						; buffer.
		sob	R3, g23

; test accumulator 3 with floating zero
		mov	#g26, @#$tmp2
		mov	#gpat10, R0
		mov	#gdat00, R1
		lperr				; set up the loop on error address.
		jsr	pc, @#gsetup		; load test pattern.
		mov	#102, R3
g26:
		ldd	(R0), ac0
		std	ac0, ac3
		ldd	ac3, ac0		; store	the test pattern.
		std	ac0, (R1)
		jsr	pc, @#gcmp		; compare the data read	with
						; that which was written.
		tst	@#gflag1
		bne	g27
		com	@#gflag1
		clc
		br	g30
g27:		sec
g30:		rol	6(R0)			; generate the next test pattern.
		rol	4(R0)
		rol	2(R0)
		rol	(R0)
		jsr	pc, @#greset		; reset	default	pattern	in output
						; buffer.
		sob	R3, g26

; test accumulator 4 with floating one
		mov	#g31, @#$tmp2
		mov	#gpat00, R0
		mov	#gdat00, R1
		lperr				; set up the loop on error address.
		jsr	pc, @#gsetup		; load test pattern.
		mov	#102, R3
g31:
		ldd	(R0), ac0
		std	ac0, ac4
		ldd	ac4, ac0		; store	the test pattern.
		std	ac0, (R1)
		jsr	pc, @#gcmp		; compare the data read	with
						; that which was written.
		tst	@#gflag1
		bne	g32
		com	@#gflag1
		sec
		br	g33
g32:		clc
g33:		rol	6(R0)			; generate the next test pattern.
		rol	4(R0)
		rol	2(R0)
		rol	(R0)
		jsr	pc, @#greset		; reset	default	pattern	in output
						; buffer.
		sob	R3, g31

; test accumulator 4 with floating zero
		mov	#g34, @#$tmp2
		mov	#gpat10, R0
		mov	#gdat00, R1
		lperr				; set up the loop on error address.
		jsr	pc, @#gsetup		; load test pattern.
		mov	#102, R3
g34:
		ldd	(R0), ac0
		std	ac0, ac4
		ldd	ac4, ac0		; store	the test pattern.
		std	ac0, (R1)
		jsr	pc, @#gcmp		; compare the data read	with
						; that which was written.
		tst	@#gflag1
		bne	g35
		com	@#gflag1
		clc
		br	g36
g35:		sec
g36:		rol	6(R0)			; generate the next test pattern.
		rol	4(R0)
		rol	2(R0)
		rol	(R0)
		jsr	pc, @#greset		; reset	default	pattern	in output
						; buffer.
		sob	R3, g34

; test accumulator 5 with floating one
		mov	#g37, @#$tmp2
		mov	#gpat00, R0
		mov	#gdat00, R1
		lperr				; set up the loop on error address.
		jsr	pc, @#gsetup		; load test pattern.
		mov	#102, R3
g37:
		ldd	(R0), ac0
		std	ac0, ac5
		ldd	ac5, ac0		; store	the test pattern.
		std	ac0, (R1)
		jsr	pc, @#gcmp		; compare the data read	with
						; that which was written.
		tst	@#gflag1
		bne	g40
		com	@#gflag1
		sec
		br	g41
g40:		clc
g41:		rol	6(R0)			; generate the next test pattern.
		rol	4(R0)
		rol	2(R0)
		rol	(R0)
		jsr	pc, @#greset		; reset	default	pattern	in output
						; buffer.
		sob	R3, g37

; test accumulator 5 with floating zero
		mov	#g42, @#$tmp2
		mov	#gpat10, R0
		mov	#gdat00, R1
		lperr				; set up the loop on error address.
		jsr	pc, @#gsetup		; load test pattern.
		mov	#102, R3
g42:
		ldd	(R0), ac0
		std	ac0, ac5
		ldd	ac5, ac0		; store	the test pattern.
		std	ac0, (R1)
		jsr	pc, @#gcmp		; compare the data read	with
						; that which was written.
		tst	@#gflag1
		bne	g43
		com	@#gflag1
		clc
		br	g44
g43:		sec
g44:		rol	6(R0)			; generate the next test pattern.
		rol	4(R0)
		rol	2(R0)
		rol	(R0)
		jsr	pc, @#greset		; reset	default	pattern	output
						; buffer.
		sob	R3, g42
		jmp	@#gdone

; use this routine to initialize all the data buffers.
gsetup:		mov	#gflag1, R5
		mov	#26, R4
1$:		clr	(R5)+
		sob	R4, 1$
		mov	#gpat10, R5
		mov	#10, R4
2$:		com	(R5)+
		sob	R4, 2$

gs1:		cmp	R0, gpat00
		beq	3$
		rts	pc
3$:		mov	#gdat00, R5
		mov	#4, R4
4$:		com	(R5)+
		sob	R4, 4$
		rts	pc

greset:		mov	#gdat00, R5
		mov	#4, R4
1$:		clr	(R5)+
		sob	R4, 1$
		jmp	@#gs1

; see if the data written matches the data read.
gcmp:		mov	(SP), @#$tmp5		; store	error PC
		mov	#gdat00, R5
		mov	#4, R4
		mov	R0, R2
1$:		cmp	(R2)+, (R5)+
		beq	2$
		emt	+3			; probably bad mmu, otherwise it is the	fp chip
2$:		sob	R4, 1$
		rts	pc

gflag1:		0
gflag2:		0
gpat00:		0
gpat01:		0
gpat02:		0
gpat03:		0
gpat10:		-1
gpat11:		-1
gpat12:		-1
gpat13:		-1
gand0:		-1
gand1:		-1
gand2:		-1
gand3:		-1
gor0:		0
gor1:		0
gor2:		0
gor3:		0
gdat00:		0
gdat01:		0
gdat02:		0
gdat03:		0
gdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 12 - FPP	accumulators dual address test
; This test performs a dual addressing test on the floating accumulators.
; Note that accumulator	zero is	used to	access all the others.
;
tst12:		scope
		lperr				; set up the loop on error address.

h1:		clr	@#hflag
		mov	#ha1w, R0		; initialize the load buffer data.
		mov	#hdat1,	R1
		mov	#24, R3

h2:		mov	(R1)+, (R0)+
		sob	R3, h2
		jsr	pc, hclr		; clear	the output data	buffer.

h3:		setd
; load accumulator 1
		mov	#ha1w, R0
		ldd	(R0), ac0
		std	ac0, ac1
; load accumulator 2
		mov	#ha2w, R0
		ldd	(R0), ac0
		std	ac0, ac2
; load accumulator 3
		mov	#ha3w, R0
		ldd	(R0), ac0
		std	ac0, ac3
; load accumulator 4
		mov	#ha4w, R0
		ldd	(R0), ac0
		std	ac0, ac4
; load accumulator 5
		mov	#ha5w, R0
		ldd	(R0), ac0
		std	ac0, ac5

h4:		jsr	pc, @#hstd		; go read all accumulators back.
		jsr	pc, @#hcmp		; see if data is correct.

; compliment each word of the data stored in accumulator 1,
; reload that accumulator, read	all the	accumulators back and check
; the data.
		mov	#ha1w, R0
		mov	#4, R2
		mov	R0, R1
h5:		com	(R1)+
		ldd	(R0), ac0
		std	ac0, ac1
		jsr	pc, @#hstd		; read all the accumulators back.
		jsr	pc, @#hcmp		; check	the data.
		sob	R2, h5

; compliment each word of the data stored in accumulator 2,
; reload that accumulator. read	all the	accumulators back and check
; the data.
		mov	#ha2w, R0
		mov	#4, R2
		mov	R0, R1
h6:		com	(R1)+
		ldd	(R0), ac0
		std	ac0, ac2
		jsr	pc, @#hstd		; read all the accumulators back.
		jsr	pc, @#hcmp		; check	the data.
		sob	R2, h6

; compliment each word of the data stored in accumulator 3.
; reload that accumulator, read	all 1he	accumulators back and check
; the data.
		mov	#ha3w, R0
		mov	#4, R2
		mov	R0, R1
h7:		com	(R1)+
		ldd	(R0), ac0
		std	ac0, ac3
		jsr	pc, @#hstd		; read all the accumulators back.
		jsr	pc, @#hcmp		; check	the data.
		sob	R2, h7

; compliment each word of the data stored in accumulator 4,
; reload that accumulator. read	all the	accumulators back and check
; the data.
		mov	#ha4w, R0
		mov	#4, R2
		mov	R0, R1
h10:		com	(R1)+
		ldd	(R0), ac0
		std	ac0, ac4
		jsr	pc, @#hstd		; read all the accumulators back.
		jsr	pc, @#hcmp		; check	the data.
		sob	R2, h10

; compliment each word of the data stored in accumulator 5,
; reload that accumulator, read	all the	accumulators back and check
; the data.
		mov	#ha5w, R0
		mov	#4, R2
		mov	R0, R1
h11:		com	(R1)+
		ldd	(R0), ac0
		std	ac0, ac5
		jsr	pc, @#hstd		; read all the accumulators back.
		jsr	pc, @#hcmp		; check	the data.
		sob	R2, h11
		tst	@#hflag
		beq	h12
		jmp	@#hdone

h12:		com	@#hflag
		jmp	@#h3

; store	all accumulators in the	output buffers.
hstd:		jsr	pc, @#hclr		; clear	all output buffers.
; store	accumulator 1
		mov	#ha1r, R4
		ldd	ac1, ac0
		std	ac0, (R4)
; store	accumulator 2
		mov	#ha2r, R4
		ldd	ac2, ac0
		std	ac0, (R4)
; store	accumulator 3
		mov	#ha3r, R4
		ldd	ac3, ac0
		std	ac0, (R4)
; store	accumulator 4
		mov	#ha4r, R4
		ldd	ac4, ac0
		std	ac0, (R4)
; store	accumulator 5
		mov	#ha5r, R4
		ldd	ac5, ac0
		std	ac0, (R4)
		rts	pc

; compare data loaded with data	read.
hcmp:		mov	(SP)+, @#hadr		; save return address.
		mov	#ha1w, R3
		mov	#ha1r, R4
		mov	#24, R5
hcmp1:		cmp	(R3)+, (R4)+
		beq	hcmp2
		jmp	@#herror
hcmp2:		sob	R5, hcmp1
		jmp	@hadr

; clear	the data output	buffer.
hclr:		mov	#ha1r, R4
		mov	#24, R5
hclr1:		clr	(R4)+
		sob	R5, hclr1
		rts	pc

; report error.
herror:
		mov	#ha1w, R3
		mov	#$tmp2,	R4
		mov	#12, R5
1$:		mov	R3, (R4)+
		add	#10, R3
		sob	R5, 1$
2$:		emt	+1
		jmp	@#hdone

hadr:		0
hflag:		0
ha1w:		.word	0, 0, 0, 0
ha2w:		.word	0, 0, 0, 0
ha3w:		.word	0, 0, 0, 0
ha4w:		.word	0, 0, 0, 0
ha5w:		.word	0, 0, 0, 0
ha1r:		.word	0, 0, 0, 0
ha2r:		.word	0, 0, 0, 0
ha3r:		.word	0, 0, 0, 0
ha4r:		.word	0, 0, 0, 0
ha5r:		.word	0, 0, 0, 0
hdat1:		.word	73567, 73567, 73567, 73567
hdat2:		.word	63146, 63146, 63146, 63146
hdat3:		.word	10421, 10421, 10421, 10421
hdat4:		.word	31463, 31463, 31463, 31463
hdat5:		.word	42104, 42104, 42104, 42104
hdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 13 - fsrc mode 0	with illegal accumulator test
; This is a test of fsrc mode 0	with accumulators 6 and	7. Use of
; either of these non-existent accumulators should result in a trap to 244
; with fec=2 (illegal opcode trap).
;
tst13:		scope
s1:
		lperr				; set up the loop on error address.
		setd				; set fd
		mov	#spat10, R0		; load ac0
		ldd	(R0), ac0

		mov	#serr0,	@#fpvect	; use of the non-existent ac-
						; cumulator should result in
						; a trap to 244.
		mov	#1, R0			; a failure in the fsrc	flows
						; will result in an odd	address
		mov	#serr1,	@#errvect	; trap to 4.
		clr	R3

s2:		ldd	ac7, ac0
s3:		cfcc
		inc	R3
s4:		inc	R3
		mov	#sdat00, R1		; no trap occurred!!
		std	ac0, (R1)		; see if ac0 was modified.
		mov	#sdat00, R1
		mov	#spat10, R2
		mov	#4, R3

s5:		cmp	(R1)+, (R2)+
		beq	s6
		jmp	@#serr2			; bad data
s6:		sob	R3, s5
		jmp	@#serr3			; missing trap

; now test ac6.
s7:
		lperr				; set up the loop on error address.
		setd
		mov	#spat10, R0		; load ac0
		ldd	(R0), ac0
		mov	#serr4,	@#fpvect
		mov	#1, R0
		mov	#serr5,	@#errvect
		clr	R3

s8:		ldd	ac6, ac0
s9:		cfcc
		inc	R3
s10:		inc	R3
		mov	#sdat00, R1
		std	ac0, (R1)		; no trap! get ac0.
		mov	#sdat00, R1		; was ac0 modified.
		mov	#spat10, R2
		mov	#4, R3
s11:		cmp	(R1)+, (R2)+
		beq	s12
		jmp	@#serr6
s12:		sob	R3, s11
		jmp	@#serr7

; trapped to 244.
serr0:		cmp	(SP), #s3		; PC of	trap correct?
		beq	1$
		jmp	@#fpspur
1$:		mov	#s7, @#sadr

serr10:		mov	(SP), @#$tmp2
		cmp	(SP)+, (SP)+
		clr	R4
		stfps	R4			; is fps correct?
		cmp	#100200, R4
		bne	serr15
		clr	R4
		stst	R4			; is fec correct?
		cmp	#2, R4
		bne	serr20
		jmp	@sadr

serr4:		cmp	(SP), #s9
		beq	1$
		jmp	@#fpspur
1$:		mov	#sdone,	@#sadr
		br	serr10

; report fps failure:
serr15:		mov	#100200, @#$tmp4
		mov	R4, @#$tmp3
1$:		emt	+1
		jmp	@sadr

; report fec bad:
serr20:		mov	#2, @#$tmp4
		mov	R4, @#$tmp3
1$:		emt	+1
		jmp	@sadr

; ac0 was modified. (but fsrc) fork failed.
serr2:		mov	#s2, @#$tmp2
1$:		emt	+1
		br	sdone

serr6:		mov	#s8, @#$tmp2
1$:		emt	+1
		br	sdone

serr3:		mov	#s2, @#$tmp2
1$:		emt	+1
		br	sdone
serr7:		mov	#s8, @#$tmp2
1$:		emt	+1
		br	sdone

; failure of (but fsrc)	caused an odd address trap to 4.
serr1:		cmp	(SP), #s3		; did trap occur on tested instruction?
		beq	1$
		cmp	(SP), #s4
		beq	1$
		jmp	@#cpspur
1$:		mov	(SP), @#$tmp2
		cmp	(SP)+, (SP)+
2$:		emt	+1
		br	sdone

serr5:		cmp	(SP), #s8		; did trap occur on test instruction?
		beq	1$
		cmp	(SP), #s9
		beq	1$
		jmp	@#cpspur
1$:		mov	(SP), @#$tmp2
		cmp	(SP)+, (SP)+
2$:		emt	+1
		br	sdone

sadr:		0
		-1
spat10:		10421
spat11:		21042
spat12:		31463
spat13:		42104
sdat00:		0
sdat01:		0
sdat02:		0
sdat03:		0
sdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 14 - fsrc mode 2	test
; This is a test of fsrc mode 2, auto
; increment mode.
;
tst14:		scope
		lperr				; set up the loop on error address.

j1:
		setd				; set double mode
		mov	#jdat0,	R0
		ldd	(R0), ac0		; load ac0=all 1
		mov	#jdat10, R0
		clr	R3
		mov	#jerr0,	@#errvect

j2:		ldd	(R0)+, ac0		; test instruction
j3:		inc	R3
j4:		inc	R3
		mov	#jdat00, R1
		std	ac0, (R1)		; pick up results
		cmp	R0, #jbuf0		; was an auto
		bne	1$			; decrement executed?
		br	jerr1
1$:		mov	#jdat10, R2		; is data correct?
		mov	#jdat00, R3
		mov	#4, R4

j5:		cmp	(R2)+, (R3)+
		beq	j6
		br	jerr2

j6:		sob	R4, j5
		cmp	#jdat10+10, R0		; was R0 increm.
		beq	j7			; by 10	(octal)
		br	jerr1

j7:		br	jdone

; if a trap through 4 occurs come here
jerr0:		cmp	(SP), #j3		; see if the trap
		beq	j10			; occurred on the
		cmp	(SP), #j4		; tested instruction
		beq	j10
		jmp	@#cpspur

j10:		mov	#762, @#$tmp3		; report fsrc flow
		mov	#322, @#$tmp4		; failure
		mov	(SP), @#$tmp2
		cmp	(SP)+, (SP)+
1$:		emt	+1
		br	jdone

jerr1:						; report, R0 not
		mov	#j2, @#$tmp2		; correctly affected
		mov	R0, @#$tmp3
		mov	#jdat10+10, @#$tmp4
1$:		emt	+1
		br	jdone

; report data failure
jerr2:
		mov	#j2, @#$tmp2
		mov	#jdat10, @#$tmp3
		mov	#jdat00, @#$tmp4
1$:		emt	+1
		br	jdone

jbuf0:		.word	010421
jbuf1:		021042
jbuf2:		042104
jbuf3:		031463
jdat10:		052525
jdat11:		114631
jdat12:		063146
jdat13:		073567
jdat00:		0
jdat01:		0
jdat02:		0
jdat03:		0
jdat0:		-1
jdat1:		-1
jdat2:		-1
jdat3:		-1
jdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 15 - fsrc mode 4	test
; This is a test of fsrc mode 4, auto
; decrement mode.
;
tst15:		scope
		lperr				; set up the loop on error address.

k1:
		setd				; set double mode
		mov	#kpat0,	R0
		ldd	(R0), ac0		; load a default
						; pattern into ac0
		mov	#kbuf0,	R0
		clr	R3
		mov	#kerr0,	@#errvect

k2:		ldd	-(R0), ac0		; test instruction
k3:		inc	R3
k4:		inc	R3
		mov	#kdat00, R1
		std	ac0, (R1)		; pick up the result
		cmp	R0, #kbuf0+10		; was an auto
		bne	1$			; increment executed
		br	kerr1
1$:		mov	#kdat10, R2		; is data correct?
		mov	#kdat00, R3
		mov	#4, R4

k5:		cmp	(R2)+, (R3)+
		beq	k6
		br	kerr2

k6:		sob	R4, k5
		cmp	#kbuf0-10, R0		; was R0 decremented
		beq	k7			; properly?
		br	kerr1

k7:		br	kdone

; trap to here on an odd address error
kerr0:		cmp	(SP), #k3		; see if the error
		beq	k10			; occurred at the
		cmp	(SP), #k4		; instruction tested.
		beq	k10
		jmp	@#cpspur

k10:		mov	#762, @#$tmp3		; report failure in
		mov	#324, @#$tmp4		; fsrc flows
		mov	(SP), @#$tmp2
1$:		emt	+1
		br	kdone

kerr1:						; report, R0
		mov	#k2, @#$tmp2		; incorrectly affected.
		mov	R0, @#$tmp3
		mov	#kdat10, @#$tmp4
1$:		emt	+1
		br	kdone

; report data failure
kerr2:
		mov	#k2, @#$tmp2
		mov	#kdat10, @#$tmp3
		mov	#kdat00, @#$tmp4
1$:		emt	+1
		br	kdone

kdat10:		.word	052525
kdat11:		114631
kdat12:		063140
kdat13:		073567
kbuf0:		010421
kbuf1:		031463
kbuf2:		042104
kbuf3:		021042
kdat00:		0
kdat01:		0
kdat02:		0
kdat03:		0
kpat0:		-1
kpat1:		-1
kpat2:		-1
dpat3:		-1
kdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 16 - fsrc mode 2, with fd=0, test
; This is a test of fsrc mode 2	with
; fd=0,	(auto increment).
;
tst16:		scope
		lperr				; set up the loop on error address.

l1:
		setd				; set double mode
		mov	#lpat10, R0
		ldd	(R0), ac0		; load ac0
		mov	#ldat10, R0		; set up the input
		mov	#lpat20, R1		; data
		mov	#4, R2
1$:		mov	(R1)+, (R0)+
		sob	R2, 1$
		mov	#ldat10, R0
		clr	R3
		setf				; clear	fd.

l2:		ldf	(R0)+, ac0
l3:		inc	R3

l4:
		setd				; set fd
		mov	#ldat00, R1
		std	ac0, (R1)		; pick up results
		cmp	R0, #ldat12		; was R0 incremented
		beq	1$			; correctly by 4
		br	lerr1
1$:		mov	#-1, @#ldat12
		mov	#-1, @#ldat13
		mov	#ldat10, R2		; is data correct
		mov	#ldat00, R3
		mov	#4, R4
l5:		cmp	(R2)+, (R3)+
		beq	l6
		br	lerr2
l6:		sob	R4, l5
		br	ldone

lerr1:						; report failure
		mov	#l2, @#$tmp2		; R0 not incremented
		mov	R0, @#$tmp3		; by 4
		mov	#ldat12, @#$tmp4
1$:		emt	+1
		br	ldone

lerr3:						; report data failure.
		mov	#l2, @#$tmp2
		mov	#ldat10, @#$tmp3
		mov	#ldat00, @#$tmp4
1$:		emt	+1
		br	ldone

lerr2:		mov	#lpat20, R2		; did (but fd)
		mov	#ldat00, R3		; fail.
		mov	#4, R4
1$:		cmp	(R2)+, (R3)+
		bne	lerr3
		sob	R4, 1$
		mov	#l2, @#$tmp2
		mov	#ldat10, @#$tmp3
		mov	#ldat01, @#$tmp4
2$:		emt	+1
		br	ldone

lpat10:		.word	-1
lpat11:		-1
lpat12:		-1
lpat13:		-1
lpat20:		052525
lpat21:		114631
lpat22:		063142
lpat23:		073567
		.word	000001
ldat10:		0
ldat11:		0
ldat12:		0
ldat13:		0
		.word	00001
ldat00:		0
ldat01:		0
ldat02:		0
ldat03:		0
ldone:
		rsetup
;_____________________________________________________________________________
;
; TEST 17 - fsrc mode 2	with gr7, immediate mode, test
; This is a test of fsrc mode 2
; using	gr7 (the PC). This is immediate
; mode.
;
tst17:		scope
m1:
		setd
		mov	#mpat10, R0
		ldd	(R0), ac0		; load backround
						; pattern into ac0.
		clr	R4
		mov	#merr3,	@#errvect

m15:		.word	172427,	5204		; 16-bit word, or the "exp-fraction" word.
;		ldd	#0, ac0			; test instruction
;		.=.-2				; effectively: 05204 is	put in the first
;		.word	5204			; 16-bit word, or the "exp-fraction" word.
;
m2:		inc	R4			; note that
m3:		inc	R4			; 005204=inc R4
m4:		inc	R4
		cmp	R4, #3			; see if the PC
		beq	1$			; was incremented
		br	merr0			; by 2 during the
						; instruction if
						; not then a bad
						; constant was generated
1$:		mov	#mdat00, R0
		std	ac0, (R0)		; get the data
		mov	#mdat00, R0
		cmp	#5204, (R0)+		; is the data correct?
		beq	m5
		br	merr1
m5:		mov	#3, R1
m6:		tst	(R0)+
		bne	m7
		sob	R1, m6
		br	mdone

m7:		mov	#mdat00, R0		; did (but gam)	fail?
		mov	#4, R1
m8:		cmp	#5204, (R0)+
		beq	m9
		br	merr1
m9:		sob	R1, m8

merr2:						; report failure
		mov	#m15, @#$tmp2		; of (but gr7)
		mov	#mpat20, @#$tmp3
		mov	#mdat00, @#$tmp4
1$:		emt	+1
		br	mdone

merr0:		mov	#m2, R5			; report failure
		mov	R5, @#$tmp4		; PC incremented
		sub	#3, R4
		asl	R4
		sub	R4, R5
		mov	R5, @#$tmp3
		mov	#m15, @#$tmp2
1$:		emt	+1
		br	mdone

merr1:						; report data
		mov	#m15, @#$tmp2		; failure
		mov	#mdat00, @#$tmp3
		mov	#mpat20, @#$tmp4
1$:		emt	+1
		br	mdone
; trap to here through 4.
merr3:		bit	#1, (SP)		; see if the
		bne	1$			; trap to 4 occurred
		jmp	@#cpspur		; because of an
						; odd address
1$:		mov	(SP), @#$tmp3		; if yes report
		mov	#m2, @#$tmp4		; bad constant
		mov	#m15, @#$tmp2		; generated
		cmp	(SP)+, (SP)+
2$:		emt	+1
		br	mdone

mpat10:		-1
mpat11:		-1
mpat12:		-1
mpat13:		-1
mpat20:		5204
mpat21:		5204
mpat22:		5204
mpat23:		5204
mdat00:		0
mdat01:		0
mdat02:		0
mdat03:		0
mdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 20 - fsrc mode 3	test
; This is a test of fsrc mode 3, auto increment
; deferred.
;
tst20:		scope
n1:
		setd				; set fd mode
		mov	#npat10, R0
		ldd	(R0), ac0		; load ac0 with	a default
						; pattern
		mov	#npat20, R0
		clr	R3
		mov	#nerr0,	@#errvect	; if a failure occurs
						; in the fsrc flows an
						; odd trap to 4	could occur
n2:		ldd	@(R0)+,	ac0		; test instruction.
n3:		inc	R3
n4:		inc	R3
		mov	#ndat00, R1
		std	ac0, (R1)		; get the data
		cmp	R0, #npat20+2		; was R0 incremented
		beq	n12			; by 2?

n5:		cmp	R0, #npat20+10		; fsrc mode 2?
		bne	n6
		br	nerr1

n6:		cmp	R0, #npat20-10		; fsrc mode 4?
		bne	n7
		br	nerr2

n7:		cmp	R0, #npat20
		bne	n11
		mov	#ndat00, R2		; fsrc mode 0?
		mov	#4, R3

n8:		cmp	(R2)+, #-1
		bne	n9
		sob	R3, n8
		br	nerr3

n9:		mov	#ndat00, R2		; fsrc mode 1
		mov	#npat20, R3
		mov	#4, R4

n10:		cmp	(R2)+, (R3)+
		bne	n11
		sob	R4, n10
		br	nerr4

n11:		br	nerr5

n12:		mov	#ndat00, R2		; data correct?
		mov	#ndat10, R3
		mov	#4, R4
n13:		cmp	(R2)+, (R3)+
		bne	n14
		sob	R4, n13
		br	ndone

n14:		br	nerr6

; if an	odd address trap occurs	come here
; to see if the	failure	was in the fsrc
; flows
nerr0:		cmp	#n4, (SP)		; fsrc mode 6 or 7?
		beq	nerr10
		cmp	#n3, (SP)
		beq	1$
		jmp	@#cpspur
1$:		cmp	R0, #npat20-2		; fsrc mode 5?
		beq	nerr11
		jmp	@#cpspur

nerr10:						; went to fsrc
		mov	(SP), @#$tmp2		; mode 6 or 7.
		cmp	(SP)+, (SP)+
1$:		emt	+1
		br	ndone

nerr11:		mov	(SP), @#$tmp2		; went to fsrc
		cmp	(SP)+, (SP)+		; mode 5.
		mov	#627, @#$tmp5
		mov	#323, @#$tmp7
		mov	#325, @#$tmp6
1$:		emt	+1
		br	ndone
nerr1:		mov	#322, @#$tmp6		; fsrc mode 2.
nerr20:		mov	#627, @#$tmp5
		mov	#323, @#$tmp7
		mov	#n2, @#$tmp2
1$:		emt	+1
		br	ndone
nerr2:		mov	#324, @#$tmp6		; fsrc mode 4
		br	nerr20
nerr3:		mov	#320, @#$tmp6		; fsrc mode 0
		br	nerr20
nerr4:		mov	#321, @#$tmp6		; fsrc mode 1
		br	nerr20

nerr5:		mov	R0, @#$tmp3		; R0 not
		mov	#npat20+2, @#$tmp4	; incremented
		mov	#n2, @#$tmp2		; properly.
1$:		emt	+1
		br	ndone

nerr6:						; data failure.
		mov	#n2, @#$tmp2
		mov	#ndat00, @#$tmp3
		mov	#ndat10, @#$tmp4
1$:		emt	+1
		br	ndone

ndat00:		.word	0
ndat01:		0
ndat02:		0
ndat03:		0
		.word	52525, 52525, 52525, 52525
npat20:		.word	ndat10
npat21:		070707
npat22:		070707
npat23:		070707
		.word	1
npat10:		.word	-1
npat11:		-1
npat12:		-1
npat13:		-1
ndat10:		.word	010421
ndat11:		021042
ndat12:		031463
ndat13:		042104
ndone:
		rsetup
;_____________________________________________________________________________
;
; TEST 21 - fsrc mode 5	test
; This is a test of fsrc mode 5, auto decrement
; deferred.
;
tst21:		scope
o1:
		setd				; set fd mode
		mov	#opat10, R0
		ldd	(R0), ac0		; load ac0 with	a
						; default pattern.
		mov	#opat21, R0
		clr	R3
		mov	#oerr0,	@#errvec	; if a failure
						; occurs in the	fsrc
						; flows	an odd addr.
						; trap to 4 may	occur.
o2:		ldd	@-(R0),	ac0		; test instruction
o3:		inc	R3
o4:		inc	R3
		mov	#odat00, R1
		std	ac0, (R1)		; get the data
		cmp	R0, #opat20		; was R0 decremented
		beq	o12			; by 2?

o5:		cmp	R0, #opat21+10		; fsrc mode 2
		bne	o6
		br	oerr1

o6:		cmp	R0, #opat21-10		; fsrc mode 4?
		bne	o7
		br	oerr2

o7:		cmp	R0, #opat21
		mov	#odat01, R2		; fsrc mode 0?
		mov	#4, R3

o8:		cmp	(R2)+, #-1
		bne	o9
		sob	R3, o8
		br	oerr3

o9:		mov	#odat00, R2		; fsrc mode 1?
		mov	#opat21, R3
		mov	#4, R4

o10:		cmp	(R2)+, (R3)+
		bne	o11
		sob	R4, o10
		br	oerr4

o11:		br	oerr5

o12:		mov	#odat00, R2		; data correct?
		mov	#odat10, R3
		mov	#4, R4

o13:		cmp	(R2)+, (R3)+
		bne	o14
		sob	R4, o13
		br	odone

o14:		br	oerr6

; if an	odd address trap occurs	come
; here to see if the failure was in the
; fsrc flows:
oerr0:		cmp	#o4, (SP)		; fsrc mode 6 or 7?
		beq	oerr10
		cmp	#o3, (SP)
		beq	1$
		jmp	@#cpspur
1$:		cmp	R0, #opat21+2		; fsrc mode 3?
		beq	oerr1
		jmp	@#cpspur

oerr10:						; went to fsrc
		mov	(SP), @#$tmp2		; mode 6 or 7
		cmp	(SP)+, (SP)+
1$:		emt	+1
		br	odone

oerr11:		mov	(SP), @#$tmp3		; went to fsrc mode
		cmp	(SP)+, (SP)+		; 3
		mov	#627, @#$tmp5
		mov	#325, @#$tmp7
		mov	#323, @#$tmp6
1$:		emt	+1
		br	odone

oerr1:		mov	#322, @#$tmp6		; fsrc mode2
oerr20:		mov	#627, @#$tmp4
		mov	#325, @#$tmp7
		mov	#o2, @#$tmp2
1$:		emt	+1
		br	odone
oerr2:		mov	#324, @#$tmp6		; fsrc mode 4
		br	oerr20
oerr3:		mov	#320, @#$tmp6		; fsrc mode 0
		br	oerr20
oerr4:		mov	#321, @#$tmp6		; fsrc mode 1
		br	oerr20

oerr5:		mov	R0, @#$tmp3		; R0 not decremented
		mov	#opat20, @#$tmp4	; properly
		mov	#o4, @#$tmp2
1$:		emt	+1
		br	odone

oerr6:						; data failure
		mov	#o2, @#$tmp2
		mov	#odat00, @#$tmp3
		mov	#odat10, @#$tmp4
1$:		emt	+1
		br	odone

odat00:		.word	0
odat01:		0
odat02:		0
odat03:		0
		.word	52525, 52525, 52525
opat20:		.word	odat10
opat21:		070707
opat22:		070707
opat23:		070707
opat24:		070707
		.word	1
opat10:		.word	-1
opat11:		-1
opat12:		-1
opat13:		-1
odat10:		.word	73567
odat11:		004210
odat12:		114631
odat13:		125252
odone:
		rsetup
;_____________________________________________________________________________
;
; TEST 22 - fsrc mode 6	test
; This is a test of fsrc mode 6, index mode
;
tst22:		scope
p1:
		setd				; set fd mode
		mov	#ppat10, R0
		ldd	(R0), ac0		; load a default pattern
						; into ac0
		mov	#perr0,	@#errvect	; if the (but fsrc) forq
						; fails	an odd address trap
		mov	#pdat10-241, R0		; could	occur.

p2:		ldd	241(R0), ac0
p3=p2+2

p4:		mov	#pdat00, R1
		std	ac0, (R1)		; get the data
		mov	#4, R3
		mov	#pdat10, R2
		mov	#pdat00, R1
p5:		cmp	(R2)+, (R1)+		; check	the data
		bne	p6
		sob	R3, p5
		cmp	#pdat10-241, R0		; R0 correct?
		beq	1$
		br	perr21
1$:		jmp	@#pdone

p6:		mov	#pdat00, R1
		mov	#4, R3
p7:		cmp	#-1, (R1)+		; was it fsrc mode 0?
		beq	p8
		br	perr1
p8:		sob	R3, p7
		br	perr2
; trap to here on an odd address
perr0:		cmp	(SP), #p3
		beq	perr11
		cmp	(SP), #p4		; was it fsrc mode 7?
		beq	perr10
		jmp	@#cpspur

perr10:		mov	#327, @#$tmp6
		br	perr17
perr11:		cmp	#pdat10-241, R0		; was it fsrc mode 1
		bne	perr12
		mov	#321, @#$tmp6
		br	perr17
perr12:		cmp	#pdat10-241+10,	R0	; was it fsrc mode 2
		bne	perr13
		mov	#322, @#$tmp6
		br	perr17
perr13:		cmp	#pdat10-241+2, R0	; was it fsrc mode 3
		bne	perr14
		mov	#323, @#$tmp6
		br	perr17
perr14:		cmp	#pdat10-241-10,	R0	; was it fsrc mode 4
		bne	perr15
		mov	#324, @#$tmp6
		br	perr17
perr15:		cmp	#pdat10-241-2, R0	; was it fsrc mode 5
		beq	perr16
		br	perr20
perr16:		mov	#325, @#$tmp6

perr17:		mov	#627, @#$tmp5		; report fsrc
		mov	#326, @#$tmp7		; flows	failure.
		mov	(SP), @#$tmp2
		cmp	(SP)+, (SP)+
1$:		emt	+1
		br	pdone

perr20:		mov	(SP), @#$tmp2		; report R0 affected
		cmp	(SP)+, (SP)+
		br	perr22
perr21:		mov	#p2, @#$tmp2
perr22:
		mov	R0, @#$tmp3
		mov	#pdat10-241, @#$tmp4
1$:		emt	+1
		br	pdone

perr1:						; data failure.
		mov	#p2, @#$tmp2
		mov	#pdat10, @#$tmp3
		mov	#pdat00, @#$tmp4
1$:		emt	+1
		br	pdone

perr2:						; fsrc failure to
		mov	#p2, @#$tmp2		; mode 0
		mov	#627, @#$tmp5
		mov	#326, @#$tmp7
		mov	#320, @#$tmp6
1$:		emt	+1
		br	pdone

ppat10:		.word	-1
ppat11:		-1
ppat12:		-1
ppat13:		-1
pdat10:		.word	010421
pdat11:		031463
pdat12:		052525
pdat13:		073567
pdat00:		.word	0
pdat01:		0
pdat02:		0
pdat03:		0
pdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 23 - fsrc mode 7	test
; This is a test of fsrc mode 7, index
; deferred mode.
;
tst23:		scope
q1:
		setd

		mov	#qpat10, R0
		ldd	(R0), ac0		; load a default
						; pattern into ac0
		mov	#qerr0,	@#errvect	; if the (but fsrc)
						; fork fails an
						; odd adr trap could
						; occur
		mov	#qpat20-241, R0

q2:		ldd	@241(R0), ac0
q3=q2+2

q4:		mov	#qdat00, R1
		std	ac0, (R1)		; get the data
		mov	#4, R3
		mov	#qdat00, R4
		mov	#qdat10, R5
q5:		cmp	(R4)+, (R5)+		; check	the data
		bne	q6
		sob	R3, q5
		cmp	#qpat20-241, R0		; check	R0.
		beq	1$
		br	qerr21
1$:		jmp	@#qdone

q6:		mov	#qdat00, R1
		mov	#4, R3
q7:		cmp	#-1, (R1)+		; was it fsrc mode 0?
		bne	q8
		sob	R3, q7
		br	qerr2

q8:		mov	#qpat20, R1
		mov	#qdat00, R2
		mov	#4, R3
q9:		cmp	(R1)+, (R2)+		; was it fsrc 6
		beq	q10			; or data failure
		br	qerr1
q10:		sob	R3, q9
		br	qerr3

; trap to here on an odd adr failure

qerr0:		cmp	(SP), #p3
		jmp	@#cpspur

qerr11:		cmp	#qpat20-241, R0		; was it fsrc
		bne	qerr12			; mode 1?
		mov	#321, @#$tmp6
		br	qerr17
qerr12:		cmp	#qpat20-241+10,	R0	; was it fsrc
		bne	qerr13			; mode 2?
		mov	#322, @#$tmp6
		br	qerr17
qerr13:		cmp	#qpat20-241+2, R0	; was it fsrc
		bne	qerr14			; mode 3?
		mov	#323, @#$tmp6
		br	qerr17
qerr14:		cmp	#qpat20-241-10,	R0	; was it fsrc
		bne	qerr15			; mode 4
		mov	#324, @#$tmp6
		br	qerr17
qerr15:		cmp	#qpat20-241-2, R0	; was it fsrc
		beq	qerr16			; mode 5
		br	qerr20

qerr16:		mov	#325, @#$tmp6

qerr17:		mov	#627, @#$tmp5		; report fsrc failure
		mov	#327, @#$tmp7
		mov	(SP), @#$tmp2
		cmp	(SP)+, (SP)+
1$:		emt	+1
		br	qdone

qerr20:		mov	(SP), @#$tmp2		; report R0 affected.
		cmp	(SP)+, (SP)+
		br	qerr22
qerr21:		mov	#q2, @#$tmp2

qerr22:		mov	R0, @#$tmp3
		mov	#qpat20-241, @#$tmp4
1$:		emt	+1
		br	qdone

qerr2:		mov	#320, @#$tmp6		; went to fsrc
		br	qerr4			; mode 0

qerr3:		mov	#326, @#$tmp6		; went to fsrc
						; mode 6
qerr4:		mov	#627, @#$tmp5
		mov	#327, @#$tmp7
		mov	#q2, @#$tmp2
1$:		emt	+1
		br	qdone

qerr1:						; data failure
		mov	#q2, @#$tmp2
		mov	#qdat10, @#$tmp3
		mov	#qdat00, @#$tmp4
1$:		emt	+1
		br	qdone

qpat10:		.word	-1
qpat11:		-1
qpat12:		-1
qpat13:		-1
qpat20:		.word	qdat10
qpat21:		52525
qpat22:		52525
qpat23:		52525
qdat00:		.word	0
qdat01:		0
qdat02:		0
qdat03:		0
qdat10:		.word	073567
qdat11:		.word	052525
qdat12:		.word	031463
qdat13:		.word	010421
qdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 24 - (but ezbt y8), (but	enbt) and (but fiuv) test
; Load instruction flows.
; Each of the patterns:
;		0
;		+num
;		-num
;		-0
; is loaded twice, once	with ac>0 then
; with ac=0. After each	load the fps is
; check	to insure that control was passed
; through with the forks properly.
;
tst24:		scope
		clr	@#uflag
		mov	#upat00, R0		; set up ac#0 data.
		mov	#4, R1
u0:		mov	#-1, (R0)+
		sob	R1, u0
		mov	#033, @#utmp1
		mov	#023, @#utmp2
		mov	#uerr0,	@#fpvect	; in case (but fiuv fails)
u1:
		lperr				; set up the loop on error address.
		mov	#200, R0
		ldfps	R0
		mov	#upat00, R0		; load ac0
		ldd	(R0), ac0
		mov	@#utmp1, @#urom1
		mov	#001, @#urom2
		mov	#254, @#urom3
		mov	#upat10, R0		; load 0 into ac0

u2:		ldd	(R0), ac0
		mov	R0, @#$tmp10
		mov	#u2, @#$tmp2
		mov	#204, R4		; see if fps is	correct
		stfps	R5
		cmp	R4, R5
		beq	u3
		jmp	@#uerr1

u3:
		lperr				; set up the loop on error address.
		mov	#200, R0
		ldfps	R0
		mov	#upat00, R0		; load ac0
		ldd	(R0), ac0
		mov	@#utmp2, @#urom1
		mov	#003, @#urom2
		mov	#054, @#urom3
		mov	#upat20, R0		; load a positive number
						; into ac0
u4:		ldd	(R0), ac0
		mov	R0, @#$tmp10
		mov	#u4, @#$tmp2
		mov	#200, R4		; fps correct?
		stfps	R5
		cmp	R4, R5
		beq	u5
		jmp	@#uerr2
u5:

		lperr				; set the loop on error	address.
		mov	#200, R0
		ldfps	R0
		mov	#upat00, R0		; load ac0
		ldd	(R0), ac0
		mov	@#utmp2, @#urom1
		mov	#403, @#urom2
		mov	#056, @#urom3
		mov	#upat30, R0		; load a negative
						; number into al0
u6:		ldd	(R0), ac0
		mov	R0, @#$tmp10
		mov	#u6, @#$tmp2
		mov	#210, R4		; fps correct
		stfps	R5
		cmp	R4, R5
		beq	u7
		jmp	@#uerr2
u7:
		lperr				; set up the loop on error address.
		mov	#200, R0
		ldfps	R0
		mov	#upat00, R0		; load ac0
		ldd	(R0), ac0
		mov	@#utmp1, @#urom1
		mov	#401, @#urom2
		mov	#256, @#urom3
		mov	#upat40, R0		; load -0 into ac0
u10:		ldd	(R0), ac0
u11:		nop				; trap from here if
		mov	R0, @#$tmp10
		mov	#u10, @#$tmp2		; (but fiuv) fault!
		mov	#214, R4		; see if fps is	correct.
		stfps	R5
		cmp	R4, R5
		beq	u12
		jmp	@#uerr1
u12:		tst	@#uflag			; see if all the patterns
		bne	u14			; have been test with
						; both ac not equal to 0 and ac=0
		mov	#upat00, R0		; if not go back and
		mov	#4, R1			; check	them with ac=0
u13:		clr	(R0)+
		sob	R1, u13
		mov	#-1, @#uflag
		mov	#233, @#utmp1
		mov	#223, @#utmp2
		jmp	@#u1
u14:
		lperr				; set up the loop on error address.
; now see if a trap can	be forced by setting fiuv and loading -0
		mov	#uerr3,	@#fpvect
		mov	#4200, R0		; set fd and fiuv
		ldfps	R0
		mov	#upat00, R0		; set up ac0
		ldd	(R0), ac0
		mov	#upat40, R0		; load -0
u15:		ldd	(R0), ac0		; should trap to 244
u16:		cfcc
		nop
		mov	#u15, @#$tmp2		; report error.
						; didn't trap
1$:		emt	+1			; (but fiuv) failed.
		br	udone

; trapped to 244. did (but fiuv) fail?
uerr0:		cmp	(SP), #u11
		beq	1$
		jmp	@#fpspur
1$:		mov	(SP), @#$tmp2
		cmp	(SP)+, (SP)+
2$:		emt	+1
		br	udone

; come here to analyse fps errors
uerr1:		bit	#4, R5
		beq	uerr20
uerr10:		mov	#443, @#$tmp5
		mov	@#urom3, R3
		mov	R3, @#$tmp7
		bit	#200, R3
		beq	1$
		bic	#200, R3
		br	2$
1$:		bis	#200, R3
2$:		mov	R3, @#$tmp6
uerr11:		mov	R5, @#$tmp3
		mov	R4, @#$tmp4
1$:		emt	+1
		br	udone
uerr2:		bit	#4, R5
		beq	uerr10
uerr20:		mov	@#urom1, @#$tmp5
		mov	@#urom2, R3
		mov	R3, @#$tmp7
		bit	#400, R3
		beq	1$
		bic	#400, R3
		br	2$
1$:		bis	#400, R3
2$:		mov	R3, @#$tmp6
uerr21:		mov	R5, @#$tmp3
		mov	R4, @#$tmp4
1$:		emt	+1
		br	udone

; interrupt here when fiuv set and attempted to	load-o
uerr3:		cmp	(SP), #u16
		beq	1$
		jmp	@#fpspur
1$:		cmp	(SP)+, (SP)+
		clr	R0
		stst	R0			; get fec.
		cmp	#14, R0			; correct
		bne	uerr4
		br	udone
uerr4:		mov	#u15, @#$tmp2
		mov	#12, @#$tmp4
		mov	R0, @#$tmp3
1$:		emt	+1
		br	udone

upat00:		.word	0
upat01:		0
upat02:		0
upat03:		0
upat10:		.word	0			; 0
upat11:		0
upat12:		0
upat13:		0
upat20:		.word	010421			; pos num
upat21:		114631
upat22:		125252
upat23:		177777
upat30:		114631				; neg num
upat31:		135673
upat32:		146314
upat33:		167356
upat40:		100000				; neg zero
upat41:		0
upat42:		0
upat43:		0
uflag:		.word	0
utmp1:		0
utmp2:		0
urom1:		0
urom2:		0
urom3:		0
udone:

;_____________________________________________________________________________
;
; TEST 25 - addf, addd,	subf and subd with fsrc=ac=0 test
; This is a test of add	and sub	with fsrc=ac=0.
;
tst25:		scope
w1:
		lperr				; set up the loop on error address.
		mov	#200, R0
		ldfps	R0			; set double mode
		mov	#wpat00, R0		; load ac0=1
		ldd	(R0), ac0
		mov	#w2, @#$tmp2		; save fp instruction
		mov	#wpat00, R0
w2:		addd	(R0), ac0		; test instruction. add	itself
		stfps	R5			; get fps
		setd				; set double mode
		mov	#wpat00, R0
		std	ac0, (R0)		; get the result
		mov	#wpat00, R1
		mov	#4, R2
w3:		cmp	(R0)+, (R1)+		; is result correct
		beq	w4
						; no
1$:		emt	+2
		jmp	@#wdone
w4:		sob	R2, w3
		cmp	#204, R5		; is fps correct
		beq	w5
						; no
		mov	#204, @#$tmp4
		mov	R5, @#$tmp3
1$:		emt	+1
		jmp	@#wdone
w5:
		lperr				; set up the loop on error address.
		mov	#200, R0
		ldfps	R0			; set double mode
		mov	#wpat00, R0		; load ac0=0
		ldd	(R0), ac0
		mov	#w6, @#$tmp2
		clr	R0
		ldfps	R0			; go to	floating mode
		mov	#wpat00, R0
w6:		addf	(R0), ac0		; test instruction
		stfps	R5			; get fps
		setd				; reset	to double mode
		mov	#wpat00, R0
		std	ac0, (R0)		; get the result
		mov	#wpat00, R1
		mov	#4, R2
w7:		cmp	(R0)+, (R1)+		; was the result
		beq	w10			; no, report failure.
1$:		emt	+2
		br	wdone
w10:		sob	R2, w7
		cmp	#4, R5			; was fps correct
		beq	w11
						; incorrect fps.
		mov	#4, @#$tmp4
		mov	R5, @#$tmp3
1$:		emt	+2
		br	wdone
w11:
		lperr				; set up the loop on error address.
		mov	#200, R0
		ldfps	R0			; set double mode
		mov	#wpat00, R0		; load ac0=0
		ldd	(R0), ac0
		mov	#w12, @#$tmp2
		mov	#wpat00, R0
w12:		subd	(R0), ac0		; test instruction
		stfps	R5			; get fps
		setd				; set double mode
		mov	#wpat00, R0
		std	ac0, (R0)		; get the result
		mov	#wpat00, R1
		mov	#4, R2
w13:		cmp	(R0)+, (R1)+		; is result correct?
		beq	w14
						; no.
1$:		emt	+2
		br	wdone
w14:		sob	R2, w13
		cmp	#204, R5		; is fps correct?
		beq	w15
						; no.
		mov	#204, @#$tmp4
		mov	R5, @#$tmp3
1$:		emt	+1
		br	wdone
w15:
		lperr				; set up the loop on error address.
		mov	#200, R0
		ldfps	R0			; set double mode
		mov	#wpat00, R0		; load ac0=0
		ldd	(R0), ac0
		mov	#w16, @#$tmp2
		clr	R0
		ldfps	R0			; enter	floating mode.
		mov	#wpat00, R0
w16:		subf (R0), ac0			; test instruction.
		stfps	R5			; get fps

		setd				; reset	to double mode
		mov	#wpat00, R0		; get the result.
		std	ac0, (R0)
		mov	#wpat00, R1
		mov	#4, R2
w17:		cmp	(R0)+, (R1)+		; is result correct?
		beq	w20
						; no.
1$:		emt	+2
		br	wdone
w20:		sob	R2, w17
		cmp	#4, R5			; is fps correct?
		beq	wdone
						; no
		mov	#4, @#$tmp4
		mov	R5, @#$tmp3
1$:		emt	+1
		br	wdone

wpat00:		.word	0
wpat01:		0
wpat02:		0
wpat03:		0
wdap00:		.word	0
wdat01:		0
wdat02:		0
wdat03:		0
wdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 26 - addd and sub with fsrc=0
; This is a test of add	and sub	with fsrtc=0.
;
tst26:		scope
x1:
		lperr				; set up the loop on error address.
		mov	#200, R0
		ldfps	R0			; set double mode
		mov	#xpat00, R0		; set ac0 to positive
		mov	-r0, @#xtmp		; number #0
		ldd	(R0), ac0
		mov	#x2, @#$tmp2
		mov	#xpat10, R0		; fsrc=0
x2:		addd	(R0), ac0		; test instruction
		stfps	R5
		setd
		mov	#xdat00, R0		; get result.
		std	ac0, (R0)
		mov	#xpat00, R1
		mov	#4, R2
x3:		cmp	(R0)+, (R1)+		; is result correct?
		beq	x4
		br	xerr1
x4:		sob	R2, x3
		mov	#200, R4
		cmp	R4, R5			; is fps correct?
		beq	x5
		jmp	@#xerr2
x5:
		lperr				; set up the loop on error address.
		mov	#200, R0
		ldfps	R0			; set double mode
		mov	#xpat20, R0		; set ac0 to
		mov	R0, @#xtmp		; negative number
		ldd	(R0), ac0
		mov	#x6, @#$tmp2
		mov	#xpat10, R0		; fsrc=0
x6:		addd	(R0), ac0		; test instruction
		stfps	R5
		setd
		mov	#xdat00, R0		; get result
		std	ac0, (R0)
		mov	#xpat20, R1
		mov	#4, R2
x7:		cmp	(R0)+, (R1)+		; is result correct?
		beq	x10
		br	xerr1
x10:		sob	R2, x7
		mov	#210, R4
		cmp	R4, R5			; is fps correct?
		beq	x11
		br	xerr2
x11:
		lperr				; set up the loop on error address.
		mov	#200, R0
		ldfps	R0			; set double mode
		mov	#xpat00, R0		; set ac0 to non-zero
		mov	R0, @#xtmp		; positive number
		ldd	(R0), ac0
		mov	#x12, @#$tmp2
		mov	#xpat10, R0		; fsrc=0
x12:		subd	(R0), ac0		; test instruction
		stfps	R5
		setd
		mov	#xdat00, R0		; get result
		std	ac0, (R0)
		mov	#xpat00, R1
		mov	#4, R2
x13:		cmp	(R0)+, (R1)+		; is result correct?
		beq	x14
		br	xerr3

x14:		sob	R2, x13
		mov	#200, R4		; is fps correct?
		cmp	R4, R5
		beq	x15
		br	xerr4
x15:
		lperr				; set up the loop on error address.
		mov	#200, R0
		ldfps	R0			; set double mode
		mov	#xpat20, R0		; set ac0=a negative
		mov	R0, @#xtmp		; number
		ldd	(R0), ac0
		mov	#x16, @#$tmp2
		mov	#xpat10, R0		; fsrc=0
x16:		subd	(R0), ac0		; test instruction.
		stfps	R5
		setd
		mov	#xdat00, R0		; get result
		std	ac0, (R0)
		mov	#xpat20, R1
		mov	#4, R2
x17:		cmp	(R0)+, (R1)+		; is result correct?
		beq	x20
		br	xerr3
x20:		sob	R2, x17
		mov	#210, R4		; is fps correct?
		cmp	R4, R5
		beq	x21
		br	xerr4
x21:		br	xdone

; report data errors
xerr1:		mov	#xpat10, @#$tmp3
		mov	@#xtmp,	@#$tmp4
		mov	#xdat00, @#$tmp5
1$:		emt	+1
		br	xdone
xerr3:		mov	#xpat10, @#$tmp3
		mov	@#xtmp,	@#$tmp4
		mov	#xdat00, @#$tmp5
		mov	@#xtmp,	@#$tmp6
1$:		emt	+2
		br	xdone

; report fps errors
xerr2:
		mov	R5, @#$tmp3
		mov	R4, @#$tmp4
1$:		emt	+1
		br	xdone
xerr4:
		mov	R5, @#$tmp3
		mov	R4, @#$tmp4
1$:		emt	+1
		br	xdone

xtmp:		.word	0
xdat00:		.word	0
xdat01:		0
xdat02:		0
xdat03:		0
xpat00:		.word	010421
xpat01:		021042
xpat02:		031463
xpat03:		042104
xpat10:		.word	0
xapt11:		0
xpat12:		0
xpat13:		0
xpat20:		.word	104210
xpat21:		114631
xpat22:		125252
xpat23:		135673
xdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 27 - subd with ac=0 test
; This is a test of subd with ac=0. Both positive
; and negative fsrc's are tried.
;
tst27:		scope
		clr	@#yflag
		mov	#ypat00, @#ytmp1	; p
		mov	#ypat10, @#ytmp2	; n
		mov	#210, @#ytmp3
y1:
		lperr				; set up the loop on error address.
		mov	#200, R0
		ldfps	R0			; set double mode
		mov	#ypat20, R0		; set ac0=0
		ldd	(R0), ac0
		mov	@#ytmp1, R0
y2:		subd	(R0), ac0		; test instruction
		stfps	R5
		setd
		mov	#ydat00, R0		; get result
		std	ac0, (R0)
		mov	#4, R2
		mov	@#ytmp2, R1		; check	result.
y3:		cmp	(R0)+, (R1)+
		bne	y6
		sob	R2, y3
		cmp	@#ytmp3, R5		; fps correct?
		beq	y4
		br	yerr3
y4:		tst	@#yflag			; finished test?
		bne	y5
		mov	#-1, @#yflag
		mov	#ypat10, @#ytmp1
		mov	#ypat00, @#ytmp2
		mov	#200, @#ytmp3
		br	y1
y5:		br	ydone
y6:		mov	#4, R2
		mov	#ytmp1,	R0		; did xor of sign bit
		mov	#ydat00, R1		; fail?
y7:		cmp	(R0)+, (R1)+
		bne	yerr1
		sob	R2, y7
		br	yerr2
yerr1:						; data failure
		mov	#y2, @#$tmp2
		mov	@#ytmp1, @#$tmp3
		mov	#ypat20, @#$tmp4
		mov	#ydat00, @#$tmp5
		mov	@#ytmp2, @#$tmp6
1$:		emt	+1
		br	ydone
yerr2:						; xor of sign bit
		mov	#y2, @#$tmp2		; failed
		mov	@#ytmp1, @#$tmp3
		mov	#ypat20, @#$tmp4
		mov	#ydat00, @#$tmp5
		mov	@#ytmp2, @#$tmp6
1$:		emt	+2
		br	ydone
yerr3:						; fps wrong.
		mov	#y2, @#$tmp2
		mov	R5, @#$tmp3
		mov	@#ytmp3, @#$tmp4
1$:		emt	+2
		br	ydone

yflag:		.word	0
ytmp1:		0
ytmp2:		0
ytmp3:		0
ydat00:		.word	0
ydat01:		0
ydat02:		0
ydat03:		0
ypat00:		063146
ypat01:		052525
ypat02:		042104
ypat03:		167356
ypat10:		163146
ypat11:		052525
ypat12:		042104
ypat13:		167356
ypat20:		0
ypat21:		0
ypat22:		0
ypat23:		0
ydone:
		rsetup
;_____________________________________________________________________________
;
; TEST 30 - addd with ac=0 test
; This is a test of addd with ac=0. Both
; positive and negative	fsrc's are tried.
;
tst30:		scope
		clr	zflag
		mov	#zpat00, @#ztmp1	; p
		mov	#200, @#ztmp2
z1:
		lperr				; set up the loop on error address.
		mov	#200, R0
		ldfps	R0			; set double mode
		mov	#zpat20, R0		; set ac0=0
		ldd	(R0), ac0
		mov	@#ztmp1, R0
z2:		addd	(R0), ac0		; test instruction
		stfps	R5
		setd
		mov	#zdat00, R0		; get result
		std	ac0, (R0)
		mov	#4, R2
		mov	@#ztmp1, R1		; result correct?
z3:		cmp	(R0)+, (R1)+
		beq	z4
		br	zerr1
z4:		sob	R2, z3
		cmp	@#ztmp2, R5		; fps correct?
		beq	z5
		br	zerr2
z5:		tst	@#zflag			; finished test?
		bne	z6
		mov	#-1, @#zflag
		mov	#zpat10, @#ztmp1
		mov	#210, @#ztmp2
		br	z1
z6:		br	zdone
zerr1:						; data failure
		mov	#z2, @#$tmp2
		mov	@#ztmp1, @#$tmp3
		mov	#zpat20, @#$tmp4
		mov	#zdat00, @#$tmp5
		mov	@#ztmp1, @#$tmp6
1$:		emt	+2
		br	zdone
zerr2:
		mov	#z2, @#$tmp2
		mov	R5, @#$tmp3
		mov	@#ztmp2, @#$tmp4
1$:		emt	+2
		br	zdone

zflag:		.word	0
ztmp1:		0
ztmp2:		0
zdat00:		.word	0
zdat01:		0
zdat02:		0
zdat03:		0
zpat00:		031463
zpat01:		010421
zpat02:		146314
zpat03:		156735
zpat10:		156735
zpat11:		167356
zpat12:		135673
zpat13:		146314
zpat20:		0
zpat21:		0
zpat22:		0
zpat23:		0
zdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 31 - addf and addd with e(ac)=e(fsrc) test and (but ft) test
; This is a test of the	add instruction	with the
; operands having equal	exponents.
; The round/trunk flows	is also	tested.
;
tst31:		scope
aa1:
		lperr				; set up the loop on error address.
		mov	#3240, R0
		ldfps	R0			; set fiu, fiv,	fd and ft
		mov	#aaerr0, @#fpvect	; in case the over/under
		mov	#aapat0, R0		; flows	in trap	will
						; occur
		ldd	(R0), ac0		; set up ac0
		mov	#aa2, @#$tmp2		; operand
		mov	#aapat1, R0
aa2:		addd	(R0), ac0		; test instruction
						; should truncate
aa3:		mov	#aadat0, R0
		std	ac0, (R0)		; get the result
		mov	#aapat2, R1
		mov	#4, R2
aa4:		cmp	(R0)+, (R1)+		; correct?
		beq	aa7
		mov	#aapat3, R0		; did (but ft) fail
		mov	#aadat0, R1
		mov	#4, R2
aa5:		cmp	(R0)+, (R1)+
		beq	aa6
		br	aaerr1			; data error
aa6:		sob	R2, aa5
		jmp	@#aaerr2		; (but ft) error
aa7:		sob	R2, aa4

; now test double floating round mode.
; a 1 should be	added to the lsb on roung mode.
aa10:
		lperr				; set up the loop on error address.
		mov	#3200, R0		; set fd, fiv, fiv, ft=0
		ldfps	R0
		mov	#aapat0, R0
		ldd	(R0), ac0		; set up ac0 operand
		mov	#aa11, @#$tmp2
		mov	#aapat1, R0
aa11:		addd	(R0), ac0		; test instruction
						; should round
aa12:		mov	#aadat0, R0
		std	ac0, (R0)		; get the result
		mov	#aapat3, R1
		mov	#4, R2
aa13:		cmp	(R0)+, (R1)+		; correct?
		beq	aa20
		mov	#aapat2, R0		; did (but ft) fail?
		mov	#aadat0, R1
		mov	#4, R2
aa14:		cmp	(R0)+, (R1)+
		beq	aa17
		mov	#aapat4, R0		; was the floating
		mov	#aadat0, R1		; constant used
		mov	#4, R2			; instead of the
aa15:		cmp	(R0)+, (R1)+		; double constant
		beq	aa16			; in the round
		br	aaerr3			; flows?
aa16:		sob	R2, aa15			; data error
		br	aaerr4			; constant error
aa17:		sob	R2, aa14
		br	aaerr5			; (but ft) error
aa20:		sob	R2, aa13

; now test addf	with ft=0, round mode
aa21:
		lperr				; set up the loop on error address.
		mov	#3200, R0		; fiv=1, fiv=1,	ft=0
		ldfps	R0
		mov	#aapat0, R0		; load ac0 operand
		ldd	(R0), ac0
		setf				; enter	floating mode
		mov	#aa22, @#$tmp2
		mov	#aapat5, R0
aa22:		addf (R0), ac0			; test instruction
						; should round
aa23:
		setd				; reset	to double
						; mode
		mov	#aadat0, R0		; get the result
		std	ac0, (R0)
		mov	#aapat6, R1		; correct?
		mov	#2, R2
aa24:		cmp	(R0)+, (R1)+
		beq	aa27
		mov	#aapat2, R0		; was the double
		mov	#aadat0, R1		; constant used	instead
		mov	#2, R2			; of the floating
aa25:		cmp	(R0)+, (R1)		; constant in the
		beq	aa26			; round	flows?
		br	aaerr6			; data error
aa26:		sob	R2, aa25
		br	aaerr7			; constant error
aa27:		sob	R2, aa24
		jmp	@#aadone

; come here if a trap occurs to	244.
aaerr0:		mov	@#$tmp2, R0		; see if the trap was
		tst	(R0)+			; at a test instruction
		cmp	R0, (SP)
		beq	1$
10$:		jmp	@#fpspur
1$:
		stst	R0			; get fec
		cmp	R0, #10
		beq	20$			; overflow
		cmp	R0, #12
		beq	30$			; underflow
		br	10$
20$
20$:		mov	(SP), @#$tmp2		; report overflow error
		cmp	(SP)+, (SP)+
21$:		emt	+2
25$:		jmp	@#aadone
30$:		mov	(SP), @#$tmp2		; report underflow
		cmp	(SP)+, (SP)+		; error
31$:		emt	+2
		br	25$

; addd result incorrect
aaerr1:		mov	#aapat2, @#$tmp6
aaer10:		mov	#aapat0, @#$tmp4
		mov	#aapat1, @#$tmp3
		mov	#aadat0, @#$tmp5
1$:		emt	+2
		br	aadone
aaerr2:		mov	#aapat2, @#$tmp6	; (but ft) failed.
		mov	#aapat0, @#$tmp4
		mov	#aapat1, @#$tmp3
		mov	#aadat0, @#$tmp5
1$:		emt	+2
		br	aadone
aaerr3:		mov	#aapat3, @#$tmp6	; data error.
		br	aaer10
aaerr4:		mov	#aapat3, @#$tmp6	; bad constant
		mov	#aapat0, @#$tmp4
		mov	#aapat1, @#$tmp3
		mov	#aadat0, @#$tmp5
1$:		emt	+2
		br	aadone
aaerr5:		mov	#aapat3, @#$tmp6	; (but ft) failed.
		mov	#aapat0, @#$tmp4
		mov	#aapat1, @#$tmp3
		mov	#aadat0, @#$tmp5
1$:		emt	+2
		br	aadone
aaerr6:		mov	#aapat5, @#$tmp3	; fd=0 and
		mov	#aapat0, @#$tmp4	; data error
		mov	#aadat0, @#$tmp5
		mov	#aapat6, @#$tmp6
1$:		emt	+2
		br	aadone
aaerr7:		mov	#aapat5, @#$tmp3	; constant error
		mov	#aapat0, @#$tmp4
		mov	#aadat0, @#$tmp5
		mov	#aapat6, @#$tmp6
1$:		emt	+2
		br	aadone
aadat0:		0
		0
		0
		0
aapat0:		200
		0
		0
		0
aapat1:		200
		0
		0
		1
aapat2:		400
		0
		0
		0
aapat3:		400
		0
		0
		1
aapat4:		400
		0
		100000
		0
aapat5:		200
		1
		0
		0
aapat6:		400
		1
		0
		0
aadone:
		rsetup
;_____________________________________________________________________________
;
; TEST 32 - addf and addd with e(ac) less than e(fsrc) test
; This is atest	of the addd and	addf
; instructions and the align ac	algorithm
; flows. The constant (25 for floating,	57 for
; double) used is checked. then	simple
; and worst case alignment situations are
; tried. Note e(ac) is less then e(fsrc).
;
tst32:		scope
; exponent difference=57=71 (oct) fd=1
cc1:
		lperr				; set up the loop on error address.
		mov	#3200, R4		; set fiv, fiv,	and fd
		ldfps	R4
		mov	#cc2, @#$tmp2
		mov	#ccp0, R0		; set ac0 operand
		ldd	(R0), ac0		; ac0
		mov	#ccp2, R0
cc2:		addd	(R0), ac0		; test instruction
		stfps	R5			; get fps
		mov	#ccdat0, R0		; get the result
		std	ac0, (R0)
		mov	#ccp2, R1		; is it	correct
		mov	#4, R2
cc3:		cmp	(R0)+, (R1)+
		beq	cc6
		mov	#ccdat0, R0		; did a	bad
		mov	#ccp0, R1		; constant (not	57)
		mov	#4, R2			; get generated
cc4:		cmp	(R0)+, (R1)+		; for the alignment
		beq	cc5			; flows?
		jmp	@#ccer1			; data error. d
cc5:		sob	R2, cc4
		jmp	@#ccer2			; bad constant.	d
cc6:		sob	R2, cc3
		cmp	R4, R5			; fps correct?
		beq	cc7
		jmp	@#ccer0			; bad fps.
; exponent difference=56=70 (oct) fd=1
cc7:
		lperr				; set up the loop on error address.
		mov	#3200, R4		; set fiv, fiv,	and fd
		ldfps	R4
		mov	#cc8, @#$tmp2
		mov	#ccp0, R0		; set ac0 operand
		ldd	(R0), ac0
		mov	#ccp1, R0		; fsrc
cc8:		addd	(R0), ac0		; test instruction
		stfps	R5			; get fps
		mov	#ccdat0, R0		; get the result
		std	ac0, (R0)
		mov	#ccp7, R1		; is it	correct
		mov	#4, R2
cc9:		cmp	(R0)+, (R1)+
		beq	cc12
		mov	#ccdat0, R0		; did a	bad
		mov	#ccp1, R1		; constant (not	57)
		mov	#4, R2			; get generated
cc10:		cmp	(R0)+, (R1)+		; for the alignment
		beq	cc11			; flows?
		jmp	@#ccer3			; data error. d
cc11:		sob	R2, cc10
		jmp	@#ccer4			; bad constant.	d
cc12:		sob	R2, cc9
		cmp	R4, R5			; fps correct?
		beq	cc13
		jmp	@#ccer0			; bad fps.
; exponent difference=25=31 (oct) fd=0
cc13:
		lperr				; set up the loop on error address.
		mov	#cc14, @#$tmp2
		mov	#ccp0, R0		; set up ac0 operand.
		ldd	(R0), ac0
		mov	#3000, R4		; set fiv, fiv,	clear fd.
		ldfps	R4
		mov	#ccp6, R0		; fsrc
cc14:		addf	(R0), ac0		; test instruction
		stfps	R5
		setd				; reenter double move
		mov	#ccdat0, R0		; get the result
		std	ac0, (R0)
		mov	#ccp6, R1		; is the result	correct?
		mov	#2, R2
cc15:		cmp	(R0)+, (R1)+
		beq	cc18
		mov	#ccdat0, R0		; was a	bad constant
		mov	#ccp3, R1		; used (not 25)	in
		mov	#2, R2			; the align flows?
cc16:		cmp	(R0)+, (R1)+
		beq	cc17
		jmp	@#ccer5			; data error f
cc17:		sob	R2, cc16
		jmp	@#ccer6			; bad constant f
cc18:		sob	R2, cc15
		cmp	R4, R5
		beq	cc19
		jmp	@#ccer90		; bad fps.
; exponent difference=24=30 (oct) fd=0
cc19:
		lperr				; set up the loop on error address.
		mov	#cc20, @#$tmp2
		mov	#ccp3, R0		; set up ac0 operand.
		ldd	(R0), ac0
		mov	#3000, R4		; set fiv, fiv,	clear fd.
		ldfps	R4
		mov	#ccp5, R0		; fsrc
cc20:		addf	(R0), ac0		; test instruction
		stfps	R5
		setd				; reenter double move
		mov	#ccdat0, R0		; get the result
		std	ac0, (R0)
		mov	#ccp10,	R1		; is the reset correct?
		mov	#2, R2
cc21:		cmp	(R0)+, (R1)+
		beq	cc24
		mov	#ccdat0, R0		; was a	bad constant
		mov	#ccp5, R1		; used (not 25)	in
		mov	#2, R2			; the align flows?
cc22:		cmp	(R0)+, (R1)+
		beq	cc23
		jmp	@#ccer7			; data error f
cc23:		sob	R2, cc22
		jmp	@#ccer8			; bad constant f
cc24:		sob	R2, cc21
		cmp	R4, R5
		beq	cc25
		jmp	@#ccer90		; bad fps.
; exponent differences fd=1
cc25:
		lperr				; set up the loop on error address.
		mov	#3200, R4		; set fiv, fiv,	and fd
		ldfps	R4
		mov	#cc26, @#$tmp2
		mov	#ccp0, R0		; set ac0 operand
		ldd	(R0), ac0
		mov	#ccp3, R0		; fsrc
cc26:		addd	(R0), ac0		; test instruction
		stfps	R5			; get fps
		mov	#ccdat0, R0		; get the result
		std	ac0, (R0)
		mov	#ccp11,	R1		; is it	correct
		mov	#4, R2
cc27:		cmp	(R0)+, (R1)+
		beq	cc30
		mov	#ccdat0, R0		; did a	bad
		mov	#ccp3, R1		; constant (not	57)
		mov	#4, R2			; get generated
cc28:		cmp	(R0)+, (R1)+		; for the alignment
		beq	cc29			; flows?
		jmp	@#ccer10		; data error. d
cc29:		sob	R2, cc28
		jmp	@#ccer11		; bad constant.	d
cc30:		sob	R2, cc27
		cmp	R4, R5			; fps correct?
		beq	cc31
		jmp	@#ccer0			; bad fps.
; exponent difference=100=144 (oct) fd=1
cc31:
		lperr				; set up the loop on error address.
		mov	#3200, R4		; set fiv, fiv,	and fd
		ldfps	R4
		mov	#cc32, @#$tmp2
		mov	#ccp0, R0		; set ac0 operand
		ldd	(R0), ac0
		mov	#ccp4, R0		; fsrc
cc32:		addd	(R0), ac0		; test instruction
		stfps	R5			; get fps
		mov	#ccdat0, R0		; get the result
		std	ac0, (R0)
		mov	#ccp4, R1		; is it	correct
		mov	#4, R2
cc33:		cmp	(R0)+, (R1)+
		beq	cc36
		mov	#ccdat0, R0		; did a	bad
		mov	#ccp4, R1		; constant (not	57)
		mov	#4, R2			; get generated
cc34:		cmp	(R0)+, (R1)+		; for the alignment
		beq	cc35			; flows?
		jmp	@#ccer12		; data error. d
cc35:		sob	R2, cc34
		jmp	@#ccer13		; bad constant.	d
cc36:		sob	R2, cc33
		cmp	R4, R5			; fps correct?
		beq	cc37
		jmp	@#ccer0			; bad fps.
cc37:		jmp	@#ccdone
ccer0:		mov	R4, @#$tmp4		; fps error d
		mov	R5, @#$tmp3
1$:		emt	+2
		jmp	@#ccdone
ccer90:		mov	R4, @#$tmp4		; fps error f
		mov	R5, @#$tmp3
1$:		emt	+2
		jmp	@#ccdone
ccer1:		mov	#ccp2, @#$tmp3		; data error d
		mov	#ccp2, @#$tmp6
ccer50:		mov	#ccp0, @#$tmp4
		mov	#ccdat0, @#$tmp5
1$:		emt	+2
		jmp	@#ccdone
ccer2:		mov	#ccp2, @#$tmp3		; constant bad d(b)
		mov	#ccp2, @#$tmp6
ccer22:		mov	#ccp0, @#$tmp4
		mov	#ccdat0, @#$tmp5
1$:		emt	+2
		jmp	@#ccdone
ccer3:		mov	#ccp1, @#$tmp3
		mov	#ccp7, @#$tmp6
		br	ccer50
ccer4:		mov	#ccp1, @#$tmp3		; constant bad d(g)
		mov	#ccp7, @#$tmp6
ccer44:		mov	#ccp0, @#$tmp4
		mov	#ccdat0, @#$tmp5
1$:		emt	+2
		jmp	@#ccdone
ccer5:		mov	#ccp6, @#$tmp3		; data error f
		mov	#ccp6, @#$tmp6
ccer55:		mov	#ccp0, @#$tmp4
		mov	#ccdat0, @#$tmp5
1$:		emt	+2
		br	ccdone
ccer6:		mov	#ccp6, @#$tmp3		; constant bad f(b)
		mov	#ccp6, @#$tmp6
		mov	#ccp0, @#$tmp4
		mov	#ccdat0, @#$tmp5
1$:		emt	+2
		br	ccdone
ccer7:		mov	#ccp5, @#$tmp3		; data error f
		mov	#ccp10,	@#$tmp6
		br	ccer55
ccer8:		mov	#ccp5, @#$tmp3		; constant bad f(g)
		mov	#ccp10,	@#$tmp6
		mov	#ccdat0, @#$tmp5
		mov	#ccp0, @#$tmp4
1$:		emt	+2
		br	ccdone
ccer10:		mov	#ccp3, @#$tmp3		; data error d
		mov	#ccp11,	@#$tmp6
		br	ccer50
ccer11:		mov	#ccp3, @#$tmp3		; constant bad d(g)
		mov	#ccp11,	@#$tmp6
		br	ccer44
ccer12:		mov	#ccp4, @#$tmp3		; data error d
		mov	#ccp4, @#$tmp6
		br	ccer50
ccer13:		mov	#ccp4, @#$tmp3		; constant bad d(b)
		mov	#ccp4, @#$tmp6
		br	ccer22
ccdat0:		0
		0
		0
		0
ccp0:		200				; e(ac)=1
		0
		0
		0
ccp1:		16200				; e(fsrc)=e(ac)+56=57
		0				;	=71(oct)
		0
		0
ccp2:		16400				; e(fsrc)=e(ac)+57=58
		0				;	=72(oct)
		0
		0
ccp3:		400				; e(fsrc)=e(ac)+1=2
		0
		0
		0
ccp4:		31200				; e(fsrc)=e(ac)+100=101=145(oct)
		0
		0
		0
ccp5:		6200				; e(fsrc)=e(ac)+24=25=31(oct)
		0
		0
		0
ccp6:		6400				; e(fsrc)=e(ac)+25=26=32(oct)
		0
		0
		0
ccp7:		16200				; ccp1 res
		0
		0
		1
ccp10:		6200				; ccp5 res
		1
		0
		0
ccp11:		500				; ccp3 res
		0
		0
		0
ccp12:		200				; bad constant
		0				; res ccp2, ccp4
		0
		0
ccdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 33 - addf and addd with e(ac) greater than e(fsrc) test
; This is a test of the	addd and addf
; instructions and the align fsrc algorithm
; flows. First the constant used is checked.
; Then simple and worst	case alignment
; situations are tried.	Note e(ac)
; is greater than e(fsrc).
;
tst33:		scope
; exponent difference=57=71 (oct) fd=1
bb1:
		lperr				; set up the loop on error address.
		mov	#3200, R4		; set fiv, fiv,	and fd
		ldfps	R4
		mov	#bber0,	@#fpvect	; set up for error
		mov	#bb2, @#$tmp2		; in case the over/
						; under	flows fail.
		mov	#bbpat2, R0		; set ac0 operand.
		ldd	(R0), ac0
		mov	#bbpat1, R0		; fsrc
bb2:		addd	(R0), ac0		; test instruction
		stfps	R5
bb3:		mov	#bbdat0, R0		; get the result
		std	ac0, (R0)
		mov	#bbpat2, R1		; result correct?
		mov	#4, R2
bb4:		cmp	(R0)+, (R1)+
		beq	bb5
		jmp	@#bber1			; data error d
bb5:		sob	R2, bb4
						; was fps correct?
		cmp	R4, R5
		beq	bb6
		jmp	@#bber0			; fps error
; exponent difference=56=70 (oct) fd=1
bb6:
		lperr				; set up the loop on error address.
		mov	#3200, R4		; set fiv, fiv,	and fd
		ldfps	R4
		mov	#bb7, @#$tmp2
		mov	#bbpat4, R0		; set ac0 operand
		ldd	(R0), ac0
		mov	#bbpat1, R0		; fsrc
bb7:		addd	(R0), ac0		; test instruction
		stfps	R5			; get fps
		mov	#bbdat0, R0		; get the result
		std	ac0, (R0)
		mov	#bbp10,	R1		; is it	correct
		mov	#4, R2
bb10:		cmp	(R0)+, (R1)+
		beq	bb13
		mov	#bbdat0, R0		; did a	bad
		mov	#bbpat4, R1		; constant (not	57)
		mov	#4, R2			; get generated
bb11:		cmp	(R0)+, (R1)+		; for the alignment
		beq	bb12			; flows?
		jmp	@#bber2			; data error. d
bb12:		sob	R2, bb11
		jmp	@#bber3			; bad constant.	d
bb13:		sob	R2, bb10
		cmp	R4, R5			; fps correct?
		beq	bb14
		jmp	@#bber0			; bad fps.
; exponent difference=25=31 (oct) fd=0
bb14:
		lperr				; set up the loop on error address.
		mov	#bb15, @#$tmp2
		mov	#bbpat0, R0		; set up ac0 operand
		ldd	(R0), ac0
		mov	#3000, R4		; set fiv and fiv
						; clear	fd
		ldfps	R4
		mov	#bbpat1, R0		; fsrc
bb15:		addf	(R0), ac0		; test instruction
		stfps	R5
		setd				; reented double mode.
		mov	#bbdat0, R0		; get the result
		std	ac0, (R0)
		mov	#bbpat0, R1		; is the result
		mov	#2, R2			; correct?
bb16:		cmp	(R0)+, (R1)+
		beq	bb17
		jmp	@#bber4			; data error f
bb17:		sob	R2, bb16
		cmp	R4, R5			; is fps correct?
		beq	bb20
		jmp	@#bber10		; fps error.
; exponent difference=24=30 (oct)
bb20:
		lperr				; set up the loop on error address.
		mov	#bb21, @#$tmp2
		mov	#bbpat3, R0		; set up ac0 operand.
		ldd	(R0), ac0
		mov	#3000, R4		; set fiu, fiv,	clear fd.
		ldfps	R4
		mov	#bbpat1, R0		; fsrc
bb21:		addf	(R0), ac0		; test instruction
		stfps	R5
		setd				; reenter double mode
		mov	#bbdat0, R0		; get the result
		std	ac0, (R0)
		mov	#bbp7, R1		; is the result	correct?
		mov	#2, R2
bb22:		cmp	(R0)+, (R1)+
		beq	bb25
		mov	#bbdat0, R0		; was a	bad constant
		mov	#bbpat3, R1		; used (not 25)	in
		mov	#2, R2			; the allign flows?
bb23:		cmp	(R0)+, (R1)+
		beq	bb24
		jmp	@#bber5			; data error f
bb24:		sob	R2, bb23
		jmp	@#bber6			; bad constant f
bb25:		sob	R2, bb22
		cmp	R4, R5
		beq	bb26
		jmp	@#bber10		; bad fps.
; exponent difference=1
bb26:
		lperr				; set up the loop on error address.
		mov	#bb27, @#$tmp2
		mov	#3200, R4
		ldfps	R4			; set up ac0 operand
		mov	#bbpat5, R0
		ldd	(R0), ac0
		mov	#bbpat1, R0		; fsrc
bb27:		addd	(R0), ac0		; test instruction
		stfps	R5
		mov	#bbdat0, R0		; get the result.
		std	ac0, (R0)
		mov	#bbp11,	R1		; is it	correct?
		mov	#4, R2
bb30:		cmp	(R0)+, (R1)+
		beq	bb31
		jmp	@#bber7			; data error d
bb31:		sob	R2, bb30
		cmp	R4, R5			; is fps correct
		beq	bb32
		jmp	@#bber0
; exponent difference=100=144 (oct)
bb32:
		lperr				; set up the loop on error address.
		mov	#bb33, @#$tmp2
		mov	#3200, R4
		ldfps	R4			; set fiv, fiv,	and fd
		mov	#bbpat6, R0		; set up ac0 operand.
		ldd	(R0), ac0
		mov	#bbpat1, R0		; fsrc
bb33:		addd	(R0), ac0		; test instruction
		stfps	R5
		mov	#bbdat0, R0		; get the result
		std	ac0, (R0)
		mov	#bbpat6, R1		; is it	correct
		mov	#4, R2
bb34:		cmp	(R0)+, (R1)+
		beq	bb35
		jmp	@#bber8			; data error d
bb35:		sob	R2, bb34
		cmp	R4, R5			; is fps correct
		bne	bber0
		jmp	bbdone
bber0:		mov	R4, @#$tmp4		; fps error d
		mov	R5, @#$tmp3
1$:		emt	+1
		rsetup

		jmp	@#bbdone
bber10:		mov	R4, @#$tmp4		; fps error f
		mov	R5, @#$tmp3
1$:		emt	+2
		rsetup

		jmp	@#bbdone
bber1:		mov	#bbpat2, @#$tmp4	; data error d
		mov	#bbpat2, @#$tmp6
bber11:		mov	#bbpat1, @#$tmp3
		mov	#bbdat0, @#$tmp5
1$:		emt	+2
		jmp	@#bbdone
bber2:		mov	#bbpat4, @#$tmp4
		mov	#bbp10,	@#$tmp6
		br	bber11
bber3:		mov	#bbpat4, @#$tmp4	; bad constant d
		mov	#bbp10,	@#$tmp6
		mov	#bbpat1, @#$tmp3
		mov	#bbdat0, @#$tmp5
1$:		emt	+2
		br	bbdone
bber4:		mov	#bbpat0, @#$tmp4	; data error f
		mov	#bbpat0, @#$tmp6
bber40:		mov	#bbpat1, @#$tmp3
		mov	#bbdat0, @#$tmp5
1$:		emt	+2
		br	bbdone
bber5:		mov	#bbpat3, @#$tmp4
		mov	#bbp7, @#$tmp6
		br	bber40
bber6:		mov	#bbpat3, @#$tmp4	; constant error f
		mov	#bbp7, @#$tmp6
		mov	#bbpat1, @#$tmp3
		mov	#bbdat0, @#$tmp5
1$:		emt	+2
		br	bbdone
bber7:		mov	#bbpat5, @#$tmp4
		mov	#bbpat11, @#$tmp6
		br	bber11
bber8:		mov	#bbpat6, @#$tmp4
		mov	#bbpat6, @#$tmp6
		br	bber11
bbdat0:		0
		0
		0
		0
bbpat0:		6400				; f(ac)=e(fsrc)+25=26
		0				;		=32(oct)
		0
		0
bbpat1:		200
		0				; e(fsrc)=1
		0
		0
bbpat2:		16400
		0				; e(ac)=e(fsrc)+57=58
		0				;		=72(oct)
		0
bbpat3:		6200				; e(ac)=e(fsrc)+24=25
		0				;		=31(oct)
		0
		0
bbpat4:		16200				; e(ac)=e(fsr6)+56=57
		0				;		=71(oct)
		0
		0
bbpat5:		400				; e(ac)=e(fsrc)+1=2
		0
		0
		0
bbpat6:		31200				; e(ac)=e(fsrc)+100=10!
		0				;		=145(0ct)
		0
		0
bbp7:		6200				; bbpat3 res
		1
		0
		0
bbp10:		16200				; bbpat4 res
		0
		0
		1
bbp11:		500				; bbpat5 res
		0
		0
		0
bbdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 34 - addd with negatve oprands test
; This is a test of the	addd instruction
; with negative	operands. Every	combination of
; operand signs	is tried.
;
tst34:		scope
; both operands	negative
dd1:
		lperr				; set up the loop on error address.
		mov	#3200, R4		; set fio, fiv,	and fd
		ldfps	R4
		mov	#dd2, @#$tmp2
		mov	#ddp1, R0		; set ac0 operand
		ldd	(R0), ac0
		mov	#ddp1, R0		; esrc
dd2:		addd	(R0), ac0		; test instruction
		stfps	R5			; get fps
		mov	#dddat0, R0		; get the result
		std	ac0, (R0)
		mov	#ddp9, R1		; is it	correct
		mov	#4, R2
dd3:		cmp	(R0)+, (R1)+
		beq	dd6
		mov	#dddat0, R0		; did a	add-sub
		mov	#ddp4, R1		; flow a failure
		mov	#4, R2
dd4:		cmp	(R0)+, (R1)+
		beq	dd5			; 216, 442, 500
		jmp	@#dder1			; data error, d
dd5:		sob	R2, dd4
		jmp	@#dder2			; flow failure,	d
dd6:		sob	R2, dd3
		bis	#10, R4
		cmp	R4, R5			; fps correct?
		beq	dd7
		jmp	@#dder0			; bad, fps
; ac pos fsrc neg ac>-fsrc
dd7:
		lperr				; set up the loop on error address.
		mov	#3200, R4		; set fio, fiv,	and fd
		ldfps	R4
		mov	#dd8, @#$tmp2
		mov	#ddp2, R0		; set ac0 operand
		ldd	(R0), ac0
		mov	#ddp1, R0		; fspc
dd8:		addd	(R0), ac0		; test instruction
		stfps	R5			; get fps
		mov	#dddat0, R0		; get the result
		std	ac0, (R0)
		mov	#ddp0, R1		; is it	correct
		mov	#4, R2
dd10:		cmp	(R0)+, (R1)+
		beq	dd11
		jmp	@#dder3			; flow failure
dd11:		sob	R2, dd10
		bis	#4, R4
		cmp	R4, R5			; fps correct?
		beq	dd12
		jmp	@#dder0			; bad fps
; ac neg fsrc pos ac=-fsrc
dd12:
		lperr				; set up the loop on error address.
		mov	#3200, R4		; set fiu, fiv,	and fd
		ldfps	R4
		mov	#dd13, @#$tmp2
		mov	#ddp1, R0		; set ac0 operand
		ldd	(R0), ac0
		mov	#ddp2, R0		; fsrc
dd13:		addd	(R0), ac0		; test instruction
		stfps	R5			; get fps
		mov	#dddat0, R0		; get the result
		std	ac0, (R0)
		mov	#ddp0, R1		; is it	correct
		mov	#4, R2
dd14:		cmp	(R0)+, (R1)+
		beq	dd15
		jmp	@#dder4			; flow failure 216, 440, 121
dd15:		sob	R2, dd14
		bis	#4, R4
		cmp	R4, R5			; eps correct?
		beq	dd16
		jmp	@#dder0			; bad fps
; ac0 poc fsrc neg /ac/	> /fsrc/
dd16:
		lperr				; set up the loop on error address.
		mov	#3200, R4		; set fiv, fiv and fd
		ldfps	R4
		mov	#dd17, @#$tmp2
		mov	#ddp3, R0		; set ac0 operand
		ldd	(R0), ac0
		mov	#ddp6, R0		; espc
dd17:		addd	(R0), ac0		; test instruction
		stfps	R5			; get fps
		mov	#dddat0, R0		; get the result
		std	ac0, (R0)
		mov	#ddp7, R1		; is it	correct
		mov	#4, R2
dd18:		cmp	(R0)+, (R1)+
		beq	dd21
		mov	#dddat0, R0		; flows	failure
		mov	#ddp8, R1		; 216, 440, 101
		mov	#4, R2			; get generated
dd19:		cmp	(R0)+, (R1)+
		beq	dd20
		jmp	@#dder5			; data error.
dd20:		sob	R2, dd19
		jmp	@#dder6
dd21:		sob	R2, dd18
		cmp	R4, R5			; eps correct?
		beq	dd22
		jmp	@#dder0			; bad fps
; ac neg fsrc pos /fsrc/ > /ac/
dd22:
		lperr				; set up the loop on error address.
		mov	#3200, R4		; set fio, fiv,	and fd
		ldfps	R4
		mov	#dd23, @#$tmp2
		mov	#ddp6, R0		; set ac0 operand
		ldd	(R0), ac0
		mov	#ddp3, R0		; fspc
dd23:		addd	(R0), ac0		; test instruction
		stfps	R5			; get fps
		mov	#dddat0, R0		; get the result
		std	ac0, (R0)
		mov	#ddp7, R1		; is it	correct?
		mov	#4, R2
dd24:		cmp	(R0)+, (R1)+
		beq	dd27
		mov	#dddat0, R0		; fio, s failure
		mov	#ddp8, R1		; constant (not	57)
		mov	#4, R2			; 216, 042, 101
dd25:		cmp	(R0), (R1)
		beq	dd26
		jmp	@#dder7			; data error.
dd26:		sob	R2, dd25
		jmp	@#dder8
dd27:		sob	R2, dd24
		cmp	R4, R5			; fps correct?
		beq	dd30
		jmp	@#dder0			; bad fps
; ac0 pos fsrc neg /ac/	< /frsrc/
dd30:
		lperr				; set up the loop on error address.
		mov	#3200, R4		; set fio, fiv,	and fd
		ldfps	R4
		mov	#dd31, @#$tmp2
		mov	#ddp4, R0		; set ac0 operand
		ldd	(R0), ac0
		mov	#ddp5, R0		; fspc
dd31:		addd	(R0), ac0		; test instruction
		stfps	R5			; get fps
		mov	#dddat0, R0		; get the result
		std	ac0, (R0)
		mov	#ddp8, R1		; is it	correct
		mov	#4, R2
dd32:		cmp	(R0)+, (R1)+
		beq	dd35			; add-sub
		mov	#dddat0, R0		; flowas failure
		mov	#ddp7, R1		; con 216 n440 not 141
		mov	#4, R2			; get generated
dd33:		cmp	(R0)+, (R1)+		; for the allignment
		beq	dd34			; flows?
		jmp	@#dder9			; data error, d
dd34:		sob	R2, dd33
		jmp	@#dder10
dd35:		sob	R2, dd32
		bis	#10, R4
		cmp	R4, R5			; fps correct?
		beq	dd36
		jmp	@#dder0			; bad fps
; ac0 neg fsrc pos /fsrc/ < /ac/
dd36:
		lperr				; set up the loop on error address.
		mov	#3200, R4		; set fio, fiv,	and fd
		ldfps	R4
		mov	#dd37, @#$tmp2
		mov	#ddp5, R0		; set ac0 operand
		ldd	(R0), ac0
		mov	#ddp4, R0		; fspc
dd37:		addd	(R0), ac0		; test instruction
		stfps	R5			; get fps
		mov	#dddat0, R0		; get the result
		std	ac0, (R0)
		mov	#ddp8, R1		; is it	correct
		mov	#4, R2
dd38:		cmp	(R0)+, (R1)+
		beq	dd41
		mov	#dddat0, R0		; add sub
		mov	#ddp7, R1		; flows	failures
		mov	#4, R2			; get 216, 042,	141
dd39:		cmp	(R0)+, (R1)+		; for the allignment
		beq	dd40			; flows?
		jmp	@#dder11		; data error. d
dd40:		sob	R2, dd39
		jmp	@#dder12		; bad constant.	d
dd41:		sob	R2, dd38
		bis	#10, R4
		cmp	R4, R5			; fps correct?
		beq	dd42
		jmp	@#dder0			; bad fps
dd42:		jmp	@#dddone
dder0:		mov	R4, @#$tmp4		; fps error
		mov	R5, @#$tmp3
1$:		emt	+2
		jmp	@#dddone
dder1:
		mov	#ddp1, @#$tmp3
		mov	#ddp1, @#$tmp4
		mov	#dddat0, @#$tmp5
		mov	#ddp1, @#$tmp6
1$:		emt	+2
		jmp	@#dddone
dder2:
		mov	#ddp1, @#$tmp3
		mov	#ddp1, @#$tmp4
		mov	#dddat0, @#$tmp5
		mov	#ddp9, @#$tmp6
1$:		emt	+2
		jmp	@#dddone
dder3:
		mov	#ddp1, @#$tmp3
		mov	#ddp2, @#$tmp4
		mov	#dddat0, @#$tmp5
		mov	#ddp0, @#$tmp6
1$:		emt	+2
		jmp	@#dddone
dder4:
		mov	#ddp2, @#$tmp3
		mov	#ddp1, @#$tmp4
		mov	#dddat0, @#$tmp5
		mov	#ddp0, @#$tmp6
1$:		emt	+2
		jmp	@#dddone
dder5:
		mov	#ddp6, @#$tmp3
		mov	#ddp3, @#$tmp4
		mov	#dddat0, @#$tmp5
		mov	#ddp7, @#$tmp6
1$:		emt	+2
		jmp	@#dddone
dder6:
		mov	#ddp6, @#$tmp3
		mov	#ddp3, @#$tmp4
		mov	#dddat0, @#$tmp5
		mov	#ddp7, @#$tmp6
1$:		emt	+2
		jmp	@#dddone
dder7:
		mov	#ddp3, @#$tmp3
		mov	#ddp6, @#$tmp4
		mov	#dddat0, @#$tmp5
		mov	#ddp7, @#$tmp6
1$:		emt	+2
		jmp	@#dddone
dder8:
		mov	#ddp3, @#$tmp3
		mov	#ddp6, @#$tmp4
		mov	#dddat0, @#$tmp5
		mov	#ddp7, @#$tmp6
1$:		emt	+2
		jmp	@#dddone
dder9:
		mov	#ddp5, @#$tmp3
		mov	#ddp4, @#$tmp4
		mov	#dddat0, @#$tmp5
		mov	#ddp8, @#$tmp6
1$:		emt	+2
		jmp	@#dddone
dder10:
		mov	#ddp5, @#$tmp3
		mov	#ddp4, @#$tmp4
		mov	#dddat0, @#$tmp5
		mov	#ddp8, @#$tmp6
1$:		emt	+2

		jmp	@#dddone
dder11:
		mov	#ddp4, @#$tmp3
		mov	#ddp5, @#$tmp4
		mov	#dddat0, @#$tmp5
		mov	#ddp8, @#$tmp6
1$:		emt	+2
		jmp	@#dddone
dder12:
		mov	#ddp4, @#$tmp3
		mov	#ddp5, @#$tmp4
		mov	#dddat0, @#$tmp5
		mov	#ddp8, @#$tmp6
1$:		emt	+2
		jmp	@#dddone
dddat0:		0
		0
		0
		0
ddp0:		0
		0
		0
		0
ddp1:		100200				; -ddp2
		0
		0
		0
ddp2:		200				; -ddp1
		0
		0
		0
ddp3:		1100				; exp=4
		0				; frac=...110...
		0
		0
ddp4:		600				; exp=3
		0				; frac=...100...
		0
		0
ddp5:		101100				; -ddp3
		0
		0
		0
ddp6:		100600				; -ddp4
		0
		0
		0
ddp7:		1000				; ddp3+ddp6
		0
		0
		0
ddp8:		101000				; ddp5+ddp4
		0
		0
		0
ddp9:		100400				; ddp1+ddp1
		0
		0
		0
dddone:		reset
;_____________________________________________________________________________
;
; TEST 35 - subd test
; This is a test of the	subd instruction.
; Both a positive and a	negative number
; is subtracted	from it	self.
;
tst35:		scope
; use positive operands
ee1:
		lperr				; set up the loop on error address.
		mov	#3200, R4		; set fiu, fiv,	and fd
		ldfps	R4
		mov	#ee2, @#$tmp2
		mov	#eep1, R0		; set ac0 operand
		ldd	(R0), ac0
		mov	#eep1, R0		; fspc
ee2:		subd	(R0), ac0		; test instruction
		stfps	R5			; get fps
		mov	#eedat0, R0		; get the result
		std	ac0, (R0)
		mov	#eep0, R1		; is it	correct?
		mov	#4, R2
ee3:		cmp	(R0)+, (R1)+
		beq	ee6
		mov	#eedat0, R0		; did a	bad
		mov	#eep2, R1		; constant (not	57)
		mov	#4, R2			; get generated
ee4:		cmp	(R0)+, (R1)+		; for the allignment
		beq	ee5			; flows?
		jmp	@#eeer1			; data error. d
ee5:		sob	R2, ee4
		jmp	@#eeer2			; bad constant.	d
ee6:		sob	R2, ee3
		bis	#4, R4
		cmp	R4, R5			; fps correct?
		beq	ee7
		jmp	@#eeer0			; bad fps
; use negative operands
ee7:
		lperr				; set up the loop on error address.
		mov	#3200, R4		; set fio, fiv,	and fd
		ldfps	R4
		mov	#ee8, @#$tmp2
		mov	#eep3, R0		; set ac0 operand
		ldd	(R0), ac0
		mov	#eep3, R0		; fspc
ee8:		subd	(R0), ac0		; test instruction
		stfps	R5			; get fps
		mov	#eedat0, R0		; get the result
		std	ac0, (R0)
		mov	#eep0, R1		; is it	correct?
		mov	#4, R2
ee9:		cmp	(R0)+, (R1)+
		beq	ee12
		mov	#eedat0, R0		; did a	bad
		mov	#eep4, R1		; constant (not	57)
		mov	#4, R2			; get generated
ee10:		cmp	(R0)+, (R1)+		; for the allignment
		beq	ee11			; flows?
		jmp	@#eeer3			; data error. d
ee11:		sob	R2, ee10
		jmp	@#eeer4			; bad constant.	d
ee12:		sob	R2, ee9
		bis	#4, R4
		cmp	R4, R5			; fps correct?
		beq	ee13
		jmp	@#eeer0			; bad fps.
ee13:		jmp	@#eedone
eeer0:		mov	R4, @#$tmp4		; bad fps
		mov	R5, @#$tmp3
1$:		emt	+2
		jmp	@#eedone
eeer1:
		mov	#eep1, @#$tmp3
		mov	#eep1, @#$tmp4
		mov	#eedat0, @#$tmp5
		mov	#eep0, @#$tmp6
1$:		emt	+2
		jmp	@#eedone
eeer2:
		mov	#eep1, @#$tmp3
		mov	#eep1, @#$tmp4
		mov	#eedat0, @#$tmp5
		mov	#eep0, @#$tmp6
1$:		emt	+2
		jmp	@#eedone
eeer3:
		mov	#eep3, @#$tmp3
		mov	#eep3, @#$tmp4
		mov	#eedat0, @#$tmp5
		mov	#eep0, @#$tmp6
1$:		emt	+2
		jmp	@#eedone
eeer4:
		mov	#eep3, @#$tmp3
		mov	#eep3, @#$tmp4
		mov	#eedat0, @#$tmp5
		mov	#eep0, @#$tmp6
1$:		emt	+2
		jmp	@#eedone
eedat0:		0
		0
		0
		0
eep0:		0
		0
		00000
		0
		0
eep1:		200
		0
		0
		0
eep2:		400
		0
		0
		0
eep3:		100200
		0
		0
		0
eep4:		100400
		0
		0
		0
eedone:
		rsetup
;_____________________________________________________________________________
;
; TEST 36 - normalize algorithm	test
; This is a test of the	normalize
; flow algorithm. Two patterns are used.
; First	the minimum situation requiring	one
; left shift and then the maximum situation
; requiring 56 shifts.
;
tst36:		scope
; use data patterns that require only one left shift to	normalize
ff1:
		lperr				; set up the loop on error address.
		mov	#3200, R4		; set fio, fiv,	and fd
		ldfps	R4
		mov	#ff2, @#$tmp2
		mov	#ffp2, R0		; set ac0 operand
		ldd	(R0), ac0
		mov	#ffp3, R0		; fspc
ff2:		addd	(R0), ac0		; test instruction
		stfps	R5			; get fps
		mov	#ffdat0, R0		; get the result
		std	ac0, (R0)
		mov	#ffp4, R1		; is it	correct
		mov	#4, R2
ff3:		cmp	(R0)+, (R1)+
		beq	ff4
		br	ffer2			; bad data
ff4:		sob	R2, ff3
		cmp	R4, R5			; fps correct?
		beq	ff5
		br	ffer0			; bad fps
; use data patterns which require 56 left shifts to normalize
; the result
ff5:
		lperr				; set up the loop on error address.
		mov	#3200, R4		; set fiu, fiv,	and fd
		ldfps	R4
		mov	#ff6, @#$tmp2
		mov	#ffp0, R0		; set ac0 operand
		ldd	(R0), ac0
		mov	#ffp1, R0		; fsrc
ff6:		addd	(R0), ac0		; test instruction
		stfps	R5			; get fps
		mov	#ffdat0, R0		; get the result
		std	ac0, (R0)
		mov	#ffp4, R1		; is it	correct
		mov	#4, R2
ff7:		cmp	(R0)+, (R1)+
		beq	ff10
		br	ffer1			; bata
ff10:		sob	R2, ff7
		cmp	R4, R5			; fps correct?
		beq	ff11
		br	ffer0			; bad fps
ff11:		br	ffdone
ffer0:		mov	R5, @#$tmp3
		mov	R4, @#$tmp4
1$:		emt	+2
		br	ffdone
ffer1:
		mov	#ffp1, @#$tmp3
		mov	#ffp0, @#$tmp4
		mov	#ffdat0, @#$tmp5
		mov	#ffp4, @#$tmp6
1$:		emt	+1
		jmp	@#ffdone
ffer2:
		mov	#ffp3, @#$tmp3
		mov	#ffp2, @#$tmp4
		mov	#ffdat0, @#$tmp5
		mov	#ffp4, @#$tmp6
1$:		emt	+1
		jmp	@#ffdone

ffdat0:		0
		0
		0
		0
ffp0:		16000
		0
		0
		1
ffp1:		116000
		0
		0
		0
ffp2:		500
		0
		0
		0
ffp3:		100400
		0
		0
		0
ffp4:		200				; ffp4=ffp0+ffp1
		0				;    =ffp3+ffp4
		0
		0
ffdone:

;_____________________________________________________________________________
;
; Floating point second	part
;_____________________________________________________________________________
;
; TEST 37 - round/trunk	test
; This is a test of the	round/trunk
; flows. In particular two things are tested:
; First	a condition in which rounding
; results in the need for renormalization, and
; second the PSW condition codes n and
; Z-bit	commbinations.
;
tst37:		scope
; round	and normalize test
hh1:
		lperr				; set up the loop on error address.
		mov	#3200, R4		; set fiu, fiv,	and fd
		ldfps	R4
		mov	#hh2, @#$tmp2
		mov	#hhp0, R0		; set ac0 operand
		ldd	(R0), ac0
		mov	#hhp1, R0		; fspc
hh2:		addd	(R0), ac0		; test instruction
		stfps	R5			; get fps
		mov	#hhdat0, R0		; get the result
		std	ac0, (R0)
		mov	#hhp2, R1		; is it	correct
		mov	#4, R2
hh3:		cmp	(R0)+, (R1)+
		beq	hh6
		mov	#hhdat0, R0		; did flow go
		mov	#hhp3, R1		; from state 663
		mov	#4, R2			; to 313 instead
hh4:		cmp	(R0)+, (R1)+		; of to	353
		beq	hh5
		jmp	@#hher0
hh5:		sob	R2, hh4
		jmp	@#hher1
hh6:		sob	R2, hh3
		cmp	R4, R5			; fps correct?
		beq	hh7
		jmp	@#hher00

; this is a test of the	ability
; of normalize to produce a zero exp. and
; of the r/t algorithm to properly set the fps
hh7:
		lperr				; set up the loop on error address.
		mov	#043200, R4		; set fiu, fiv,	and fd
						; fid
		ldfps	R4
		mov	#hh8, @#$tmp2		; in case underflow
		mov	#hhtrap, @#fpvect	; trap occurs
		mov	#hhp5, R0		; set ac0 operand
		ldd	(R0), ac0
		mov	#hhp6, R0		; fspc
hh8:		addd	(R0), ac0		; test instruction
		stfps	R5			; get fps
		mov	#hhdat0, R0		; get the result
		std	ac0, (R0)
		mov	#hhp4, R1		; is it	correct
		mov	#4, R2
hh9:		cmp	(R0)+, (R1)+
		beq	hh10
		jmp	@#hher2
hh10:		sob	R2, hh9
		bis	#100004, R4		; fps correct?
		cmp	R4, R5
		beq	hh11
		jmp	@#hher3

; this is a test of the	r/t algorithm's
; ability to set both n	and z on a - 0 result.
hh11:
		lperr				; set up the loop on error address.
						; set fiv, fiv,	and fd
		mov	#043200, R4
		ldfps	R4
		mov	#hh12, @#$tmp2
		mov	#hhp8, R0		; set ac0 operand
		ldd	(R0), ac0
		mov	#hhp9, R0		; fspc
hh12:		addd	(R0), ac0		; test instruction
		stfps	R5			; get fps
		mov	#hhdat0, R0		; get the result
		std	ac0, (R0)
		mov	#hhp7, R1		; is it	correct
		mov	#4, R2
hh13:		cmp	(R0)+, (R1)+
		beq	hh16
		mov	#hhdat0, R0
		mov	#hhp4, R1
		mov	#4, R2
hh14:		cmp	(R0)+, (R1)+
		beq	hh15
		jmp	@#hher4
hh15:		sob	R2, hh14
		jmp	@#hher5
hh16:		sob	R2, hh13
		bis	#100014, R4		; fps correct?
		cmp	R4, R5
		beq	hh17
		jmp	@#hher6
; test that cc are cleared by r/t
hh17:
		lperr				; set up the loop on error address.
		mov	#00200,	R4		; set fiv, fiv,	and fd
		ldfps	R4
		mov	#hh18, @#$tmp2
		mov	#fpspur, @#fpvect
		mov	#hhp8, R0		; set ac0 operand
		ldd	(R0), ac0
		mov	#hhp8, R0		; fspc
hh18:		addd	(R0), ac0		; test instruction
		stfps	R5			; get fps
		mov	#hhdat0, R0		; get the result
		std	ac0, (R0)
		mov	#hhp10,	R1		; is it	correct
		mov	#4, R2
hh19:		cmp	(R0)+, (R1)+
		beq	hh20
		jmp	@#hher7
hh20:		sob	R2, hh19
		bis	#00000,	R4		; fps correct?
		cmp	R4, R5
		beq	hh21
		jmp	@#hher8
; test that n is set by	r/t
hh21:
		lperr				; set up the loop on error address.
		mov	#3200, R4		; set fiv, fiv,	and fd
		ldfps	R4
		mov	#hh22, @#$tmp2
		mov	#hhp5, R0		; set ac0 operand
		ldd	(R0), ac0
		mov	#hhp5, R0		; fspc
hh22:		addd	(R0), ac0		; test instruction
		stfps	R5			; get fps
		mov	#hhdat0, R0		; get the result
		std	ac0, (R0)
		mov	#hhp11,	R1		; is it	correct
		mov	#4, R2
hh23:		cmp	(R0)+, (R1)+
		beq	hh24
		jmp	@#hher9
hh24:		sob	R2, hh23
		bis	#10, R4
		cmp	R4, R5			; fps correct?
		beq	hh25
		jmp	@#hher10
hh25:		jmp	@#hhdone
hher0:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#hhp1, @#$tmp3
		mov	#hhp0, @#$tmp4
		mov	#hhdat0, @#$tmp5
		mov	#hhp2, @#$tmp6
1$:		emt	+2
		jmp	@#hhdone
hher1:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#hhp1, @#$tmp3
		mov	#hhp0, @#$tmp4
		mov	#hhdat0, @#$tmp5
		mov	#hhp2, @#$tmp6
1$:		emt	+2
		jmp	@#hhdone
hher00:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#hhp1, @#$tmp3
		mov	#hhp0, @#$tmp4
		mov	#hhdat0, @#$tmp5
		mov	#hhp2, @#$tmp6
1$:		emt	+2
		jmp	@#hhdone
hher2:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#hhp6, @#$tmp3
		mov	#hhp5, @#$tmp4
		mov	#hhdat0, @#$tmp5
		mov	#hhp4, @#$tmp6
1$:		emt	+2
		jmp	@#hhdone
hher3:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#hhp6, @#$tmp3
		mov	#hhp5, @#$tmp4
		mov	#hhdat0, @#$tmp5
		mov	#hhp4, @#$tmp6
1$:		emt	+2
		jmp	@#hhdone
hher4:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#hhp9, @#$tmp3
		mov	#hhp8, @#$tmp4
		mov	#hhdat0, @#$tmp5
		mov	#hhp7, @#$tmp6
1$:		emt	+2
		jmp	@#hhdone
hher5:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#hhp9, @#$tmp3
		mov	#hhp8, @#$tmp4
		mov	#hhdat0, @#$tmp5
		mov	#hhp7, @#$tmp6
1$:		emt	+2
		jmp	@#hhdone
hher6:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#hhp9, @#$tmp3
		mov	#hhp8, @#$tmp4
		mov	#hhdat0, @#$tmp5
		mov	#hhp7, @#$tmp6
1$:		emt	+2
		jmp	@#hhdone
hher7:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#hhp8, @#$tmp3
		mov	#hhp8, @#$tmp4
		mov	#hhdat0, @#$tmp5
		mov	#hhp10,	@#$tmp6
1$:		emt	+2
		jmp	@#hhdone
hher8:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#hhp8, @#$tmp3
		mov	#hhp8, @#$tmp4
		mov	#hhdat0, @#$tmp5
		mov	#hhp10,	@#$tmp6
1$:		emt	+2
		jmp	@#hhdone
hher9:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#hhp5, @#$tmp3
		mov	#hhp5, @#$tmp4
		mov	#hhdat0, @#$tmp5
		mov	#hhp11,	@#$tmp6
1$:		emt	+2
		jmp	@#hhdone
hher10:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#hhp5, @#$tmp3
		mov	#hhp5, @#$tmp4
		mov	#hhdat0, @#$tmp5
		mov	#hhp11,	@#$tmp6
1$:		emt	+2
		jmp	@#hhdone
hhtrap:		mov	@#$tmp2, R3		; was the trap to 244
		add	#2, R3			; on the instruction
		cmp	R3, (SP)		; being	tested?
		beq	1$
		jmp	@#fpspur
1$:		mov	(SP), @#$tmp2		; failure of fps interrupt
						; disable bit (fid=1)
		cmp	(SP)+, (SP)+		; to inhibit trap.
		stfps	R1
		mov	R1, @#$tmp3
		stst	R1
		mov	R1, @#$tmp4
2$:		emt	+2
		jmp	@#hhdone
hhdat0:		0
		0
		0
		0
hhp0:		452
		125252
		125252
		125253
hhp1:		252
		125252
		125252
		125252
hhp2:		600				; hhp0 + hhp1 with
		0				; proper normalization
		0
		0
hhp3:		400				; hhp0 + hhp1 with
		0				; bad normalization
		0
		0
hhp4:		0
		0
		0
		0
hhp5:		100200
		0
		0
		0
hhp6:		300
		0
		0
		0
hhp7:		100000				; hhp7 = hhp8 +	hhp9
		0				;     =	hhp5 + hhp6
		0
		0
hhp8:		200
		0
		0
		0
hhp9:		100300
		0
		0
		0
hhp10:		400				; hhp10	= hhp8 + hhp8
		0
		0
		0
hhp11:		100400				; hhp11	= hhp5 + hhp5
		0
		0
		0
hhdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 40 - over/under test
; This is a partial test of the	over/under
; flows. One overflow and two underflow
; conditions are checked. The remaining
; underflow cond. and the remaining overflow
; cond.	will be	checked	later using the
; xxx instruction. Here	each condition tested
; is checked both with traps enabled
; (fiu=1 or fiv=1) and also with traps
; disabled (film) or fiv=0).
;
tst40:		scope
; test overflow	condition with trap disabled fiv=0
gg1:
		lperr				; set up the loop on error address.
		mov	#200, R4		; clear	fiu, fiv, and set fd
		ldfps	R4
		mov	#gg2, @#$tmp2
		mov	#gger0,	@#fpvect
		mov	#ggp5, R0		; set ac0 operand

		ldd	(R0), ac0
		mov	#ggp5, R0		; fsrc
gg2:		addd	(R0), ac0		; test instruction
		stfps	R5			; get fps
		mov	#ggdat0, R0		; get the result
		std	ac0, (R0)
		mov	#ggp6, R1		; is it	correct
		mov	#4, R2
gg3:		cmp	(R0)+, (R1)+
		beq	gg4
		jmp	@#gger1
gg4:		sob	R2, gg3
		bis	#6, R4			; fps correct?
		cmp	R4, R5
		beq	gg5
		jmp	@#gger2
						; test overflow	with traps enabled
						; fiv=1
gg5:
lperr						; set up the loop on error address.
		mov	#1200, R4		; clear	fiu, set fiv, and fd
		ldfps	R4
		mov	#gg6, @#$tmp2
		mov	#gg7, @#fpvect
		mov	#ggp5, R0		; set ac0 operand
		ldd	(R0), ac0
		mov	#ggp5, R0		; fspc
gg6:		addd	(R0), ac0		; test instruction
		cfcc				; no overflow trap occured
		mov	#ggdat0, R0
		std	ac0, (R0)
		jmp	@#gger3
gg7:		mov	@#$tmp2, R3
		add	#2, R3
		cmp	R3, (SP)		; check	stack data
		beq	1$
		jmp	@#fpspur
1$:		mov	(SP), @#$tmp2
		cmp	(SP)+, (SP)+
		stfps	R5
		mov	#ggdat0, R0		; get the result
		std	ac0, (R0)
		mov	#ggp6, R1		; is it	correct
		mov	#4, R2
gg8:		cmp	(R0)+, (R1)+
		beq	gg9
		jmp	@#gger4
gg9:		sob	R2, gg8
		bis	#100006, R4		; exact	zero resulted if overflow
		cmp	R4, R5			; fps correct?,	check fer, fz, fv
		beq	1$
		jmp	@#gger6
1$:		mov	#10, R4
; check	fec
		stst	R5
		cmp	R4, R5
		beq	gg10
		jmp	@#gger5
; check	under flow condition with
; traps	disabled (fiu=0)
gg10:
		lperr				; set up the loop on error address.
		mov	#0200, R4		; set fiu, fiv,	and fd
		ldfps	R4
		mov	#gg11, @#$tmp2
		mov	#gger7,	@#fpvect
		mov	#ggp2, R0		; set ac0 operand
		ldd	(R0), ac0		; fsrc
		mov	#ggp3, R0
gg11:		addd	(R0), ac0		; test instruction
		stfps	R5			; get fps
		mov	#ggdat0, R0		; get the result
		std	ac0, (R0)
		mov	#ggp6, R1		; is it	correct
		mov	#4, R2
gg12:		cmp	(R0)+, (R1)+
		beq	gg13
		jmp	@#gger8
gg13:		sob	R2, gg12
		bis	#4, R4			; fps correct?
		cmp	R4, R5
		beq	gg14
		jmp	@#gger9
		; check	underflow condition with
		; trap enabled (fiu=1)
gg14:
		lperr				; set up the loop on error address.
		mov	#2200, R4		; set fiu, fiv,	and fd
		ldfps	R4
		mov	#gg15, @#$tmp2
		mov	#gg16, @#fpvect
		mov	#ggp2, R0		; set ac0 operand
		ldd	(R0), ac0		; fspc
		mov	#ggp3, R0
gg15:		addd	(R0), ac0		; test instruction
		cfcc
		mov	#ggdat0, R0
		std	ac0, (R0)
		jmp	@#gger10
gg16:		mov	@#$tmp2, R3
		add	#2, R3
		cmp	(SP), R3
		beq	1$
		jmp	@#fpspur
1$:		mov	(SP), @#$tmp2
		cmp	(SP)+, (SP)+
		stfps	R5			; get fps
		mov	#ggdat0, R0		; get the result
		std	ac0, (R0)
		mov	#ggp7, R1		; is it	correct
		mov	#4, R2
gg17:		cmp	(R0)+, (R1)+
		beq	gg18
		jmp	@#gger11
gg18:		sob	R2, gg17
		bis	#100000, R4
		cmp	R4, R5			; fps correct?
		beq	2$
		jmp	@#gger12
2$:
1$:		mov	#12, R4
; check	fec
		stst	R5
		cmp	R4, R5
		beq	gg19
		jmp	@gger13
; check	underflow condition with traps
; disabled (fiu=0)
gg19:
		lperr				; set up the loop on error address.
		mov	#0200, R4		; set fiu, fiv,	and fd
		ldfps	R4
		mov	#gg20, @#$tmp2
		mov	#gger14, @#fpvect
		mov	#ggp2, R0		; set ac0 operand
		ldd	(R0), ac0
		mov	#ggp8, R0		; fspc
gg20:		addd	(R0), ac0		; test instruction
		stfps	R5			; get fps
		mov	#ggdat0, R0		; get the result
		std	ac0, (R0)
		mov	#ggp6, R1		; is it	correct
		mov	#4, R2
gg21:		cmp	(R0)+, (R1)+
		beq	gg22
		jmp	@#gger15
gg22:		sob	R2, gg21
		bis	#4, R4			; fps correct?
		cmp	R4, R5
		beq	gg23
		jmp	@#gger16

; check	underflow condition with trap
; enabled (fiu=1)
gg23:
		lperr				; set up the loop on error address.
		mov	#2200, R4		; set fiu, fiv,	and fd
		ldfps	R4
		mov	#gg24, @#$tmp2
		mov	#gg25, @#fpvect
		mov	#ggp2, R0		; set ac0 operand
		ldd	(R0), ac0
		mov	#ggp8, R0		; fsrc
gg24:		addd	(R0), ac0		; test instruction
		cfcc
		mov	#ggdat0, R0
		std	ac0, (R0)
		jmp	@#gger17
gg25:		mov	@#$tmp2, R0
		add	#2, R0
		cmp	R0, (SP)
		beq	1$
		jmp	@#fpspur
1$:		mov	(SP), @#$tmp2
		cmp	(SP)+, (SP)+
		stfps	R5			; get fps
		mov	#ggdat0, R0		; get the result
		std	ac0, (R0)
		mov	#ggp9, R1		; is it	correct
		mov	#4, R2
gg26:		cmp	(R0)+, (R1)+
		beq	gg27
		jmp	@#gger18
gg27:		sob	R2, gg26
		bis	#100004, R4
		cmp	R4, R5			; fps correct?
		beq	1$
		jmp	gger20
1$:		mov	#12, R4
						; check	fec
		stst	R5
		cmp	R4, R5
		beq	gg28
		jmp	gger19
gg28:		jmp	@#ggdone
gger0:		mov	@#$tmp2, R1
		add	#2, R1
		cmp	R1, (SP)
		beq	10$
5$:		jmp	@#fpspur
10$:
		stst	R1
		cmp	R1, #10
		bne	5$
		cmp	(SP)+, (SP)+
		mov	#ggdat0, R0
		std	ac0, (R0)
		mov	#ggp5, @#$tmp3
		mov	#ggp5, @#$tmp4
		mov	#ggdat0, @#$tmp5
		mov	#ggp6, @#$tmp6
1$:		emt	+1
		jmp	@#ggdone

gger1:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#ggp5, @#$tmp3
		mov	#ggp5, @#$tmp4
		mov	#ggdat0, @#$tmp5
		mov	#ggp6, @#$tmp6
1$:		emt	+2
		jmp	@#ggdone

gger2:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#ggp5, @#$tmp3
		mov	#ggp5, @#$tmp4
		mov	#ggdat0, @#$tmp5
		mov	#ggp6, @#$tmp6
1$:		emt	+2
		jmp	@#ggdone

gger3:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#ggp5, @#$tmp3
		mov	#ggp5, @#$tmp4
		mov	#ggdat0, @#$tmp5
		mov	#ggp6, @#$tmp6
1$:		emt	+2
		jmp	@#ggdone

gger4:		br	gger1

gger5:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#ggp5, @#$tmp3
		mov	#ggp5, @#$tmp4
		mov	#ggdat0, @#$tmp5
		mov	#ggp6, @#$tmp6
1$:		emt	+2
		jmp	@#ggdone

gger6:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#ggp5, @#$tmp3
		mov	#ggp5, @#$tmp4
		mov	#ggdat0, @#$tmp5
		mov	#ggp6, @#$tmp6
1$:		emt	+2
		jmp	@#ggdone

gger7:		mov	@#$tmp2, R1
		add	#2, R1
		cmp	R1, (SP)
		beq	10$
5$:		jmp	@#fpspur
10$:
		stst	R1
		cmp	R1, #12
		bne	5$
		cmp	(SP)+, (SP)+
		mov	#ggdat0, R0
		std	ac0, (R0)
		mov	#ggp3, @#$tmp3
		mov	#ggp2, @#$tmp4
		mov	#ggdat0, @#$tmp5
		mov	#ggp6, @#$tmp6
1$:		emt	+2
		jmp	@#ggdone

gger8:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#ggp3, @#$tmp3
		mov	#ggp2, @#$tmp4
		mov	#ggdat0, @#$tmp5
		mov	#ggp6, @#$tmp6
1$:		emt	+2
		jmp	@#ggdone

gger9:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#ggp3, @#$tmp3
		mov	#ggp2, @#$tmp4

		mov	#ggdat0, @#$tmp5
		mov	#ggp6, @#$tmp6
1$:		emt	+2
		jmp	@#ggdone

gger10:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#ggp3, @#$tmp3
		mov	#ggp2, @#$tmp4
		mov	#ggdat0, @#$tmp5
		mov	#ggp7, @#$tmp6
1$:		emt	+2
		jmp	@#ggdone

gger11:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#ggp3, @#$tmp3
		mov	#ggp2, @#$tmp4
		mov	#ggdat0, @#$tmp5
		mov	#ggp7, @#$tmp6
1$:		emt	+2
		jmp	@#ggdone

gger12:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#ggp3, @#$tmp3
		mov	#ggp2, @#$tmp4
		mov	#ggdat0, @#$tmp5
		mov	#ggp7, @#$tmp6
1$:		emt	+2
		jmp	@#ggdone

gger13:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#ggp3, @#$tmp3
		mov	#ggp2, @#$tmp4
		mov	#ggdat0, @#$tmp5
		mov	#ggp7, @#$tmp6
1$:		emt	+2
		jmp	@#ggdone

gger14:		mov	@#$tmp2, R1
		add	#2, R1
		cmp	R1, (SP)
		beq	10$
5$:		jmp	@#fpspur
10$:
		stst	R1
		cmp	R1, #12
		bne	5$
		cmp	(SP)+, (SP)+
		mov	#ggdat0, R0
		std	ac0, (R0)
		mov	#ggp1, @#$tmp3
		mov	#ggp3, @#$tmp4
		mov	#ggdat0, @#$tmp5
		mov	#ggp6, @#$tmp6
1$:		emt	+2
		jmp	@#ggdone

gger15:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#ggp2, @#$tmp3
		mov	#ggp8, @#$tmp4
		mov	#ggdat0, @#$tmp5
		mov	#ggp6, @#$tmp6
1$:		emt	+2
		jmp	@#ggdone

gger16:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#ggp2, @#$tmp3
		mov	#ggp8, @#$tmp4
		mov	#ggdat0, @#$tmp5
		mov	#ggp6, @#$tmp6
1$:		emt	+2
		jmp	@#ggdone

gger17:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#ggp2, @#$tmp3
		mov	#ggp8, @#$tmp4
		mov	#ggdat0, @#$tmp5
		mov	#ggp9, @#$tmp6
1$:		emt	+2
		jmp	@#ggdone

gger18:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#ggp2, @#$tmp3
		mov	#ggp8, @#$tmp4
		mov	#ggdat0, @#$tmp5
		mov	#ggp9, @#$tmp6
1$:		emt	+2
		jmp	@#ggdone

gger19:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#ggp2, @#$tmp3
		mov	#ggp8, @#$tmp4
		mov	#ggdat0, @#$tmp5
		mov	#ggp9, @#$tmp6

1$:		emt	+2
		jmp	@#ggdone

gger20:
		mov	R5, @#$tmp10
		mov	R4, @#$tmp11
		mov	#ggp2, @#$tmp3
		mov	#ggp8, @#$tmp4
		mov	#ggdat0, @#$tmp5
		mov	#ggp9, @#$tmp6
1$:		emt	+2
		jmp	@#ggdone

ggdat0:		0
		0
		0
		0
ggp1:		300
		0
		0
		0
ggp2:		100200
		0
		0
		0
ggp3:		200
		0
		0
		1
ggp4:		10200
		0
		0
		0
ggp5:		77600				; over flow = ggp5 + ggp5
		0
		0
		0
ggp6:		0				; overflow result
		0				; underflow result
		0				; ggp6 = ggp4 +	ggp5
		0				;     =	ggp3 + ggp2 (fiu=0)
						;     =	ggp3 + ggp1
ggp7:		62400				; ggp7 = ggp3 +	ggp2 (fiu=1)
		0
		0
		0
ggp8:		340
		0
		0
		0
ggp9:		100
		0
		0
		0
ggdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 41 - ldcfd and ldcdf test
; This is a test of ldcfd and ldcdf.
;
tst41:		scope
; test for correct auto	increment constant.
hx1:
		lperr				; set up the loop on error address.
		mov	#200, R4		; set long integer mode
		ldfps	R4
		mov	#hxp1, R0
		ldd	(R0), ac0
		mov	#hxp2, R0
		mov	#hx2, @#$tmp2
hx2:		ldcfd	(R0)+, ac0
		cmp	R0, #hxp2+4		; s R0 correct
		beq	hx3
		jmp	@#hxer1
hx3:
		stfps	R5			; get fps
		mov	#hxdat0, R0
		std	ac0, (R0)		; get ac0
		mov	#hxp7, R1		; see if result	is
		mov	#4, R2			; correct
hx4:		cmp	(R1)+, (R0)+
		beq	hx7
		mov	#hxp2, R1		; did fd get
		mov	#hxdat0, R0		; complimented?
		mov	#4, R2
hx5:		cmp	(R1)+, (R0)+
		beq	hx6
		jmp	@#hxer2
hx6:		sob	R2, hx5
		jmp	@#hxer3
hx7:		sob	R2, hx4
		mov	#200, R4		; fps correct?
		cmp	R4, R5
		beq	hx8
		jmp	@#hxer8

; now test ldcdf
hx8:
		lperr				; set up the loop on error address.
		mov	#200, R4
		ldfps	R4
		mov	#hxp1, R0
		ldd	(R0), ac0
		mov	#hxp2, R0
		mov	#hx9, @#$tmp2
		setf
hx9:		ldcdf	(R0)+, ac0		; test instruction
		cmp	R0, #hxp2+10		; was a	good
		beq	hx10			; constant used
		jmp	@#hxer5			; to increment R0?
hx10:
		stfps	R5
		mov	#hxdat0, R0
		setd
		std	ac0, (R0)		; get result
		mov	#hxp8, R1
		mov	#4, R2
hx11:		cmp	(R1)+, (R0)+		; is it	correct?
		beq	hx14
		mov	#hxp7, R1
		mov	#hxdat0, R0
		mov	#4, R2
hx12:		cmp	(R1)+, (R0)		; did fd fail to get
		beq	hx13			; complimented?
		jmp	@#hxer6
hx13:		sob	R2, hx12
		jmp	@#hxer7
hx14:		sob	R2, hx11
		mov	#0, R4			; fps correct?
		cmp	R4, R5
		beq	hx15
		jmp	@#hxer8

; test gr7 immediate mode constant
hx15:
		lperr				; set up the loop on error address.
		mov	#200, R4
		ldfps	R4			; set fd
		mov	#hx16, @#$tmp2
		mov	#hxer9,	@#errvect
		clr	R1
hx16:		ldcfd	#5201, ac0
hx165:		inc	R1
		inc	R1
		inc	R1
		mov	#cpspur, @#errvect
		cmp	R1, #3			; see if PC was
		beq	hx17			; correct
		jmp	@#hxer10
hx17:
		lperr				; set up the loop on error address.
		mov	#200, R4
		ldfps	R4
		mov	#hx18, @#$tmp2
		mov	#hxp6, R0
		ldd	(R0), ac0
		mov	#cpspur, @#errvect
		mov	#hxp2, R0
hx18:		ldcfd	(R0), ac0
		mov	#hxdat0, R0
		std	ac0, (R0)		; get result.
		mov	#hxp7, R1
		mov	#4, R2
hx19:		cmp	(R0)+, (R1)+		; is result correct?
		beq	hx20
		jmp	@#hxer2
hx20:		sob	R2, hx19

; test ldcfd with negative operand
hx21:
		lperr				; set up the loop on error address.
		mov	#200, R4
		ldfps	R4
		mov	#hx22, @#$tmp2
		mov	#hxp6, R0
		ldd	(R0), ac0
		mov	#hxp4, R0
hx22:		ldcfd	(R0), ac0
		mov	#hxdat0, R0
		std	ac0, (R0)		; get result
		mov	#hxp5, R1
		mov	#4, R2
hx23:		cmp	(R1)+, (R0)+
		beq	hx26
		mov	#hxp7, R1
		mov	#hxdat0, R0
		mov	#4, R2
hx24:		cmp	(R1)+, (R0)+		; was sign incorrect
		beq	hx25
		jmp	@#hxer11
hx25:		sob	R2, hx24
		jmp	@#hxer12
hx26:		sob	R2, hx23

; test ldcfd 0
hx27:
		lperr				; set up the loop on error address.
		mov	#200, R4
		ldfps	R4
		mov	#hxp1, R0
		ldd	(R0), ac0
		addd	(R0), ac0
		mov	#hx28, @#$tmp2
		mov	#hxp1, R0
hx28:		ldcfd	(R0), ac0
		stfps	R5
		mov	#hxdat0, R0
		std	ac0, (R0)		; get result
		mov	#hxp1, R1
		mov	#4, R2
hx29:		cmp	(R1)+, (R0)+		; is it	0?
		beq	hx30
		jmp	@#hxer13
hx30:		sob	R2, hx29
		mov	#204, R4		; fps correct
		cmp	R4, R5
		beq	hx31
		jmp	@#hxer4

; test ldcfd 0
hx31:
		lperr				; set up the loop on error address.
		mov	#200, R4
		ldfps	R4
		mov	#hxp6, R0
		ldd	(R0), ac0
		mov	#hx32, @#$tmp2
		mov	#hxp1, R0
hx32:		ldcfd	(R0), ac0
		stfps	R5
		mov	#hxdat0, R0
		std	ac0, (R0)		; get result
		mov	#hxp1, R1
		mov	#4, R2
hx33:		cmp	(R1)+, (R0)+		; is it	zero?
		beq	hx34
		jmp	@#hxer13
hx34:		sob	R2, hx33
		mov	#204, R4		; fps correct?
		cmp	R4, R5
		beq	hx35
		jmp	@#hxer4
hx35:		jmp	@#hxdone

; R0 incorrect
hxer1:		mov	#hxp2+4, @#$tmp4
		mov	R0, @#$tmp3
1$:		emt	+2
		jmp	@#hxdone

hxer5:		mov	#hxp2+10, @#$tmp4
		mov	R0, @#$tmp3
1$:		emt	+2
		jmp	@#hxdone

; report bad data
hxer2:		mov	#hxp2, @#$tmp5
		mov	#hxp7, @#$tmp7
hxer22:		mov	#hxdat0, @#$tmp6
1$:		emt	+2
		jmp	@#hxdone

hxer3:		mov	#hxp2, @#$tmp5
		mov	#hxp7, @#$tmp7
hxer33:		mov	#hxdat0, @#$tmp6
1$:		emt	+2
		jmp	@#hxdone

hxer4:		mov	R5, @#$tmp3
		mov	R4, @#$tmp4
1$:		emt	+2
		jmp	@#hxdone

hxer8:		mov	R5, @#$tmp3
		mov	R4, @#$tmp4
1$:		emt	+2
		jmp	@#hxdone
hxer6:		mov	#hxp2, @#$tmp5
		mov	#hxp8, @#$tmp7
hxer66:		mov	#hxdat0, @#$tmp6
1$:		emt	+2
		jmp	@#hxdone

hxer7:		mov	#hxp2, @#$tmp5
		mov	#hxp8, @#$tmp7
		mov	#hxdat0, @#$tmp6
1$:		emt	+2
		jmp	@#hxdone

hxer9:		bit	#1, (SP)		; see if it
		bne	1$			; an odd address
		cmp	#hx165,	(SP)
		beq	1$
		jmp	@#cpspur

1$:		mov	(SP), @#$tmp2
		cmp	(SP)+, (SP)+
2$:		emt	+2
		jmp	@#hxdone

hxer10:		sub	#3, R1
		asl	R1
		mov	#hx165,	R2
		mov	R2, @#$tmp4
		sub	R1, R2
		mov	R2, @#$tmp3
1$:		emt	+2
		jmp	@#hxdone

hxer11:		mov	#hxp4, @#$tmp5
		mov	#hxp5, @#$tmp7
		jmp	@#hxer22
hxer12:		mov	#hxp4, @#$tmp5
		mov	#hxp5, @#$tmp7
		mov	#hxdat0, @#$tmp6
1$:		emt	+2
		jmp	@#hxdone

hxer13:		mov	#hxp1, @#$tmp5
		mov	#hxp1, @#$tmp7
		jmp	@#hxer22

hxdat0:		0
		0
		0
		0
hxp1:		0
		0
		0
		0
hxp2:		577
		177776
		177777
		177776
hxp3:		5201
		0
		0
		0
hxp4:		100577
		177776
		177777
		177776
hxp5:		100577
		177776
		0
		0
hxp6:		252
		125252
		125252
		125252
hxp7:		577
		177776
		0
		0
hxp8:		577
		177777
		0
		0
hxdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 42 - cmpd test
; This is a test of the	cmpd instruction. Note that a subroutine
; is used to set up operands, execute the instruction and check	the
; results.
;
tst42:		scope
; test the cmpd	instruction with (fsrc=ac=0)
aaa1:
		lperr				; set up the loop on error address.
		jsr	pc, @#cmpsub
1$:		.word	0, 0, 0, 0		; ac0
2$:		.word	0, 0, 0, 0		; fsrc
3$:		200				; fps before execution
		204				; fps after execution
		200				; error	fps
4$:		emt	+2			; fps error

; test cmpd with (ac=0)	and fsrc positive.
aaa2:
		lperr				; set up the loop on error address.
		jsr	pc, @#cmpsub
1$:		.word	0, 0, 0, 0		; ac
2$:		25252				; fsrc
		52525
		125252
		52525
3$:		200				; fps before execution
		200				; fps after execution
		210				; error	fps
4$:		emt	+2

; test cmpd with (ac=0)	and fsrc negative
aaa3:
		lperr				; set up the loop on error address.
		jsr	pc, @#cmpsub
1$:		.word	0, 0, 0, 0		; ac
2$:		125252				; fsrc
		125252
		52525
		125252
3$:		200				; fps before execution
		210				; fps after execution
		200				; error	fps
4$:		emt	+2

; test cmpd with (fsrc=0) and ac positive
aaa4:
		lperr				; set up the loop on error address.
		jsr	pc, @#cmpsub
1$:		25252				; ac
		52525
		125252
		52525
2$:		.word	0, 0, 0, 0		; fsrc
3$:		200				; fps before execution
		210				; fps after execution
		200				; error	fps
4$:		emt	+2

; test cmpd with (fsrc=0) and ac negative
aaa5:
		lperr				; set up the loop on error address.
		jsr	pc, @#cmpsub
1$:		125252				; ac
		125252
		52525
		125252
2$:		.word	0, 0, 0, 0		; fsrc
3$:		200				; fps before execution
		200				; fps after execution
		210				; error	fps
4$:		emt	+2

; test cmpd with ac positive and fsrc negative
aaa6:
		lperr				; set up the loop on error address.
		jsr	pc, @#cmpsub
1$:		52525				; ac
		125252
		52525
		125252
2$:		125252				; fsrc
		52525
		125252
		52525
3$:		200				; fps before execution
		210				; fps after execution
		200				; error	fps
4$:		emt	+2

; test cmpd with ac negative and fsrc positive
aaa7:
		lperr				; set up the loop on error address.
		jsr	pc, @#cmpsub
1$:		125252				; ac
		52525
		125252
		52525
2$:		52525				; fsrc
		125252
		52525
		125252
3$:		200				; fps before execution
		200				; fps after execution
		210				; error	fps
4$:		emt	+2

; test cmpd with ac positive and fsrc positive
; and eac less than efsrc.
aaa8:
		lperr				; set up the loop on error address.
		jsr	pc, @#cmpsub
1$:		12345				; ac
		67654
		32101
		23456
2$:		23456				; fsrc
		76543
		21012
		34567
3$:		200				; fps before execution
		200				; fps after execution
		210				; error	fps
4$:		emt	+2

; test cmpd with ac positive, fsrc positive and	eac greater than efsrc
aaa9:
		lperr				; set up the loop on error address.
		jsr	pc, @#cmpsub
1$:		45676				; ac
		54321
		12345
		67654
2$:		34567				; fsrc
		65432
		101234
		56765
3$:		200				; fps before execution
		210				; fps after execution
		200				; error	fps
4$:		emt	+2

; test cmpd with ac positive, fsrc positive and	ac equal to fsrc
aaa10:
		lperr				; set up the loop on error address.
		jsr	pc, @#cmpsub
1$:		12345				; ac
		67012
		34567
		012345
2$:		12345				; fsrc
		67012
		34567
		012345
3$:		200				; fps before execution
		204				; fps after execution
		200				; error	fps
4$:		emt	+2

; test cmpd with ac positive, fsrc positive. eac equal to efsrc,
; and fsrc greater than	ac.
aaa11:
		lperr				; set up the looo on error address.
		jsr	pc, @#cmpsub
1$:		12345				; ac
		67012
		34567
		012345
2$:		12345				; fsrc
		70123
		45670
		123456
3$:		200				; fps before execution
		200				; fps after execution
		210				; error	fps
4$:		emt	+2

; test cmpd with ac positive. fsrc positive. eac equal to efsrc,
; and ac greater than fsrc.
aaa12:
		lperr				; set up the loop on error address.
		jsr	pc, @#cmpsub
1$:		54321				; ac
		76543
		21076
		54321
2$:		54321				; fsrc
		65432
		107654
		32107
3$:		200				; fps before execution
		210				; after	execution
		200				; error	fps
4$:		emt	+2

; test cmpd with ac negative, fsrc negative, eac equal to efsrc,
; and ac greater than fsrc
aaa13:
		lperr				; set up the loop on error address.
		jsr	pc, @#cmpsub
1$:		112345				; ac
		43210
		76543
		21076
2$:		112345				; fsrc
		54321
		07654
		32107
3$:		200				; fps before execution
		210				; fps after execution
		200				; error	fps
4$:		emt	+2

		jmp	@#aaadone		; finished cmpd	test.

; this subroutine, cmpsub, is called to	set up,	execute
; and check the	results	of a cmpd instruction.
; it is	called thus:
;
;		jsr	pc, @#cmpsub
;	acarg:	.word	x, x, x, x		; ac operand
;	fsrcarg:.word	x, x, x.x		; fsrc operand
;	fpsb:	.word	x			; fps before execution
;	fpsa:	.word	x			; fps after execution
;	fpse:	.word	x			; error	fps
;	err:	error	x			; fps error
;	cont:					; return address
;
; The operands are set up (using acc for the ac	operand). Then
; fpsb is loaded into the fps. The instruction,	cmpd, is executed.
; After	the execution the fps is checked against fpsa. If it is	a match
; then there was no error and control is returned to cont. If
; the fps is incorrect it is compared with fpse	in an attempt to analyse
; the failure. If the fps is the same as fpse then control is
; returned to the error	call at	location err. If the fps was
; not correct but didn't match fpse a general error is reported
; and control is passed	to cont.
;
cmpsub:		mov	(SP)+, R1		; pick up a winter to the
						; arguments.
		mov	20(R1),	R0		; get the fps before execution.
		ldfps	R0			; load it into the fps.
		mov	#1$, @#$tmp2		; save address of cmpd instruction.
		mov	R1, R0			; get address of ac operand.
		ldd	(R0), ac0		; load ac0 operand
		mov	R1, R0			; compute fsrc operand
		add	#10, R0			; address
		nop				; for scoping.
1$:		cmpd	(R0), ac0		; execute the test instruction.
		stfps	R5			; save fps after instruction.
		mov	22(R1),	R4		; get expected fps.
						; if incorrect set up for
		mov	R1, @#$tmp3		; an error call.
		mov	R1, @#$tmp4
		add	#10, @#$tmp4
		mov	R5, @#$tmp5
		mov	R4, @#$tmp6
		cmp	R4, R5			; was fps correct?
		beq	3$			; branch if yes.
		cmp	24(R1),	R5		; was the fps the same
						; as the expected incorrect fps?
		bne	2$			; branch if no match.
		add	#26, R1			; if the expected incorrect
						; fps matched the resultant fps
		jmp	(R1)			; return to the	error call
						; in the calling routine.
2$:		emt	+2			; otherwise report incorrect fps
		br	5$
3$:		mov	#cmptmp, R0		; if fps was correct make sure
		std	ac0, (R0)		; ac0 was not affected by cmpd.
		mov	R1, R2
		mov	#4, R3
4$:		cmp	(R2)+, (R0)+
		bne	6$
		sob	R3, 4$
5$:		jmp	30(R1)			; return
6$:						; report ac0 modified by cmpd
		mov	R1, @#$tmp3
		mov	#cmptmp, @#$tmp4
7$:		emt	+2
		br	5$			; return

cmptmp:		.word	0, 0, 0, 0
aaadone:
		rsetup
;_____________________________________________________________________________
;
; TEST 43 - divd with (fsrc=0) and (but	fd) test
; This is a test of the	divd instruction with a
; zero divisor.	The condition is checked with both
; trap enabled and traps disabled.
;
tst43:		scope
; first	test divd with (fsrc=ac=0) and traps disabled.
		lperr				; set up the loop on error address.
bbb0:		mov	#40200,	R4		; set up fps
						; with interrupts
						; disabled.
		ldfps	R4
		mov	#bbber1, @#fpvect	; set up for any fp interrupts.
		mov	#bbb1, @#$tmp2
		mov	#bbbp1,	R0		; set up ac0=0
		ldd	(R0), ac0
		mov	#bbbp1,	R1		; fsrc=0

bbb1:		divd	(R1), ac0		; test instruction
		stfps	R5			; get fps
		stst	R3			; get fec
		mov	#140204, R4		; expected fps.
		cmp	R4, R5			; is fps correct.
		bne	bbber2			; if incorrect branch.
		mov	#4, R2			; expected fec.
		cmp	R2, R3			; is fec correct?
		bne	bbber3			; if incorrect branch.

; test divd with (fsrc=0) and traps disabled.
bbb2:
		lperr				; set up the loop on error address.
		mov	#40200,	R4		; load fps with	traps disabled.
		ldfps	R4
		mov	#bbb3, @#$tmp2
		mov	#bbbp2,	R0		; set up ac0 operand (non zero).
		ldd	(R0), ac0
		mov	#bbbp1,	R0		; fsrc=0

bbb3:		divd	(R0), ac0
		stfps	R5			; get fps.
		stst	R3			; get fec.
		mov	#140200, R4		; expected fps.
		cmp	R4, R5			; is fps correct?
		bne	bbber2			; if incorrect branch.
		mov	#4, R2			; expected fec.
		cmp	R2, R3			; was fec correct?
		bne	bbber3			; if incorrect branch.

; test divd with (fsrc=0) and traps enabled.
bbb4:
		lperr				; set up the loop on error address.
		mov	#200, R4		; set up fps. trap enabled.
		ldfps	R4
		mov	#bbb5, @#$tmp2
		mov	#bbbp2,	R0		; set up ac0 operand (non zero).
		ldd	(R0), ac0
		mov	#bbb6, @#fpvect		; set up for the expected interrupt.
		mov	#bbbp1,	R0		; fsrc=0

bbb5:		divd	(R0), ac0		; test instruction (should result in trap).
		cfcc
		br	bbber4			; go report failure, no	trap. ...

bbb6:		cmp	#bbb5+2, (SP)		; trap to here when the	division by 0
						; occurs. first	see if the address of
						; the trap is 2+the address of the test
						; divd instruction.
		beq	1$
		jmp	@#fpspur		; if not then report an	unexpected
						; fp trap.
1$:		stfps	R5			; get fps.
		stst	R3			; get fec.
		cmp	(SP)+, (SP)+		; reset	the stack.
		mov	#100200, R4		; expected fps.
		cmp	R4, R5			; is fps correct?
		bne	bbber2			; if incorrect branch.
		mov	#4, R2			; expected fec.
		cmp	R2, R3			; is fec correct?
		bne	bbber3			; if incorrect branch.
		jmp	@#bbbdone		; otherwise go to next test.

; trap here if an unexpected interrupt occurs.
bbber1:		add	#2, @#$tmp2		; see if the interrupt occurred
						; during the execution of the divd
						; instruction being tested.
		cmp	(SP), @#$tmp2
		beq	1$
		jmp	@#fpspur		; if not report	unexpected fp trap.
1$:		cmp	(SP)+, (SP)+		; reset	the stack.
		stst	R3			; get fec.
		stfps	R5			; get fps.
		mov	#4, @#$tmp3		; expected fec.
		mov	R3, @#$tmp4
		mov	R5, @#$tmp5
		mov	R0, @#$tmp7
		mov	#140200, @#$tmp6
2$:		emt	+2
						; with traps disabled.
		jmp	@#bbbdone

; report fps incorrect.
bbber2:		mov	R5, @#$tmp4
		mov	R4, @#$tmp5
		mov	R0, @#$tmp6
		mov	R1, @#$tmp7
1$:		emt	+2
		jmp	@#bbbdone

; report fec incorrect.
bbber3:		mov	R3, @#$tmp4
		mov	R2, @#$tmp3
		mov	R0, @#$tmp6
		mov	R1, @#$tmp7
1$:		emt	+2
		jmp	@#bbbdone

; report no trap occurred after	trying to divide
; by zero with all traps enabled.
bbber4:		stst	R3			; get fec.
		stfps	R5			; get fps.
		mov	#4, @#$tmp4
		mov	R3, @#$tmp3
		mov	R5, @#$tmp5
		mov	#100200, @#$tmp6
		mov	R0, @#$tmp7
		mov	R1, @#$tmp10
1$:		emt	+2
		br	bbbdone

bbbp1:		.word	0, 0, 0, 0
bbbp2:		.word	12345, 54321, 23456, 76543
bbbdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 44 - divf test
; This is a test of the	divf instruction. Note that a subroutine is
; used to set up the operands, execute the instruction and check the
; results.
;
tst44:		scope
; check	divf with (ac=0).
ccc1:
		lperr				; set up the loop on error address.
		jsr	pc, divfsub
1$:		.word	0, 0			; ac
2$:		.word	12345, 67012		; fsrc
3$:		.word	0, 0			; res
4$:		0				; fps before execution.
		4				; fps after execution
5$:		.word	12345, 67012		; error	result
6$:		emt	+2

; test divf with ac positive, fsrc positive and	in round mode.
ccc2:
		lperr				; set up the loop on error address.
		jsr	pc, @#divfsub
1$:		.word	65652, 125252		; ac
2$:		.word	65600, 0		; fsrc
3$:		.word	40252, 125252		; res
4$:		3000				; fps before execution.
		3000				; fps after execution.
5$:		.word	40052, 125252		; error	result.
6$:		emt	+2

; test divf with ac positive, fsrc positive.
ccc3:
		lperr				; set up the loop on error address.
		jsr	pc, divfsub
1$:		.word	76400, 0		; ac
2$:		.word	76400, 0		; fsrc
3$:		.word	40200, 0		; res
4$:		1000				; fps before execution.
		1000				; fps after execution.
5$:		.word	140200,	0		; error	res.
6$:		emt	+2			; sign bad

; test divf with both operands positive.
ccc4:
		lperr				; set up the loop on error address.
		jsr	pc, @#divfsub
1$:		.word	56777, 177777		; ac
2$:		.word	54200, 0		; fsrc
3$:		.word	42777, 177777		; res
4$:		0				; fps before execution.
		0				; fps after execution.
5$:		.word	2000, 2000		; error	res.
6$:		emt	+2

; test the divf	instruction:
ccc5:
		lperr				; set up the loop on error address.
		jsr	pc, @#divfsub
1$:		.word	12377, 177777		; ac
2$:		.word	12300, 0		; fsrc
3$:		.word	40252, 125252		; res
4$:		0				; fps before execution.
		0				; fps after execution.
5$:		.word	-1, -1			; error	res.
6$:		emt	+2

; test divide algorithm, test round constant.
ccc6:
		lperr				; set up the loop on error address.
		jsr	pc, @#divfsub
1$:		.word	64600, 1		; ac
2$:		.word	66600, 0		; fsrc
3$:		.word	36200, 1		; res
4$:		0				; fps before execution.
		0				; fps after execution.
5$:		.word	3000, 3000		; error	res.
6$:		emt	+2

; test divf.
ccc7:
		lperr				; set up the loop on error address.
		jsr	pc, @#divfsub
1$:		.word	34577, 177776		; ac
2$:		.word	23400, 0		; fsrc
3$:		.word	51377, 177776		; res
4$:		17				; fps before execution.
		0				; fps after execution.
5$:		.word	3400, 3400		; error	res.
6$:		emt	+2

; divf test.
ccc8:
		lperr				; set up the loop on error address.
		jsr	pc, @#divfsub
1$:		.word	67652, 125252		; ac
2$:		.word	56500, 0		; fsrc
3$:		.word	51343, 107070		; res
4$:		0				; fps before execution.
		0				; fps after execution.
5$:		.word	51543, 107070		; error	res.
6$:		emt	+2			; didn't increment the exponent
						; after	divid normalization.

; divf with ac negative. fsrc negative.
ccc9:
		lperr				; set up the loop on error address.
		jsr	pc, @#divfsub
1$:		.word	140400,	0		; ac
2$:		.word	140500,	0		; fsrc
3$:		.word	040052,	125253		; res
4$:		0				; fps before execution.
		0				; fps after execution.
5$:		.word	140052,	125253		; error	res.
6$:		emt	+2			; bad sign.

; divf with ac negative	and fsrc positive.
ccc10:
		lperr				; set up the loop on error address.
		jsr	pc, @#divfsub
1$:		.word	160077,	0		; ac
2$:		.word	40277, 0		; fsrc
3$:		.word	160000,	0		; res
4$:		7				; fps before execution.
		10				; fps after execution.
5$:		.word	60000, 0		; error	res.
6$:		emt	+2			; bad sign.

; divf with ac positive	and fsrc negative.
ccc11:
		lperr				; set up the loop on error address.
		jsr	pc, @#divfsub
1$:		.word	40400, 0		; ac
2$:		.word	140500,	0		; fsrc
3$:		.word	140052,	125253		; res
4$:		17				; fps before execution.
		10				; fps after execution.
5$:		.word	40052, 125253		; error	res.
6$:		emt	+2			; bad sign.

; test divf both operands positive and truncate	mode.
ccc12:
		lperr				; set up the loop on error address.
		jsr	pc, @#divfsub
1$:		.word	60100, 1		; ac
2$:		.word	40300, 0		; fsrc
3$:		.word	60000, 0		; res
4$:		52				; fps before execution.
		40				; fps after execution.
5$:		.word	60000, 1		; error	res.
6$:		emt	+2			; truncation error

; divf with positive operands and round	mode.
ccc13:
		lperr				; set up the loop on error address.
		jsr	pc, divfsub
1$:		.word	60100, 1		; ac
2$:		.word	40300, 0		; fsrc
3$:		.word	60000, 1		; res
4$:		5				; fps before execution.
		0				; fps after execution.
5$:		.word	60000, 0		; error	res.
6$:		emt	+2			; round	error.
		jmp	@#cccdone		; go to	next test.

; This subroutine, divfsub, is called to set up, execute
; and check the	result of a divf instruction. It is called thus:
;
;		jsr	pc, @#divfsub
;	acarg:	.word	x, x			; ac operand
;	fsrcarg:.word	x, x			; fsrc operand
;	res:	.word	x, x			; expected result
;	fpsb:	.word	x			; fps before execution
;	fpsa:	.word	x			; fps after execution
;	erres:	.word	x, x			; error	result
;	err:	error	x			; result error
;	cont:					; return address

; The operands are set up (using ac0 for the ac	operand). Then
; fpsb is loaded into the fps. The instruction,	divf is	executed.
; After	the execution the result is checked against the
; expected correct result, res.	If it is correct then the fps
; is checked with the expected correct fps, fpsa. If the fps was
; incorrect then it is reported. If the	result was incorrect it
; is compared with erres in an attempt to analyse the error. If
; the incorrect	result matched erres then control is passed to
; the error call at err. If the	incorrect result did not match erres
; then the failure is reported in divfsub and control is passed	to
; cont.	If no errors are detected then divfsub returns control
; to cont.
;
divfsub:	mov	(SP)+, R1		; get a	pointer	to the arguments.
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	R1, R0			; load the ac operand.
		ldd	(R0), ac0
		mov	14(R1),	R0		; load the fps
		ldfps	R0
		mov	#1$, @#$tmp2
		mov	R1, R0
		add	#4, R0			; establish a pointer to fsrc.
1$:		divf	(R0), ac0		; test instruction.
		stfps	R4			; get the fps.
		mov	#200, R0		; set fd mode
		ldfps	R0
		mov	#divft,	R0		; get the result of the	divf.
		std	ac0, (R0)
		mov	R1, R2			; save the data	in case	of error.
		mov	R2, @#$tmp3
		add	#4, R2
		mov	R2, @#$tmp4
		add	#4, R2
		mov	R2, @#$tmp5
		mov	#divft,	@#$tmp6
		mov	R4, @#$tmp7
		mov	16(R1),	@#$tmp10
		cmp	(R0), 10(R1)		; is the result	correct?
		bne	10$			; if incorrect branch.
		cmp	2(R0), 12(R1)
		bne	10$
		cmp	16(R1),	R4		; is fps correct?
		bne	15$			; if incorrect branch.
		jmp	26(R1)			; if no	errors occurred	return.
10$:		cmp	(R0), 20(R1)		; does the incorrect result
		bne	11$			; match	the anticipated	incorrect result.
		cmp	2(R0), 22(R1)
		bne	11$			; branch if no.
		mov	R1, R2			; it matched so	return to the error
						; report at the	calling	routine.
		add	#24, R2
		jmp	(R2)
11$:						; report result	incorrect.
12$:		emt	+2
13$:		jmp	26(R1)
15$:						; report fps incorrect.
16$:		emt	+2
		br	13$

divft:		.word	0, 0, 0, 0
cccdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 45 - divd test
; This is a test of the	divd instruction. Note that a subroutine is
; used to set up the operands, execute the instruction and check the results.
;
tst45:		scope
; divd test with positive operands and in round	mode.
ddd1:
		lperr				; set up the loop on error address.
		jsr	pc, @#divdsub
1$:		.word	34277, 0, 0, 0		; ac
2$:		.word	40277, 0, 0, 0		; fsrc
3$:		.word	34200, 0, 0, 0		; res
4$:		200				; fps before execution.
		200				; fps after execution.
5$:		.word	-1, -1,	-1, -1		; error	res.
6$:		emt	+2

; divd with ac negative	and fsrc positive in truncate mode.
ddd2:
		lperr				; set up the loop on error address.
		jsr	pc, @#divdsub
1$:		.word	134277,	0, 0, 0		; ac
2$:		.word	40277, 0, 0, 0		; fsrc
3$:		.word	134200,	0, 0, 0		; res
4$:		207				; fps before execution.
		210				; fps after execution.
5$:		.word	-1, -1,	-1, -1		; error	result.
6$:		emt	+2

; divd test with operands both negative	and in truncate	mode.
ddd3:
		lperr				; set up the loop on error address.
		jsr	pc, divdsub
1$:		.word	134300,	0, 0, 1		; ac
2$:		.word	140300,	0, 0, 0		; fsrc
3$:		.word	34200, 0, 0, 0		; res
4$:		250				; fps before execution.
		240				; fps after execution.
5$:		.word	34200, 0, 0, 1		; error	res.
6$:		emt	+2			; truncation error.

; divd with ac positive	and fsrc negative in round mode.
ddd4:
		lperr				; set up the loop on error address.
		jsr	pc, @#divdsub
1$:		.word	34300, 0, 0, 1		; ac
2$:		.word	140300,	0, 0, 0		; fsrc
3$:		.word	134200,	0, 0, 1		; res
4$:		207				; fps before execution.
		210				; fps after execution.
5$:		.word	134200,	0, 0, 0		; error	res.
6$:		emt	+2			; round	error.

; divd test.
odds:
		lperr				; set up the loop on error address.
		jsr	pc, @#divdsub
1$:		.word	100400,	0, 0, 0		; ac
2$:		.word	500, 0,	0, 0		; fsrc
3$:		.word	140052,	125252		; res
		.word	125252,	125252
4$:		7647				; fps before execution.
		7650				; fps after execution.
5$:		.word	-1, -1,	-1, -1		; error	res.
6$:		emt	+2

; divd test with ac positive and fsrc negative in round	mode.
ddd6:
		lperr				; set up the loop on error address.
		jsr	pc, @#divdsub
1$:		.word	400, 0,	0, 0		; ac
2$:		.word	100500,	0, 0, 0		; fsrc
3$:		.word	140052,	125252		; res
		.word	125252,	125253
4$:		7707				; fps before execution.
		7710				; fps after execution.
5$:		.word	-1, -1,	-1, -1		; error	res.

6$:		emt	+2

; divd test.
ddd7:
		lperr				; set up the loop on error address.
		jsr	pc, @#divdsub
1$:		.word	170360,	170360		; ac
		.word	170360,	170360
2$:		.word	170360,	170360		; fsrc
		.word	170360,	170360
3$:		.word	40200, 0, 0, 0		; res
4$:		7717				; fps before execution.
		7700				; fps after execution.
5$:		.word	-1, -1,	-1, -1		; error	res.
6$:		emt	+2
		jmp	@#ddddone		; go to	next test.

; This subroutine. divdsub, is called to set up, execute
; and check the	result of a divd instruction. It is called thus:
;
;		jsr	pc, @#divdsub
;	acarc:	.word	x, x, x, x		; ac operand
;	fsrcarg:.word	x, x, x, x		; fsrc operand
;	res:	.word	x, x, x, x		; expected result
;	fpsb:	.word	x			; fps before execution
;	fpsa:	.word	x			; fps after execution
;	erres:	.word	x, x, x, x		; error	result
;	err:	error	x			; result error
;	cont:					; return address
;
; The operands are set up (using ac0 for the ac	operand). Then
; fpsb is loaded into the fps. The instruction,	divd is	executed.
; After	the execution the result is checked against the
; expected correct result, res.	If it is correct then the fps
; is checked with the expected correct fps, fpsa. If the fps was
; incorrect then it is reported. If the	result was incorrect it
; is compared with erres in an attempt to analyse the error. If
; the incorrect	result matched erres then control is passed to
; the error call at err. If the	incorrect result did not match erres
; then the failure is reported in divdsub and control is passed	to
; cont.	If no errors are detected then divdsub returns control
; to cont.
;
divdsub:	mov	(SP)+, R1		; get a	pointer	to the arguments.
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	R1, R0			; set up the ac0 operand.
		ldd	(R0), ac0
		mov	30(R1),	R0		; load the fps.
		ldfps	R0
		mov	#1$, @#$tmp2
		mov	R1, R0			; establish a pointer to fsrc.
		add	#10, R0
1$:		divd	(R0), ac0		; execute the test instruction.
		stfps	R4			; get the fps.
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	#divdt,	R0		; get the result.
		std	ac0, (R0)
		mov	R1, R2			; save data in case of error.
		mov	R2, @#$tmp3
		add	#10, R2
		mov	R2, @#$tmp4
		add	#10, R2
		mov	R2, @#$tmp5
		mov	#divdt,	@#$tmp6
		mov	R4, @#$tmp7
		mov	32(R1),	@#$tmp10
		mov	R1, R2			; check	the result.
		add	#20, R2
		mov	#divdt,	R3
		mov	#4, R5
2$:		cmp	(R2)+, (R3)+
		bne	10$			; branch if result incorrect.
		sob	R5, 2$
		cmp	32(R1),	R4		; is fps correct?
		bne	15$			; branch if incorrect.
		jmp	46(R1)			; return.
10$:		mov	R1, R2			; was incorrect	result anticipated?
		add	#34, R2
		mov	#divdt,	R3
		mov	#4, R5
11$:		cmp	(R2)+, (R3)+
		bne	12$			; branch if no.
		sob	R5, 11$
		mov	R1, R2			; if the incorrect result was
		add	#44, R2			; anticipated return to	the
						; error	report in the calling
		jmp	(R2)			; routine.
12$:						; report result	incorrect.
13$:		emt	+2
14$:		jmp	46(R1)
15$:						; report fps incorrect.
16$:		emt	+2
		br	14$

divdt:		.word	0, 0, 0, 0
ddddone:
		rsetup
;_____________________________________________________________________________
;
; TEST 46 - mulf test
; This is a test of the	mulf instruction. It makes use of a subroutine
; to set up the	operands, execute the mulf instruction and check the
; results.
;
tst46:		scope
; mulf with (fsrc=ac=0)
eee1:
		lperr				; set up the loop on error address.
		jsr	pc, @#mulfsub
1$:		.word	0, 0			; ac
2$:		.word	0, 0			; fsrc
3$:		.word	0, 0			; res
4$:		7517				; fps before execution.
		7504				; fps after execution.
5$:		.word	-1, -1
6$:		emt	+2

; mulf with (fsrc=0).
eee2:
		lperr				; set up the loop on error address.
		jsr	pc, @#mulfsub
1$:		.word	71625, 34435		; ac
2$:		.word	0, 0			; fsrc
3$:		.word	0, 0			; res
4$:		13				; fps before execution.
		4				; fps after execution.
5$:		.word	-1, -1			; error	res.

6$:		emt	+2

; mulf with (ac=0)
eee3:
		lperr				; set up the loop on error address.
		jsr	pc, @#mulfsub
1$:		.word	0, 0			; ac
2$:		.word	071625,	153443		; fsrc
3$:		.word	0, 0			; res
4$:		7500				; fps before execution.
		7504				; fps after execution.
5$:		.word	-1, -1			; error	res.
6$:		emt	+2

; mulf with ac positive	and fsrc positive in round mode.
eee4:
		lperr				; set up the loop on error address.
		jsr	pc, @#mulfsub
1$:		.word	40200, 0		; ac
2$:		.word	40177, -1		; fsrc
3$:		.word	40177, -1		; res
4$:		17				; fps before execution.
		0				; fps after execution.
5$:		.word	140177,	-1		; error	res.
6$:		emt	+2			; bad sign.

; mulf with ac positive	and fsrc positive in truncate mode.
eee5:
		lperr				; set up the loop on error address.
		jsr	pc, mulfsub
1$:		.word	40177, -1		; ac
2$:		.word	40200, 0		; fsrc
3$:		.word	40177, -1		; res
4$:		40				; fps before execution.
		40				; fps after execution.
5$:		.word	37777, -1		; error	res.
6$:		emt	+2			; st 252 to 044	into 444 (but y62)
						; mul. normalization failure.

; mulf with both operands positive normalize test.
eee6:
		lperr				; set up the loop on error address.
		jsr	pc, @#mulfsub
1$:		.word	40100, 0		; ac
2$:		.word	40100, 0		; fsrc
3$:		.word	40020, 0		; res
4$:		12				; fps before execution.
		0				; fps after execution.
5$:		.word	42040, 0		; error	res.
6$:		emt	+2			; st 252 to 444	into 042 (but y62)
						; mul. normalization failure.

; mulf with both operands positive in round mode.
eee7:
		lperr				; set up the loop on error address.
		jsr	pc, @#mulfsub
1$:		.word	17500, 0		; ac
2$:		.word	23652, 125252		; fsrc
3$:		.word	3177, -1		; res
4$:		7417				; fps before execution.
		7400				; fps after execution.
5$:		.word	-1, -1
6$:		emt	+2

; mulf with ac positive	and fsrc negative in round mode.
eeeb:
		lperr				; set up the loop on error address.
		jsr	pc, @#mulfsub
1$:		.word	40342, 0		; ac
2$:		.word	176542,	0		; fsrc
3$:		.word	176707,	102000		; res
4$:		7				; fps before execution.
		10				; fps after execution.
7$:		.word	76507, 102000		; error	res.
6$:		emt	+2			; bad sign.

; mulf with ac negative	and fsrc positive in round mode.
eee9:
		lperr				; set up the loop on error address.
		jsr	pc, @#mulfsub
1$:		.word	140200,	0		; ac
2$:		.word	7417, 7417		; fsrc
3$:		.word	107417,	7417		; res
4$:		0				; fps before execution.
		10				; fps after execution.
5$:		.word	7417, 7417		; error	res.
6$:		emt	+2			; bad sign.

; mulf with both operands negative in round mode.
eee10:
		lperr				; set up the loop on error address.
		jsr	pc, @#mulfsub
1$:		.word	144600,	0		; ac
2$:		.word	154000,	0		; fsrc
3$:		.word	60400, 0		; res
4$:		17				; fps before execution.
		0				; fps after execution.
5$:		.word	160400,	0		; error	res.
6$:		emt	+2			; bad sign.

; mulf both operands negative in round mode.
eee11:
		lperr				; set up the loop on error address.
		jsr	pc, @#mulfsub
1$:		.word	140300,	0		; ac
2$:		.word	160000,	1		; fsrc
3$:		.word	60100, 2		; res
4$:		10				; fps before execution.
		0				; fps after execution.
5$:		.word	60100, 1		; error	res.
6$:		emt	+2			; round	failure.

; mulf with ac positive	and fsrc negative in truncate mode.
eee12:
		lperr				; set up the loop on error address.
		jsr	pc, @#mulfsub
1$:		.word	60000, 1		; ac
2$:		.word	140300,	0		; fsrc
3$:		.word	160100,	1		; res
4$:		7547				; fps before execution.
		7550				; fps after execution.
5$:		.word	160100,	1		; error	res.
6$:		emt	+2			; truncation error.

; mulf with ac positive	and fsrc positive in round mode.
eee13:
		lperr				; set up the loop on error address.
		jsr	pc, @#mulfsub
1$:		.word	40277, 0		; ac
2$:		.word	60000, 1		; fsrc
3$:		.word	60077, 1		; res
4$:		14				; fps before execution.
		0				; fps after execution.
5$:		.word	60077, 2		; error	res.
6$:		emt	+2			; round	failure. constant bad.
		jmp	eeedone			; go to	the next test.

; This subroutine, mulfsub, is called to set up, execute
; and check the	result of a mulf instruction. it is called thus:
;
;		jsr	pc, @#mulfsub
;	acarg:	.word	x, x			; ac operand
;	fsrcarg:.word	x, x			; fsrc operand
;	res:	.word	x, x			; expected result
;	fpsb:	.word	x			; fps before execution
;	fpsa:	.word	x			; fps after execution
;	erres:	.word	x, x			; error	result
;	err:	error	x			; result error
;	cont:					; return address
;
; The operands are set up (using ac0 for the ac	operand). Then
; fpsb is loaded into the fps. The instruction,	mulf is	executed.
; After	the execution the result is checked against the
; expected correct result, res.	If it is correct then the fps
; is checked with the expected correct fps, fpsa. If the fps was
; incorrect then it is reported. If the	result was incorrect it
; is compared with erres in an attempt to analyse the error. If
; the incorrect	result matched erres then control is passed to
; the error call at err. If the	incorrect result did not match erres
; then the failure is reported in mulfsub and control is passed	to
; cont.	If no errors are detected then mulfsub returns control
; to cont.
;
mulfsub:	mov	(SP)+, R1		; get a	pointer	to the arguments.
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	R1, R0			; load the ac operand.
		ldd	(R0), ac0
		mov	14(R1),	R0		; load the fps
		ldfps	R0
		mov	#1$, @#$tmp2
		mov	R1, R0
		add	#4, R0			; establish a pointer to fsrc.
1$:		mulf (R0), ac0			; test instruction.
		stfps	R4			; get the fps.
		mov	#200, R0		; set fd mode
		ldfps	R0
		mov	#mulft,	R0		; get the result of the	mulf.
		std	ac0, (R0)
		mov	R1, R2			; save the data	in case	of error.
		mov	R2, @#$tmp3
		add	#4, R2
		mov	R2, @#$tmp4
		add	#4, R2
		mov	R2, @#$tmp5
		mov	#mulft,	@#$tmp6
		mov	R4, @#$tmp7
		mov	16(R1),	@#$tmp10
		cmp	(R0), 10(R1)		; is the result	correct?
		bne	10$			; if incorrect branch.
		cmp	2(R0), 12(R1)
		bne	10$
		cmp	16(R1),	R4		; is fps correct?
		bne	15$			; if incorrect branch.
		jmp	26(R1)			; if no	errors occurred	return.

10$:		cmp	(R0), 20(R1)		; does the incorrect result
		bne	11$			; match	the anticipated	incorrect result.
		cmp	2(R0), 22(R1)
		bne	11$			; branch if no.
		mov	R1, R2			; it matched so	return to the error
						; report at the	calling	routine.
		add	#24, R2
		jmp	(R2)
11$:						; report result	incorrect.
12$:		emt	+2
13$:		jmp	26(R1)
15$:						; report fps incorrect.
16$:		emt	+2
		br	13$

mulft:		.word	0, 0, 0, 0
eeedone:
		rsetup
;_____________________________________________________________________________
;
; TEST 47 - muld test
; This is a test of the	muld instruction. Note that a subroutine is
; used to set up the operands. Execute the muld	instruction and
; check	the results.
;
tst47:		scope
; muld test with ac positive and fsrc positive.
fff1:
		lperr				; set up the loop on error address.
		jsr	pc, @#muldsub
1$:		.word	40200, 0, 0, 0		; ac
2$:		.word	23777, -1, -1, -1	; fsrc
3$:		.word	23777, -1, -1, -1	; res
4$:		217				; fps before execution.
		200				; fps after execution.
5$:		.word	23777, -1, 0, 0		; error	res.
6$:		emt	+2			; bad constant used in algorithm
						; used 24 instead of 56.

; muld test with both operands positive	truncation test.
fff2:
		lperr				; set up the loop on error address.
		jsr	pc, muldsub
1$:		.word	65400, 0, 0, 1		; ac
2$:		.word	37577, -1, -1, -2	; fsrc
3$:		.word	64777, -1, -1, -1	; res
4$:		247				; fps before execution.
		240				; fps after execution.
5$:		.word	65000, 0, 0, 0		; error	res.
6$:		emt	+2			; truncation error.

; muld test with both operands negative	in round mode.
fffj:
		lperr				; set up the loop on error address.
		jsr	pc, @#muldsub
1$:		.word	137577,	-1, -1,	-2	; ac
2$:		.word	165400,	0, 0, 1		; fsrc
3$:		.word	65000, 0, 0, 0		; res
4$:		7717				; fps before execution.
		7700				; fps after execution.
5$:		.word	64777, -1, -1, -1	; error	res.
6$:		emt	+2			; round	error.

; muld test with ac positive and fsrc negative in round	mode.
fff4:
		lperr				; set up the loop on error address.
		jsr	pc, @#muldsub
1$:		.word	17500, 0, 0, 0		; ac
2$:		.word	123652,	125252		; fsrc
		.word	125252,	125252
3$:		.word	103177,	-1, -1,	-1	; res
4$:		200				; fps before execution.
		210				; fps after execution.
5$:		.word	103200,	0, 0, 0		; error	res.
6$:		emt	+2			; round	error (bad constant).
		jmp	fffdone

; This subroutine, muldsub, is called to set up. execute
; and check the	result of a muld instruction. It is called thus:
;
;		jsr	pc, @#muldsub
;	acarg:	.word	x, x, x, x		; ac operand
;	fsrcarg:.word	x, x, x, x		; fsrc operand
;	res:	.word	x, x, x, x		; expected result
;	fpsb:	.word	x			; fps before execution
;	fpsa:	.word	x			; fps after execution
;	erres:	.word	x, x, x, x		; error	result
;	err:	error	x			; result error
;	cont:					; return address
;
; The operands are set up (using ac0 for the ac	operand). Then
; fpsb is loaded into the fps. The instruction,	muld is	executed.
; After	the execution the result is checked against the
; expected correct result, res.	If it is correct then the fps
; is checked with the expected correct fps, fpsa. If the fps was
; incorrect then it is reported. If the	result was incorrect it
; is compared with erres in an attempt to analyse the error. If
; the incorrect	result matched erres then control is passed to
; the error call at err. If the	incorrect result did not match erres
; then the failure is reported in muldsub and control is passed	to
; cont.	If no errors are detected then muldsub returns control
; to cont.
;
muldsub:	mov	(SP)+, R1		; get a	pointer	to the arguments.
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	R1, R0			; set up the ac0 operand.
		ldd	(R0), ac0
		mov	30(R1),	R0		; load the fps.
		ldfps	R0
		mov	#1$, @#$tmp2
		mov	R1, R0			; establish a pointer to fsrc.
		add	#10, R0
1$:		muld	(R0), ac0		; execute the test instruction.
		stfps	R4			; get the fps.
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	#muldt,	R0		; get the result.
		std	ac0, (R0)
		mov	R1, R2			; save data in case of error.
		mov	R2, @#$tmp3
		add	#10, R2
		mov	R2, @#$tmp4
		add	#10, R2
		mov	R2, @#$tmp5
		mov	#muldt,	@#$tmp6
		mov	R4, @#$tmp7
		mov	32(R1),	@#$tmp10
		mov	R1, R2			; check	the result.
		add	#20, R2
		mov	#muldt,	R3
		mov	#4, R5
2$:		cmp	(R2)+, (R3)+
		bne	10$			; branch if result incorrect.
		sob	R5, 2$
		cmp	32(R1),	R4		; is fps correct?
		bne	15$			; branch if incorrect.
		jmp	46(R1)			; return.
10$:		mov	R1, R2			; was incorrect	result anticipated?
		add	#34, R2
		mov	#muldt,	R3
		mov	#4, R5
11$:		cmp	(R2)+, (R3)+
		bne	12$			; branch if no.
		sob	R5, 11$
		mov	R1, R2			; if the incorrect result was
		add	#44, R2			; anticipated return to	the
						; error	report in the calling
		jmp	(R2)			; routine.
12$:						; report result	incorrect.
13$:		emt	+2
14$:		jmp	46(R1)
15$:						; report fps incorrect.
16$:		emt	+2
		br	14$

muldt:		.word	0, 0, 0, 0
fffdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 50 - under/over flow, using mulf	with traps disabled, test
; This is a test of the	overflow and underflow conditions using
; the mulf instruction with traps disabled. Note that a	subroutine
; is used to set up the	operands, execute the mulf instruction and
; check	the results.
;
tst50:		scope
; underflow, with exponent of result = -129
iii1:
		lperr				; set up the loop on error address.
		jsr	pc, @#ovunfnt
1$:		.word	20200, 0		; ac
2$:		.word	20000, 0		; fsrc
3$:		.word	0, 0			; res
4$:		.word	-1, -1			; error	res.
5$:		0				; fps before execution.
		4				; fps after execution.
6$:		12				; fec
		-1				; flag
7$:		emt	+2			; st 331 to 155	into 115 (but fiu)
		br	8$
		emt	+2
8$:

; underflow, with exponent of result = -193
iii2:
		lperr				; set up the loop on error address.
		jsr	pc, @#ovunfnt
1$:		.word	10200, 0		; ac
2$:		.word	10000, 0		; fsrc
3$:		.word	0, 0			; res
4$:		.word	10000, 0		; error	res.
5$:		5013				; fps before execution.
		5004				; fps after execution.
6$:		12				; fec
		-1				; flag
7$:		emt	+2			; setting fiuv or fiv causes trap
						; with fiu clear.
		br	8$
		emt	+2
8$:

; overflow, exponent of	result = 128
iii3:
		lperr				; set up the loop on error address.
		jsr	pc, @#ovunfnt
1$:		.word	60200, 0		; ac
2$:		.word	60000, 0		; fsrc
3$:		.word	0, 0			; res
4$:		.word	60000, 0		; error	res.
5$:		0				; fps before execution.
		6				; fps after execution.
6$:		10				; fec
		0				; flag
7$:		emt	+2			; st 333 to 136	into 116 (but fiv).
		br	8$
		emt	+2
8$:

; overflow, exponent of	result = 130
iii4:
		lperr				; set up the loop on error address.
		jsr	pc, @#ovunfnt
1$:		.word	60200, 0		; ac
2$:		.word	60200, 0		; fsrc
3$:		.word	0, 0			; res
4$:		.word	-1, -1			; error	res.
5$:		6011				; fps before execution.
		6006				; fps after execution.
6$:		10				; fec
		0				; flag
7$:		emt	+2			; setting fiuv or fiu with
						; fiv clear causes trap.
		br	8$
		emt	+2
8$:		jmp	iiidone			; go to	next test.

; This subroutine, ovunfnt, is used to set up the operands, execute
; the mulf instruction and check the results of	an instruction with
; operands which should	result in either overflow or underflow.	A call
; to it	is made	thus:
;
;	acarg:	.word	x, x			; ac operand
;	fsrcarg:.word	x, x			; fsrc operand
;	res:	.word	x, x			; expected result
;	erres:	.word	x, x			; error	result
;	fpsb:	.word	x			; fps before execution
;	fpsa:	.word	x			; fps after execution
;	fec:	.word	x			; expected fec
;	flag:	.word	x			; 0/-1,	over/under flow	flag
;	err1:	error	x			; trap error.
;		br	cont
;	err2:	error	x			; data,	result error
;	cont:					; return address
;
; The operands are set up (using ac0 as	the accumulator). Then
; the mulf instruction is executed. If no trap occurs then the
; result is checked against res. If the	result is correct then the fps is
; compared with	fpsa if	this too is correct ovunfnt returns control
; to the calling routine at cont. If the fps is	bad ovunfnt
; reports this failure and then	returns	to cont. If the	result of the
; mulf is incorrect, the incorrect result is compared with the
; anticipated failing data pattern, erres. If the failure in
; the result was anticipated correctly to be erres then	ovunfnt
; will transfer	control	to the error call at err2. Otherwise the
; result was incorrect but was not anticipated and ovunfnt will
; report the failure after which control will be passed	to cont.
; If a trap occurs (it should not) then	ovunfnt	will read the fec.
; should the fec match the anticipated fec ovunfnt will
; store	all data and transfer control to the error call	at err1. If the
; fec is not the same as the anticipated fec ovunfnt will report
; the error and	return to cont.	Note that ovunfnt uses the flag
; to tell whether or not these particular operands will	result in
; underflow (flag=-1) or overflow (flag=0).
;
ovunfnt:	mov	(SP)+, R1		; get a	pointer	to the arguments.
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	R1, R0			; load ac0, operand.
		ldd	(R0), ac0
		mov	R1, R2			; save the data	patterns in case of
		mov	R2, @#$tmp3		; error.
		add	#4, R2
		mov	R2, @#$tmp4
		add	#4, R2
		mov	R2, @#$tmp5
		mov	22(R1),	@#$tmp10
		mov	#ovfntt, @#$tmp6
		mov	20(R1),	R0		; load the fps.
		ldfps	R0
		mov	#1$, @#$tmp2
		mov	#25$, @#fpvect		; set up the fp	trap vector in case
						; of error.
		mov	R1, R0			; compute the address of fsrc.
		add	#4, R0
1$:		mulf	(R0), ac0		; test instruction.
2$:		stfps	R4			; get fps.
		stst	R5			; get fec.
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	#ovfntt, R0		; get the result.
		std	ac0, (R0)
		mov	R4, @#$tmp7
		mov	R5, @#$tmp11
		mov	#ovfntt, R0		; check	the result.
		mov	R1, R2
		add	#10, R2
		mov	#2, R3
3$:		cmp	(R0)+, (R2)+
		bne	15$			; branch if incorrect.
		sob	R3, 3$
		cmp	22(R1),	R4		; was fps correct?
		bne	10$			; branch if fps	is incorrect.
4$:		jmp	36(R1)			; return, test completed.

; report incorrect fps.
10$:		tst	26(R1)			; was the result over or under flow?
		bne	12$			; branch if underflow.
						; report fps bad after overflow.
11$:		emt	+2
		br	4$
12$:						; report fps bad after underflow.
13$:		emt	+2
		br	4$

; result incorrect.
15$:		mov	#ovfntt, R0		; see if failure is anticipated
		mov	R1, R2			; failure.
		add	#14, R2
		mov	#2, R3
16$:		cmp	(R0)+, (R2)+
		bne	17$			; branch if not	anticipated.
		sob	R3, 16$
		mov	R1, R2			; error	was anticipated	so return
		add	#34, R2			; to the error report in the calling
		mov	R2, @#$tmp2		; routine.
		jmp	(R2)

17$:		tst	26(R1)			; result was not anticipated
						; so error must	be reported here.
						; first	see if arguments should
						; have resulted	in overflow or under
						; flow by looking at the flag.
		bne	19$			; branch if underflow expected.
						; report result	incorrect, expecting
18$:		emt	+2			; overflow.
		br	4$
19$:						; report result	incorrect, expecting
20$:		emt	+2			; underflow.
		br	4$

; if an	fp trap	occurs come here.
25$:		mov	(SP), R2		; get address of trap.
		cmp	#2$, R2			; was the trap during the mulf instruction?
		beq	26$			; branch if yes.
		jmp	@#fpspur		; otherwise go report a	spurious
						; fp trap.
26$:		cmp	(SP)+, (SP)+		; reset	the stack.
		mov	R2, @#$tmp2		; save data for	error report.
		stfps	R4			; get fps.
		stst	R5			; get fec.
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	#ovfntt, R0		; get the result.
		std	ac0, (R0)
		mov	R5, @#$tmp11
		cmp	R5, 24(R1)		; was the fec anticipated?
		bne	27$			; branch if not	anticipated.
		mov	R1, R2			; error	was anticipated	so
		add	#30, R2			; return to the	error report of	the
						; calling routine.
		jmp	(R2)

27$:		tst	26(R1)			; the errw was not anticipated so
						; it must be reported here. first see if expected
						; overflow or under flow.
		bne	29$			; branch if expecting underflow
						; report trapped on overflow with fiv=0
28$:		emt	+2
		jmp	36(R1)

29$:						; report trapped on under flow with fiu=0
30$:		emt	+2
		jmp	36(R1)

ovfntt:		.word	0, 0, 0, 0
iiidone:
		rsetup
;_____________________________________________________________________________
;
; TEST 51 - under/over flow, using muld	with trap disabled, test
; This is a test of the	overflow and underflow conditions that can
; arrise using the muld	instruction with traps disabled. A subroutine is
; used to set up the operands. Execute the muld	instruction and
; check	the results.
;
tst51:		scope
; underflow, exponent of result=-129
jjj1:
		lperr				; set up the loop on error address.
		jsr	pc, @#ovundn7
1$:		.word	20200, 0		; ac
		.word	127272,	0
2$:		.word	20000, 0, 0, 0		; fsrc
3$:		.word	0, 0, 0, 0		; res
4$:		.word	0, 0			; error	res.
		.word	127272,	0
5$:		200				; fps before execution.
		204				; fps after execution.
6$:		12				; fec
		-1				; flag
7$:		emt	+2			; st 331 to 155	into 115 (but fiu)
		br	8$
		emt	+2			; st 115 (but fd)
8$:

; underflow, exponent of result	= -193
jjj2:
		lperr				; set up the loop on error address.
		jsr	pc, @#ovundnt
1$:		.word	10200, 0		; ac
		.word	123456,	0
2$:		.word	10000, 0, 0, 0		; fsrc
3$:		.word	0, 0, 0, 0		; res
4$:		.word	0, 0, 123456, 0		; error	res
5$:		5213				; fps before execution.
		5204				; fps after execution.
6$:		12				; fec
		-1				; flag
7$:		emt	+2			; setting fiuv or fiv bad.
		br	8$
		emt	+2			; st 115 (but fd)
8$:

; overflow, exponent of	result = 128
jjj3:
		lperr				; set up the loop on error address.
		jsr	pc, @#ovundnt
1$:		.word	60200, 0		; ac
		.word	65432, 0
2$:		.word	60000, 0, 0, 0		; fsrc
3$:		.word	0, 0, 0, 0		; res
4$:		.word	0, 0, 65432, 0		; error	res.
5$:		200				; fps before execution.
		206				; fps after execution.
6$:		10				; fec
		0				; flag
7$:		emt	+2			; st 333 to 136	into 116 (but fiv)
		br	8$
		emt	+2			; st 116 (but fd)
8$:

; overflow, exponent of	result = 130
jjj4:
		lperr				; set up the loop on error address.
		jsr	pc, @#ovundnt
1$:		.word	60200, 0		; ac
		.word	125252,	0
2$:		.word	60200, 0, 0, 0		; fsrc
3$:		.word	0, 0, 0, 0		; res
4$:		.word	0, 0, 125252, 0		; error	res.
5$:		6211				; fps before execution.
		6206				; fps after execution.
6$:		10				; fec
		0				; flag
7$:		emt	+2			; setting fiuv or fiv bad.
		br	8$
		emt	+2			; st 116 (but fd)
8$:		jmp	@#jjjdone		; go to	next test.

; This subroutine, ovundnt, is used to set up the operands, execute
; the muld instruction and check the results of	an instruction with
; operands which should	result in either overflow or underflow.	A call
; to it	is made	thus:
;
;	acarg:	.word	x, x, x, x		; ac operand
;	fsrcarg:.word	x, x, x, x		; fsrc operand
;	res:	.word	x, x, x, x		; expected result
;	erres:	.word	x, x, x, x		; error	result
;	fpsb:	.word	x			; fps before execution
;	fpsa:	.word	x			; fps after execution
;	fec:	.word	x			; expected fec
;	flag:	.word	x			; 0/-1,	over/under flow	flag
;	err1:	error	x			; trap error.
;		br	cont
;	err2:	error	x			; data,	result error
;	cont:					; return address
;
; The operands are set up (using ac0 as	the accumulator). Then
; the muld instruction is executed. If no trap occurs then the
; result is checked against res. If the	result is correct then the fps is
; compared with	fpsa if	this too is correct ovundnt returns control
; to the calling routine at cont. If the fps is	bad ovundnt
; reports this failure and then	returns	to cont. If the	result of the
; muld is incorrect. The incorrect result is compared with the
; anticipated failing data pattern, erres. If the failure in
; the result was anticipated correctly to be erres then	ovundnt
; will transfer	control	to the error call at err2. Otherwise the
; result was incorrect but was not anticipated and ovundnt will
; report the failure after which control will be passed	to cont.
; If a trap occurs (it should not) then	ovundnt	will read the fec.
; Should the fec match the anticipated fec ovundnt will
; store	all data and transfer control to the error call	at err1. If the
; fec is not the same as the anticipated fec ovundnt will report
; the error and	return to cont.	Note that ovundnt uses the flag
; to tell whether or not these particular operands will	result in
; underflow (flag=-1) or overflow (flag=0).
;
ovundnt:	mov	(SP)+, R1		; get a	pointer	to the arguments.
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	R1, R0			; load ac0, operand.
		ldd	(R0), ac0
		mov	R1, R2			; save the data	patterns in case of
		mov	R2, @#$tmp3		; error.
		add	#10, R2
		mov	R2, @#$tmp4
		add	#10, R2
		mov	R2, @#$tmp5
		mov	42(R1),	@#$tmp10
		mov	#ovdntt, @#$tmp6
		mov	40(R1),	R0		; load the fps.
		ldfps	R0
		mov	#1$, @#$tmp2
		mov	#25$, @#fpvect		; set up the fp	trap vector in case
						; of error.
		mov	R1, R0			; compute the address of fsrc.
		add	#10, R0
1$:		muld	(R0), ac0		; test instruction.

2$:		stfps	R4			; get fps.
		stst	R5			; get fec.
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	#ovdntt, R0		; get the result.
		std	ac0, (R0)
		mov	R4, @#$tmp7
		mov	R5, @#$tmp11
		mov	#ovdntt, R0		; check	the result.
		mov	R1, R2
		add	#20, R2
		mov	#4, R3
3$:		cmp	(R0)+, (R2)+
		bne	15$			; branch if incorrect.
		sob	R3, 3$
		cmp	42(R1),	R4		; was fps correct?
		bne	10$			; branch if fps	is incorrect.
4$:		jmp	56(R1)			; return. test completed.

; report incorrect fps.
10$:		tst	46(R1)			; was the result over or under flow?
		bne	12$			; branch if underflow.
						; report fps bad after overflow.
11$:		emt	+2
		br	4$
12$:						; report fps bad after underflow.
13$:		emt	+2
		br	4$

; result incorrect.
15$:		mov	#ovdntt, R0		; see if failure is anticipated
		mov	R1, R2			; failure.
		add	#30, R2
		mov	#4, R3
16$:		cmp	(R0)+, (R2)+
		bne	17$			; branch if not	anticipated.
		sob	R3, 16$
		mov	R1, R2			; error	was anticipated	so return
		add	#54, R2			; to the error report in the calling
		mov	R2, @#$tmp2		; routine.
		jmp	(R2)

17$:		tst	46(R1)			; result was not anticipated
						; so error must	be reported here.
						; first	see if arguments should
						; have resulted	in overflow or under
						; flow by looking at the flag.
		bne	19$			; branch if underflow expected.
						; report result	incorrect. expecting
18$:		emt	+2			; overflow.
		br	4$
19$:						; report result	incorrect, expecting
20$:		emt	+2			; underflow.
		br	4$

; if an	fp trap	occurs come here.
25$:		mov	(SP), R2		; get address of trap.
		cmp	#2$, R2			; was the trap during the mulf instruction?
		beq	26$			; branch if yes.
		jmp	@#fpspur		; otherwise go report a	spurious
						; fp trap.
26$:		cmp	(SP)+, (SP)+		; reset	the stack.
		mov	R2, @#$tmp2		; save data for	error report.
		stfps	R4			; get fps.
		stst	R5			; get fec.
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	#ovdntt, R0		; get the result.
		std	ac0, (R0)
		mov	R5, @#$tmp11
		cmp	R5, 44(R1)		; was the fec anticipated?
		bne	27$			; branch if not	anticipated.
		mov	R1, R2			; error	was anticipated	so
		add	#50, R2			; return to the	error report of	the
						; calling routine.
		jmp	(R2)

27$:		tst	26(R1)			; the error was	not anticipated	so
						; it must be reported here. first see if expected
						; overflow or under flow.
		bne	29$			; branch if expecting underflow
						; report trapped on overflow with fiv=0
28$:		emt	+2
		jmp	56(R1)
29$:						; report trapped on under flow with fiu=0
30$:		emt	+2
		jmp	56(R1)

ovdntt:		.word	0, 0, 0, 0
jjjdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 52 - under/over flow, using mulf	with traps enabled, test
; This is a test of the	underflow and overflow
; conditions that can occur using the mulf instruction.
; A subroutine is called to set	up the operands,
; execute the mulf instruction and check
; the results. Here the	particular interrupt,
; either overflow or underflow,	is enabled so a	trap should
; occur.
;
tst52:		scope
; underflow, exponent of result	= -129
kkk1:
		lperr				; set up the loop on error address.
		jsr	pc, @#ovunft
1$:		.word	20123, 45676		; ac
2$:		.word	20200, 0		; fsrc
3$:		.word	123, 45676		; res
4$:		.word	-1, -1			; error	res.
5$:		2000				; fps before execution.
		102004				; fps after execution.
6$:		12				; fec
		-1				; flag
7$:		emt	+2			; st 331 (but fiu) no trap.
		br	8$
		emt	+2
8$:

; underflow, exponent of the result = -193
kkk3:
		lperr				; set up the loop on error address.
		jsr	pc, @#ovunft
1$:		.word	10127, 127272		; ac
2$:		.word	10200, 0		; fsrc
3$:		.word	60127, 127272		; res
4$:		.word	-1, -1			; error	res.
5$:		7017				; fps before execution.
		107000				; fps after execution.
6$:		12				; fec
		-1
7$:		emt	+2			; st 331 (but fiu) no trap.
		br	8$
		emt	+2
8$:

; overflow, exponent of	the result = 128
kkk4:
		lperr				; set up the loop on error address.
		jsr	pc, @#ovunft
1$:		.word	60252, 125252		; ac
2$:		.word	60000, 0		; fsrc
3$:		.word	000052,	125252		; res
4$:		.word	-1, -1			; error	res.
5$:		1000				; fps before execution.
		101006				; fps after execution.
6$:		10				; fec
		0				; flag
7$:		emt	+2			; st 333 (but fiv) no trap
		br	8$
		emt	+2
8$:

; overflow, exponent of	result = 130
kkk5:
		lperr				; set up the loop on error address.
		jsr	pc, @#ovunft
1$:		.word	60345, 67654		; ac
2$:		.word	60200, 0		; fsrc
3$:		.word	345, 67654		; res
4$:		.word	-1, -1			; error	res.
5$:		7015				; fps before execution.
		107002				; fps after execution.
6$:		10				; fec
		0				; flag
7$:		emt	+2			; st 133 (but fiv) no trap
		br	8$
		emt	+2
8$:		jmp	kkkdone

; This subroutine, ovunft, is used to set up the operands, execute
; the mulf instruction and check the results of	an instruction with
; operands which should	result in either overflow or underflow.	A call
; to it	is made	thus:
;
;	acarg:	.word	x, x			; ac operand
;	fsrcarg:.word	x, x			; fsrc operand
;	res:	.word	x, x			; expected result
;	erres:	.word	x, x			; error	result
;	fpsb:	.word	x			; fps before execution
;	fpsa:	.word	x			; fps after execution
;	eec:	.word	x			; expected fec
;	flag:	.word	x			; 0/-1,	over/under flow	flag
;	err1:	error	x			; trap error.
;		br	cont
;	err2:	error	x			; data,	result error
;	cont:					; return address
;
; The operands are set up (using ac0 as	the accumulator). Then
; the mulf instruction is executed. If the trap	occurs then the
; result is checked against res. If the	result is correct then the fps is
; compared with	fpsa if	this too is correct ovunft returns control
; to the calling routine at cont. If the fps is	bad ovunft
; reports this failure and then	returns	to cont. The fec is treated
; in the same way. If the result of the
; mulf is incorrect. The incorrect result is compared with the
; anticipated failing data pattern, erres. If the failure in
; the result was anticipated correctly to be erres then	ovunft
; will transfer	control	to the error call at err2. Otherwise the
; result was incorrect but was not anticipated and ovunft will
; report the failure after which control will be passed	to cont.
; If no	trap occurs control is passed to err1.
; Note that ovunfnt uses the flag
; to tell whether or not these particular operands will	result in
; underflow (flag=-1) or overflow (flag=0).
;
ovunft:		mov	(SP)+, R1		; get a	pointer	to the arguments.
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	R1, R0			; load ac0, operand.
		ldd	(R0), ac0
		mov	R1, R2			; save the data	patterns in case of
		mov	R2, @#$tmp3		; error.
		add	#4, R2
		mov	R2, @#$tmp4
		add	#4, R2
		mov	R2, @#$tmp5
		mov	22(R1),	@#$tmp10
		mov	#ovftt,	@#$tmp6
		mov	20(R1),	R0		; load the fps.
		ldfps	R0
		mov	#1$, @#$tmp2
		mov	#50$, @#fpvect		; set up the fp	trap vector in case
						; of error
		mov	R1, R0			; compute the address of fsrc.
		add	#4, R0

1$:		mulf	(R0), ac0		; test instruction. should cause trap.
2$:		cfcc
		jmp	@#25$			; failure, no trap.

50$:		mov	(SP), R2		; trap to here and see if the PC of the
		cmp	R2, #2$			; trap was that	of the mulf instruction.
		beq	51$			; branch if yes.
		jmp	@#fpspur		; otherwise report spurious fp error.

51$:		cmp	(SP)+, (SP)+		; reset	the stack
		stfps	R4			; get fps.
		stst	R5			; get fec.
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	#ovftt,	R0		; get the result.
		std	ac0, (R0)
		mov	R4, @#$tmp7
		mov	R5, @#$tmp11
		mov	#ovftt,	R0		; check	the result.
		mov	R1, R2
		add	#10, R2
		mov	#2, R3
3$:		cmp	(R0)+, (R2)+
		bne	15$			; branch if incorrect.
		sob	R3, 3$
		cmp	22(R1),	R4		; was fps correct?
		bne	10$			; branch if fps	is incorrect.
		cmp	24(R1),	R5		; is fec correct?
		bne	5$			; if incorrect branch.
4$:		jmp	36(R1)			; return, test completed.
						; report incorrect fec.
5$:		tst	26(R1)			; was the result overflow or underflow?
		bne	7$			; branch if underflow.
						; report bad fec on expected overflow.
6$:		emt	+2
		br	4$
7$:						; report bad fec on expected underflow.
8$:		emt	+2
		br	4$

; report incorrect fps.
10$:		tst	26(R1)			; was the result over or under flow?
		bne	12$			; branch if underflow.
						; report fps bad after overflow.
11$:		emt	+2
		br	4$
12$:						; report fps bad after underflow.
13$:		emt	+2
		br	4$

; result incorrect.
15$:		mov	#ovftt,	R0		; see if failure is anticipated
		mov	R1, R2			; failure.
		add	#14, R2
		mov	#2, R3
16$:		cmp	(R0)+, (R2)+
		bne	17$			; branch if not	anticipated.
		sob	R3, 16$
		mov	R1, R2			; error	was anticipated	so return
		add	#34, R2			; to the error report in the calling
		mov	R2, @#$tmp2		; routine.
		jmp	(R2)

17$:		tst	26(R1)			; result was n anticipated
						; so error must	be reported here.
						; first	see if arguments should
						; have resulted	in overflow or under
						; flow by looking at the flag.
		bne	19$			; branch if underflow expected.

						; report result	incorrect, expecting
18$:		emt	+2			; overflow.
		br	4$
19$:						; report result	incorrect. expecting
20$:		emt	+2			; underflow.
		br	4$

; if no	fp trap	occurs come here.
25$:		stfps	R4			; get fps.
		stst	R5			; get fec.
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	#ovftt,	R0		; get the result.
		std	ac0, (R0)
		mov	R4, @#$tmp7
		mov	R5, @#$tmp11
		mov	R1, R2			; error	was anticipated	so
		add	#30, R2			; return to the	error report of	the
						; calling routine.
		jmp	(R2)

ovftt:		.word	0, 0, 0, 0
kkkdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 53 - under/over flow, using muld	with traps enabled, test
; This is a test of the	over flow and under flow conditions using the
; muld instruction with	traps enabled. A subroutine is used to set up
; the operands,	execute	the muld instruction and check the results.
;
tst53:		scope
; underflow, exponent of result	= -129
lll1:
		lperr				; set up the loop on error address.
		jsr	pc, @#ovundt
1$:		.word	20052, 125252		; ac
		.word	125252,	125252
2$:		.word	20300, 0, 0, 0		; fsrc
3$:		.word	177, -1, -1, -1		; res
4$:		.word	177, -1			; error	res.
		.word	125252,	125252
5$:		2200				; fps before execution.
		102204				; fps after execution.
6$:		12				; fec
		-1				; flag
7$:		emt	+2			; st 331 (but fiu) no trap.
		br	8$
		emt	+2			; st 155 (but fd)
8$:
; underflow, exponent of the result = -193
lll2:
		lperr				; set up the loop on error address.
		jsr	pc, @#ovundt
1$:		.word	10327, 127272		; ac
		.word	36363, 45454
2$:		.word	10000, 0, 0, 0		; fsrc
3$:		.word	60127, 127272		; res
		.word	36363, 45454
4$:		.word	-1, -1,	-1, -1		; error	res.
5$:		7217				; fps before execution.
		107200				; fps after execution.
6$:		12				; fec
		-1				; flag
7$:		emt	+2			; st 137 (but fiu) no trap.
		br	8$
		emt	+2
8$:

; overflow. exponent of	the result = 128
lll3:
		lperr				; set up the loop on error address.
		jsr	pc, @#ovundt
1$:		.word	60252, 125252		; ac
		.word	125252,	125252		; fsrc
2$:		.word	160100,	0, 0, 0		; fsrc
3$:		.word	100177,	-1, -1,	-1	; res
4$:		.word	100177,	-1		; error	res.
		.word	125252,	125252
5$:		1200				; fps before execution.
		101216				; fps after execution.
6$:		10				; fec
		0				; flag
7$:		emt	+2			; st 333 (but fiv) no trap.
		br	8$
		emt	+2			; st 700 (but fd).
8$:

; overflow. exponent of	the result = 150
lll4:
		lperr				; set up the loop on error address.
		jsr	pc, @#ovundt
1$:		.word	60345, 67654		; ac
		.word	56765, 45676
2$:		.word	60200, 0, 0, 0		; fsrc
3$:		.word	345, 67654		; res
		.word	56765, 45676
4$:		.word	-1, -1,	-1, -1		; error	res.
5$:		7215				; fps before execution.
		107202				; fps after execution.
6$:		10				; fec
		0				; flag
7$:		emt	+2			; st 133 (but fiv) no trap
		br	8$
		emt	+2
8$:		jmp	@#llldone

; This subroutine, ovundt, is used to set up the operands, execute
; the muld instruction and check the results of	an instruction with
; operands which should	result in either overflow or underflow.	A call
; to it	is made	thus:
;
;	acarg:	.word	x, x, x, x		; ac operand
;	fsrcarg:.word	x, x, x, x		; fsrc operand
;	res:	.word	x, x, x, x		; expected result
;	erres:	.word	x, x, x, x		; error	result
;	epss:	.word	x			; fps before execution
;	fpsa:	.word	x			; fps after execution
;	fec:	.word	x			; expected fec
;	flag:	.word	x			; 0/-1,	over/under flow	flag
;	err1:	error	x			; trap error.
;		br	cont
;	err2:	error	x			; data,	result error
;	cont:					; return address
;
; The operands are set up (using ac0 as	the accumulator). Then
; the muld instruction is executed. If the trap	occurs then the
; result is checked against res. If the	result is correct then the fps is
; compared with	fpsa if	this too is correct ovundt returns control
; to the calling routine at cont. If the fps is	bad ovundt
; reports this failure and then	returns	to cont. the fec is treated
; in the same way. If the result of the
; mulf is incorrect, the incorrect result is compared with the
; anticipated failing data pattern, erres. If the failure in
; the result was anticipated correctly to be erres then	ovundt
; will transfer	control	to the error call at err2. Otherwise the
; result was incorrect but was not anticipated and ovundt will
; report the failure after which control will be passed	to cont.
; If no	trap occurs control is passed to err1.
; Note that ovundnt uses the flag
; to tell whether or not these particular operands will	result in
; underflow (flag=-1) or overflow (flag=0).
;
ovundt:		mov	(SP)+, R1		; get a	pointer	to the arguments.
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	R1, R0			; load ac0, operand.
		ldd	(R0), ac0
		mov	R1, R2			; save the data	patterns in case of
		mov	R2, @#$tmp3		; error.
		add	#10, R2
		mov	R2, @#$tmp4
		add	#10, R2
		mov	R2, @#$tmp5
		mov	42(R1),	@#$tmp10
		mov	#ovdtt,	@#$tmp6
		mov	40(R1),	R0		; load the fps.
		ldfps	R0
		mov	#1$, @#$tmp2
		mov	#50$, @#fpvect		; set up the fp	trap vector in case
						; of error.
		mov	R1, R0			; compute the address of fsrc.
		add	#10, R0
1$:		muld	(R0), ac0		; test instruction. should cause trap.
2$:		cfcc
		jmp	@#25$			; failure. no trap.

50$:		mov	(SP), R2		; trap to here and see if the PC of the
		cmp	R2, #2$			; trap was that	of the mulf instruction.
		beq	51$			; branch if yes.
		jmp	@#fpspur		; otherwise report spurious fp error.

51$:		cmp	(SP)+, (SP)+		; reset	the stack
		stfps	R4			; get fps.
		stst	R5			; get fec.
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	#ovdtt,	R0		; get the result.
		std	ac0, (R0)
		mov	R4, @#$tmp7
		mov	R5, @#$tmp11
		mov	#ovdtt,	R0		; check	the result.
		mov	R1, R2
		add	#20, R2
		mov	#4, R3
3$:		cmp	(R0)+, (R2)+
		bne	15$			; branch if incorrect.
		sob	R3, 3$
		cmp	42(R1),	R4		; was fps correct?
		bne	10$			; branch if fps	is incorrect.
		cmp	44(R1),	R5		; is fec correct?
		bne	5$			; if incorrect branch.
4$:		jmp	56(R1)			; rerfn. test completed.

; report incorrect fec.
5$:		tst	46(R1)			; was the result overflow or underflow?
		bne	7$			; branch if underflow.
						; report bad fec on expected overflow.
6$:		emt	+2
		br	4$
7$:						; report bad fec on expected underflow.
8$:		emt	+2
		br	4$

; report incorrect fps.
10$:		tst	46(R1)			; was the result over or under flow?
		bne	12$			; branch if underflow.
						; report fps bad after overflow.
11$:		emt	+2
		br	4$
12$:						; report fps bad after underflow.
13$:		emt	+2
		br	4$

; result incorrect.
15$:		mov	#ovdtt,	R0		; see if failure is anticipated.
		mov	R1, R2			; failure.
		add	#30, R2
		mov	#4, R3
16$:		cmp	(R0)+, (R2)+
		bne	17$			; branch if not	anticipated.
		sob	R3, 16$
		mov	R1, R2			; error	was anticipated	s0 return
		add	#54, R2			; to the error report in the calling
		mov	R2, @#$tmp2		; routine.
		jmp	(R2)

17$:		tst	46(R1)			; result was not anticipated
						; so error must	be reported here.
						; first	see if arguments should
						; have resulted	in overflow or under
						; flow by looking at the flag.
		bne	19$			; branch if underflow expected.
						; report result	incorrect, expecting
18$:		emt	+2			; overflow.
		br	4$
19$:						; report result	incorrect, expecting
20$:		emt	+2			; underflow.

		br	4$

; if no	fp trap	occurs core here.
25$:		stfps	R4			; get fps.
		stst	R5			; get fec.
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	#ovdtt,	R0		; get the result.
		std	ac0, (R0)
		mov	R4, @#$tmp7
		mov	R5, @#$tmp11
		mov	R1, R2			; error	was anticipated	so
		add	#50, R2			; return to the	error report of	the
						; calling routine.
		jmp	(R2)

ovdtt:		.word	0, 0, 0, 0
llldone:
		rsetup
;_____________________________________________________________________________
;
; TEST 54 - modf test
; This is a test of the	modf instruction, which	makes use of
; a subroutine to set up the operands, execute the modf	instruction
; and check the	results.
;
tst54:		scope
; modf with (fsrc=ac=0)
ggg1:
		lperr				; set up the loop on error address.
		jsr	pc, @#modfsub
1$:		.word	0, 0			; ac
2$:		.word	0, 0			; fsrc
3$:		.word	0, 0			; fractional res.
4$:		.word	0, 0			; integer res.
5$:		.word	-1, -1			; error	fractional res.
6$:		.word	-1, -1			; error	ingeter	res.
7$:		13				; fps before execution.
		4				; fps after execution.
8$:		emt	+2			; store	single zero bad.
		br	9$
		emt	+2			; ac v 1 <= zero failed.
9$:

; modf test with (fsrc=0)
ggg2:
		lperr				; set up the loop on error address.
		jsr	pc, @#modfsub
1$:		.word	123456,	76543		; ac
2$:		.word	0, 0			; fsrc
3$:		.word	0, 0			; fractional res.
4$:		.word	0, 0			; integer result.
5$:		.word	123456,	76543		; error	fractional res.
6$:		.word	-1, -1			; error	integer	res.
7$:		0				; fps before execution.
		4				; fps after execution.
8$:		emt	+2			; store	zero failure.
		br	9$
		emt	+2
9$:

; modf test with (ac=0)
ggg3:
		lperr				; set up the loop on error address.
		jsr	pc, @#modfsub
1$:		.word	0, 0			; ac
2$:		.word	76543, 21234		; fsrc
3$:		.word	0, 0			; fractional res.
4$:		.word	0, 0			; integer res.
5$:		.word	0, 0			; error	fractional res.
6$:		.word	-1, -1			; error	integer	res.
7$:		3				; fps before execution.
		4				; fps after execution.
8$:		emt	+2			; res. bad
		br	9$
		emt	+2
9$:

; modf test with exponent of the result	= 25
ggg4:
		lperr				; set up the loop on error address.
		jsr	pc, @#modfsub
1$:		.word	46252, 125252		; ac
2$:		.word	40300, 0		; fsrc
3$:		.word	0, 0			; fractional res.
4$:		.word	46377, -1		; integer res.
5$:		.word	46252, 125252		; error	fractional res.
6$:		.word	40300, 0		; error	integer	res.
7$:		13				; fps before execution.
		4				; fps after execution.
8$:		emt	+2			; st 134
		br	9$
		emt	+2
9$:

; modf test with exponent of the result	= 127
ggg5:
		lperr				; set up the loop on error address.
		jsr	pc, @#modfsub
1$:		.word	77652, 125252		; ac
2$:		.word	40300, 0		; fsrc
3$:		.word	0, 0			; fractional res.
4$:		.word	77777, -1		; integer res.
5$:		.word	77652, 125252		; error	fractional res.
6$:		.word	40300, 0		; error	integer	res.
7$:		0				; fps before execution.
		4				; fps after execution.
8$:		emt	+2
		br	9$
		emt	+2
9$:

; modf test with exponent of result = 25
ggg6:
		lperr				; set up the loop on error address.
		jsr	pc, @#modfsub
1$:		.word	46200, 1		; ac
2$:		.word	40340, 0		; fsrc
3$:		.word	0, 0			; fractional res.
4$:		.word	46340, 1		; integer res.
5$:		.word	40000, 0		; error	fractional res.
6$:		.word	-1, -1			; error	integer	res.
7$:		13				; fps before execution.
		4				; fps after execution.
8$:		emt	+2			; bad constant (not 24),
						; or st	525 to 050 into	150.
		br	9$
		emt	+2
9$:

; modf test with exponent of the result	= 24
ggg7:
		lperr				; set up the loop on error address.
		jsr	pc, @#modfsub
1$:		.word	46000, 1		; ac
2$:		.word	40340, 0		; fsrc
3$:		.word	40100, 0		; fractional res.
4$:		.word	46140, 1		; integer result.
5$:		.word	0, 0			; error	fractional res.
6$:		.word	-1, -1			; error	integer	res.
7$:		0				; fps before execution.
		0				; fps after execution.
8$:		emt	+2			; bad constant used (not 24)
						; or st	525 to 150 into	050
		br	9$
		emt	+2
9$:

; modf test with exponent of the result	= 10
ggg8:
		lperr				; set up the loop on error address.
		jsr	pc, @#modfsub
1$:		.word	42577, -1		; ac
2$:		.word	40200, 0		; fsrc
3$:		.word	40177, 176000		; fractional res.
4$:		.word	42577, 140000		; integer res.
5$:		.word	-1, -1			; error	fractional res.
6$:		.word	-1, -1			; error	integer	res.
7$:		0				; fps before execution.
		0				; fps after execution.
8$:		emt	+2
		br	9$
		emt	+2
9$:
; modf test with the exponent of the result = 10
ggg9:
		lperr				; set up the loop on error address.
		jsr	pc, @#modfsub
1$:		.word	42577, 140001		; ac
2$:		.word	40200, 0		; fsrc
3$:		.word	34600, 0		; fractional res.
4$:		.word	42577, 140000		; integer res.
5$:		.word	0, 0			; error	fractional res.
6$:		.word	-1, -1			; error	integer	res.
7$:		0				; fps before execution.
		0				; fps after execution.
8$:		emt	+2			; st 532 to 122	into normalize.
		br	9$
		emt	+2
9$:

; modf test with exponent of the result	= 9
ggg10:
		lperr				; set up the loop on error address.
		jsr	pc, @#modfsub
1$:		.word	42377, 100000		; ac
2$:		.word	40200, 0		; fsrc
3$:		.word	0, 0			; fractional res.
4$:		.word	42377, 100000		; integer res.
5$:		.word	-1, -1			; error	fractional res.
6$:		.word	-1, -1			; error	integer	res.
7$:		13				; fps before execution.
		4				; fps after execution.
8$:		emt	+2
		br	9$
		emt	+2
9$:

; modf test with exponent of the result	= 0
ggg11:
		lperr				; set up the loop on error address.
		jsr	pc, @#modfsub
1$:		.word	40177, -1		; ac
2$:		.word	40200, 0		; fsrc
3$:		.word	40177, -1		; fractional res.
4$:		.word	0, 0			; integer res.
5$:		.word	0, 0			; error	fractional res.
6$:		.word	40177, -1		; error	integer	res.
7$:		17				; fps before execution.
		0				; fps after execution.
8$:		emt	+2			; st 041 to 046	into 246.
		br	9$
		emt	+2
9$:

; modf test with exponent of the result	= -15
ggg12:
		lperr				; set up the loop on error address.
		jsr	pc, @#modfsub
1$:		.word	34377, -1		; ac
2$:		.word	40200, 0		; fsrc
3$:		.word	34377, -1		; fractional res.
4$:		.word	0, 0			; integer res.
5$:		.word	0, 0			; error	fractional res.
6$:		.word	34377, -1		; error	integer	res.
7$:		0				; fps before execution.
		0				; fps after execution.
8$:		emt	+2
		br	9$
		emt	+2
9$:

; modf test with exponent of result = -64, in round mode
ggg13:
		lperr				; set up the loop on error address.
		jsr	pc, @#modfsub
1$:		.word	20000, 1		; ac
2$:		.word	40300, 0		; fsrc
3$:		.word	20100, 2		; fractional res.
4$:		.word	0, 0			; integer res.
5$:		.word	20100, 1		; error	fractional res.
6$:		.word	0, 0			; error	integer	res.
7$:		0				; fps before execution.
		0				; fps after execution.
8$:		emt	+2			; round	trunk. st 126 into round.
		br	9$
		emt	+2
9$:

; modf test with exponent of result = 11
ggg14:
		lperr				; set up the loop on error address.
		jsr	pc, @#modfsub
1$:		.word	142777,	170000		; ac
2$:		.word	40200, 0		; fsrc
3$:		.word	140000,	0		; fractional res.
4$:		.word	142777,	160000		; integer res.
5$:		.word	40000, 0		; error	fractional res.
6$:		.word	42777, 160000		; error	integer	res.
7$:		7				; fps before execution.
		10				; fps after execution.
8$:		emt	+2			; sign of fraction.
		br	9$
		emt	+2			; sign of integer.
9$:		jmp	gggdone			; go to	next test.

; This subroutine, modfsub, is called to setup the
; operands, execute the	modf instruction and check the results.
; It is	called thus:
;
;	acarg:	.word	x, x			; ac operand
;	fsrcarg:.word	x, x			; fsrc operand
;	fres:	.word	x, x			; fractional result
;	intres:	.word	x, x			; integer result
;	erfres:	.word	x, x			; error	fraction result
;	erintres:.word	x, x			; error	integer	result
;	fpsb:	.word	x			; fps before execution
;	fpsa:	.word	x			; fps after execution
;	err1:	error	x			; fraction error
;		br	cont
;	err2:	error	x			; integer error
;	cont:					; return address
;
; The operands are set up (using ac0 for the ac	argument). The modf
; instruction is executed. Then	the results are	retrieved.
; The fraction part of the result is compared with fres. If this is correct
; then the integer part	is compared with intres. If both of these are correct
; then the fps is compared with	fpsa. After execution if no errors occurred
; then modfsub will return to cont. If the fps was incorrect
; it is	reported here. If the fraction is incorrect it is compared with
; the anticipated bad fraction.	erfres.	If this	doesn't	match
; the true result then the error is reported here. If the anticipated
; failure matches the true result then modfsub passes control to the
; error	call at	err1. Likewise if the integer part of the result is
; not correct then it is compared with the anticipated integer
; failure. If this doen't match	then the error is reported here.
; if a match is	made however. modfsub will return control to the error
; call at err2.
;
modfsub:	mov	(SP)+, R1		; get a	pointer	to the arguments
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	R1, R0			; set up ac0
		ldd	(R0), ac0
		mov	#modp1,	R0		; put a	backround pattern into ac1.
		ldd	(R0), ac1
		mov	30(R1),	R0		; set up the fps.
		ldfps	R0
		mov	#1$, @#$tmp2
		mov	R1, R0			; compute the address of the fsrc.
		add	#4, R0

1$:		modf (R0), ac0			; execute the test instruction.
		stfps	R4			; get the fps.
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	#modft0, R0		; get the fractional result.
		std	ac0, (R0)
		mov	#modft1, R0		; get the integer result.
		std	ac1, (R0)
		mov	R1, R2			; save the data	in case	of error.
		mov	R2, @#$tmp3
		add	#4, R2
		mov	R2, @#$tmp4
		add	#4, R2
		mov	R2, @#$tmp5
		add	#4, R2
		mov	R2, @#$tmp6
		mov	#modft0, @#$tmp7
		mov	#modft1, @#$tmp10
		mov	R4, @#$tmp11
		mov	32(R1),	@#$tmp12
		mov	#modft0, R2		; check	the fractional result.
		cmp	10(R1),	(R2)
		bne	10$			; branch if incorrect.
		cmp	12(R1),	2(R2)
		bne	10$
		mov	#modft1, R2		; check	the integer result.
		cmp	14(R1),	(R2)
		bne	15$			; branch if incorrect.
		cmp	16(R1),	2(R2)
		bne	15$
		cmp	32(R1),	R4		; check	the fps.
		bne	20$			; branch if incorrect.
9$:		jmp	42(R1)			; return.

; fractional error.
10$:		cmp	20(R1),	(R2)		; was the error	anticipated?
		bne	11$			; branch if not	anticipated.
		cmp	22(R1),	2(R2)
		bne	11$
		mov	R1, R2			; the error was	anticipated so
		add	#34, R2			; return to the	error report at	the
						; calling routine.
		jmp	(R2)
11$:						; the error was	not anticipated	so
12$:		emt	+2			; report the incorrect fraction	here.
		br	9$

; integer error.
15$:		cmp	24(R1),	(R2)		; was this error anticipated?
		bne	16$			; branch if not.
		cmp	26(R1),	2(R2)
		bne	16$
		mov	R1, R2			; the error was	anticipated so return
		add	#40, R2			; to the error report in the calling
						; routine.
		jmp	(R2)
16$:						; the error was	not anticipated	so report
17$:		emt	+2			; the integer failure here.
		br	9$

; fps incorrect.
20$:		mov	R4, @#$tmp11		; report incorrect fps.
		mov	32(R1),	@#$tmp12
21$:		emt	+2
		br	9$

modft0:		.word	0, 0, 0, 0
modft1:		.word	0, 0, 0, 0
modp1:		.word	-1, -1,	-1, -1
gggdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 55 - modd test
; This is a test of the	modd instruction. It makes use of a subroutine
; to set up the	arguments, execute the instruction and check the
; results.
;
tst55:		scope
; modd with (fsrc=ac=0)
hhh1:
		lperr				; set up the loop on error address.
		jsr	pc, @#moddsub
1$:		.word	0, 0, 0, 0		; ac
2$:		.word	0, 0, 0, 0		; fsrc
3$:		.word	0, 0, 0, 0		; fractional res.
4$:		.word	0, 0, 0, 0		; integer res.
5$:		.word	0, 0, 0, 0		; error	fractional res.
6$:		.word	0, 0, -1, -1		; error	integer	res.
7$:		200				; fps before execution.
		204				; fps after execution.
8$:		emt	+2
		br	9$
		emt	+2			; st 231 to 142	into 143
9$:
; modd test with fsrc=0
hhh2:
		lperr				; set up the loop on error address.

		jsr	pc, @#moddsub
1$:		.word	012345,	67012		; ac
		.word	34567, 012345
2$:		.word	0, 0, 0, 0		; fsrc
3$:		.word	0, 0, 0, 0		; fractional res.
4$:		.word	0, 0, 0, 0		; integer res.
5$:		.word	012345,	67012		; error	fractional res.
		.word	34567, 012345
6$:		.word	-1, -1,	-1, -1		; error	integer	res.
7$:		213				; fps before execution.
		204				; fps after execution.
8$:		emt	+2			; store	double zero
		br	9$
		emt	+2			; ac v 1 <= zero st 143
9$:

; modd test with (ac=0)
hhh3:
		lperr				; set up the loop on error address.
		jsr	pc, @#moddsub
1$:		.word	0, 0, 0, 0		; ac
2$:		.word	72727, 127272		; fsrc
		.word	72727, 127272
3$:		.word	0, 0, 0, 0		; fractional res.
4$:		.word	0, 0, 0, 0		; integer res.
5$:		.word	-1, -1,	-1, -1		; error	fractional res.
6$:		.word	-1, -1,	-1, -1		; error	integer	res.
7$:		213				; fps before execution.
		204				; fps after execution.
8$:		emt	+2
		br	9$
		emt	+2
9$:

; modd test with exponent of the result	= 57
hhh4:
		lperr				; set up the loop on error address.
		jsr	pc, @#moddsub
1$:		.word	56252, 125252		; ac
		.word	125252,	125250
2$:		.word	40300, 0, 0, 0		; fsrc
3$:		.word	0, 0, 0, 0		; fractional res.
4$:		.word	56377, -1, -1, -4	; integer res.
5$:		.word	0, 0			; error	fractional res.
		.word	125252,	125252
6$:		.word	56377, -1, -1, -1	; error	integer	res.
7$:		213				; fps before execution.
		204				; fps after execution.
8$:		emt	+2			; st 526 to 134	into 135
		br	9$
		emt	+2
9$:

; modd test with exponent of the result	= 79
hhh5:
		lperr				; set up the loop on error address.
		jsr	pc, @#moddsub
1$:		.word	140240,	0, 0, 0		; ac
2$:		.word	63714, 146314		; fsrc
		.word	133572,	167737
3$:		.word	0, 0, 0, 0		; fractional res.
4$:		.word	163777,	-1		; integer res.
		.word	162531,	125726
5$:		.word	-1, -1,	-1, -1		; error	fractional res.
6$:		.word	63777, -1		; error	integer	res.
		.word	162531,	125726
7$:		210				; fps before execution.
		204				; fps after execution.
8$:		emt	+2
		br	9$
		emt	+2			; st 526 bad sign
9$:

; modd test with exponent of the result	= 57
hhh6:
		lperr				; set up the loop on error address.
		jsr	pc, @#moddsub
1$:		.word	56200, 0, 0, 1		; ac
2$:		.word	40340, 0, 0, 0		; fsrc
3$:		.word	0, 0, 0, 0		; fractional res.
4$:		.word	56340, 0, 0, 1		; integer res.
5$:		.word	40000, 0, 0, 0		; error	fractional res.
6$:		.word	56340, 0, 0, 1		; error	integer	res.
7$:		213				; fps before execution.
		204				; fps after execution.
8$:		emt	+2			; constant bad (not 56)
						; or st	525 to 050 into	150
		br	9$
		emt	+2
9$:

; modd test with exponent of the result	= 56
hhh7:
		lperr				; set up the loop on error address.
		jsr	pc, @#moddsub
1$:		.word	56000, 0, 0, 1		; ac
2$:		.word	40340, 0, 0, 0		; fsrc
3$:		.word	40100, 0, 0, 0		; fractional res.
4$:		.word	56140, 0, 0, 1		; integer res.
5$:		.word	0, 0, 0, 0		; error	fractional res.
6$:		.word	56140, 0, 0, 1		; error	integer	res.
7$:		213				; fps before execution.
		200				; fps after execution.
8$:		emt	+2			; bad constant (not 56)	or
						; st 525 to 150	into 050
		br	9$
		emt	+2
9$:

; modd test with exponent of the result	= 36
hhh8:
		lperr				; set up the loop on error address.
		jsr	pc, @#moddsub
1$:		.word	51177, -1, -1, -1	; ac
2$:		.word	40200, 0, 0, 0		; fsrc
3$:		.word	40177, -20, 0, 0	; fractional res.
4$:		.word	51177, -1, -20,	0	; integer res.
5$:		.word	-1, -1,	-1, -1		; error	fractional res.
6$:		.word	-1, -1,	-1, -1		; error	integer	res.
7$:		217				; fps before execution.
		200				; fps after execution.
8$:		emt	+2
		br	9$
		emt	+2
9$:

; modd test with exponent of the result	= 30
hhh9:
		lperr				; set up the loop 0n error address.
		jsr	pc, @#moddsub
1$:		.word	40200, 0, 0, 0		; ac
2$:		.word	47577, -1		; fsrc
		.word	176000,	1
3$:		.word	31600, 0, 0, 0		; fractional res.
4$:		.word	47577, -1		; integer res.
		.word	176000,	0
5$:		.word	0, 0, 0, 0		; error	fractional res.
6$:		.word	47577, -1, -1, -1	; error	integer	res.
7$:		200				; fps before execution.
		200				; fps after execution.
8$:		emt	+2			; (normalize) st 532 to	122
						; into norm.
		br	9$
		emt	+2			; ac v 1 <= x14
						; or st	733 to 156 into	157.
9$:

; modd test with exponent of the result	= 31
hhh10:
		lperr				; set up the loop on error address.
		jsr	pc, @#moddsub
1$:		.word	47777, -1		; ac
		.word	177000,	0
2$:		.word	40200, 0, 0, 0		; fsrc
3$:		.word	0, 0, 0, 0		; fractional res.
4$:		.word	47777, -1		; integer res.
		.word	177000,	0
5$:		.word	0, 0, 177000, 0		; error	fractional res.
6$:		.word	-1, -1,	-1, -1		; error	integer	res.
7$:		213				; fps before execution.
		204				; fps after execution.
8$:		emt	+2			; (but fd) store x10
		br	9$
		emt	+2
9$:

; modd test with exponent of the result	= 0
hhh11:
		lperr				; set up the loop on error address.
		jsr	pc, @#moddsub
1$:		.word	40200, 0, 0, 0		; ac
2$:		.word	40177, 72727		; fsrc
		.word	127272,	72727
3$:		.word	40177, 72727		; fractional res.
		.word	127272,	72727
4$:		.word	0, 0, 0, 0		; integer res.
5$:		.word	-1, -1,	-1, -1		; error	fractional res.
6$:		.word	0, 0, -1, -1		; error	integer	res.
7$:		200				; fps before execution.
		200				; fps after execution.
8$:		emt	+2
		br	9$
		emt	+2			; st 246 to 126	into 127 (but fd)
9$:

; modd test with exponent of the result	= -115
hhh12:
		lperr				; set up the loop on error address.
		jsr	pc, @#moddsub
1$:		.word	3377, -1		; ac
		.word	-1, 52525
2$:		.word	40200, 0, 0, 0		; fsrc
3$:		.word	3377, -1		; fractional res.
		.word	-1, 52525
4$:		.word	0, 0, 0, 0		; integer res.
5$:		.word	-1, -1,	-1, -1		; error	fractional res.
6$:		.word	0, 0, -1, -1		; error	integer	res.
7$:		200				; fps before execution.
		200				; fps after execution.
8$:		emt	+2
		br	9$
		emt	+2			; st 446 to 126	into 127 (but fd)
9$:

; modd test with exponent of the result	= -63, in round	mode.
hhh13:
		lperr				; set up the loop on error address.
		jsr	pc, @#moddsub
1$:		.word	40300, 0, 0, 0		; ac
2$:		.word	20200, 0, 0, 1		; fsrc
3$:		.word	20300, 0, 0, 2		; fractional res.
4$:		.word	0, 0, 0, 0		; integer res.
5$:		.word	0, 0, -1, -1		; error	fractional res.
6$:		.word	-1, -1,	-1, -1		; error	integer	res.
7$:		200				; fps before execution.
		200				; fps after execution.
8$:		emt	+2			; st 127 into rnd/tr
		br	9$
		emt	+2
9$:		jmp	@#hhhdone		; go to	the next test.

; This subroutine, moddsub, is called to setup the
; operands, execute the	modd instruction and check the results.
; It is	called thus:
;
;	acarg:	.word	x, x, x, x		; ac operand
;	fsrcarg:.word	x, x, x, x		; fsrc operand
;	fres:	.word	x, x, x, x		; fractional result
;	intres:	.word	x, x, x, x		; integer result
;	erfres:	.word	x, x, x, x		; error	fraction result
;	erintres:.word	x, x, x, x		; error	integer	result
;	fpsb:	.word	x			; fps before execution
;	fpsa:	.word	x			; fps after execution
;	err1:	error	x			; fraction error
;		br	cont
;	err2:	error	x			; integer error
;	cont:					; return address
;
; The operands are set up (using ac0 for the ac	argument). The mood
; instruction is executed. Then	the results are	retrieved.
; The fraction part of the result is compared with fres. If this is correct
; then the integer part	is compared with intres. If both of these are correct
; then the fps is compared with	fpsa. After execution if no errors occurred
; then moddsub will return to cont. If the fps was incorrect
; it is	reported here. If the fraction is incorrect it is compared with
; the anticipated bad fraction,	erfres.	If this	doesn't	match
; the true result then the error is reported here. If the anticipated
; failure matches the true result then moddsub passes control to the
; error	call at	err1. Likewise if the integer part of the result is
; not correct then it is compared with the anticipated integer
; failure. If this doen't match	then the error is reported here.
; If a match is	made however, moddsub will return control to the error
; call at err2.
;
moddsub:	mov	(SP)+, R1		; get a	pointer	to the arguments
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	R1, R0			; set up ac0
		ldd	(R0), ac0
		mov	#modp1,	R0		; put a	backround pattern into ac1.
		ldd	(R0), ac1
		mov	60(R1),	R0		; set up the fps.
		ldfps	R0
		mov	#1$, @#$tmp2
		mov	R1, R0			; compute the address of the fsrc.
		add	#10, R0
1$:		modd	(R0), ac0		; execute the test instruction.
		stfps	R4			; get the fps.
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	#moddt0, R0		; get the fractional result.
		std	ac0, (R0)
		mov	#moddt1, R0		; get the integer result.
		std	ac1, (R0)
		mov	R1, R2			; save the data	in case	of error.
		mov	R2, @#$tmp3
		add	#10, R2
		mov	R2, @#$tmp4
		add	#10, R2
		mov	R2, @#$tmp5
		add	#10, R2
		mov	R2, @#$tmp6
		mov	#moddt0, @#$tmp7
		mov	#moddt1, @#$tmp10
		mov	62(R1),	@#$tmp12
		mov	R4, @#$tmp11
		mov	#moddt0, R2		; check	the fractional result.
		mov	R1, R3
		add	#20, R3
		mov	#4, R5
2$:		cmp	(R2)+, (R3)+
		bne	10$			; branch if incorrect.
		sob	R5, 2$
		mov	#moddt1, R2		; check	the integer result.
		mov	R1, R3
		add	#30, R3
		mov	#4, R5
3$:		cmp	(R2)+, (R3)+
		bne	15$			; branch if incorrect.
		sob	R5, 3$
		cmp	62(R1),	R4		; check	the fps.
		bne	20$			; branch if incorrect.

9$:		jmp	72(R1)			; return.

; fractional error.
10$:		mov	#moddt0, R2		; was the fractional error anticipated?
		mov	R1, R3
		add	#40, R3
		mov	#4, R5
50$:		cmp	(R2)+, (R3)+
		bne	11$			; branch if not	anticipated.
		sob	R5, 50$
		mov	R1, R2			; the error was	anticipated so
		add	#64, R2			; return to the	error report at	the
						; calling routine.
		jmp	(R2)
11$:						; the error was	not anticipated	so
12$:		emt	+2			; report the incorrect fraction	here.
		br	9$

; integer error.
15$:		mov	#moddt1, R2		; was the integer error	anticipated?
		mov	R1, R3
		add	#50, R3
		mov	#4, R5

60$:		cmp	(R2)+, (R3)+
		bne	17$			; branch if not	anticipated.
		sob	R5, 60$
		mov	R1, R2			; the error was	anticipated so return
		add	#70, R2			; to the error report in the calling
						; routine.
		jmp	(R2)
16$:						; the error was	not anticipated	so report
17$:		emt	+2			; the integer failure here.
		br	9$

; fps incorrect.
20$:		mov	R4, @#$tmp11		; report incorrect fps.
		mov	62(R1),	@#$tmp12
21$:		emt	+2
		br	9$

moddt0:		.word	0, 0, 0, 0
moddt1:		.word	0, 0, 0, 0
hhhdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 56 - under/over flow, using modf	with traps disabled, test
; This is a test of the	modf overflow and underflow conditions.	It makes
; use of a subroutine to setup the operands, execute the modf instruction
; and check the	results. Traps are disabled during this	test.
;
tst56:		scope
; underflow test, with exponent	of the result =	-129, fiu=1, fid=1
mmm1:
		lperr				; set up the loop on error address.
		jsr	pc, modfov
1$:		.word	20123, 45676		; ac
2$:		.word	20200, 0		; fsrc
3$:		.word	123, 45676		; fractional res.
4$:		.word	0, 0			; integer res.
5$:		.word	-1, -1			; error	fractional res.
6$:		.word	-1, -1			; error	integer	res.
7$:		42000				; fps before execution.
		142004				; fps after execution.
		12				; fec
8$:		emt	+2			; fec incorrect, underflow.
		br	9$
		emt	+2			; ac v 1 (2.3) <= zero.	st 126.
9$:

; underflow exp	of result = -193, fiu=0, fid=1
mmm2:
		lperr				; set up the loop on error address.
		jsr	pc, @#modfov
1$:		.word	10200, 0		; ac
2$:		.word	10000, 0		; fsrc
3$:		.word	0, 0			; fractional res.
4$:		.word	0, 0			; integer res.
5$:		.word	-1, -1			; error	fractional res.
6$:		.word	-1, -1			; error	integer	res.
7$:		5013				; fps before execution.
		5004				; fps after execution.
		12				; fec
8$:		nop
		br	9$
		emt	+2
9$:

; overflow test	with exponent of the result = 128, fiv=1, fid=1
mmm3:
		lperr				; set up the loop on error address.
		jsr	pc, @#modfov
1$:		.word	60052, 125252		; ac
2$:		.word	60200, 0		; fsrc
3$:		.word	0, 0			; fractional res.
4$:		.word	52, 125252		; integer res.
5$:		.word	0, 0			; error	fractional res.
6$:		.word	0, 0			; error	integer	res.
7$:		41000				; fps before execution.
		141006				; fps after execution.
		10				; fec
8$:		emt	+2			; bad fec on overflow.
		br	9$
		emt	+2			; st 520 to store zero twice
						; into 162
9$:

; overflow test	with exponent of the result = 130, fiv=0, fid=1
mmm4:
		lperr				; set up the loop on error address.
		jsr	pc, @#modfov
1$:		.word	60345, 67654		; ac
2$:		.word	60200, 0		; fsrc
3$:		.word	0, 0			; fractional res.
4$:		.word	0, 0			; integer res.
5$:		.word	0, 0			; error	fractional res.
6$:		.word	345, 67654		; error	integer	res.
7$:		6011				; fps before execution.
		6006				; fps after execution.
		10				; fec
8$:		nop
		br	9$
		emt	+2			; st 520 to 162	into store zero	twice.
9$:

; overflow test	with exponent of the result = 128, result negative
; and fiv=1, fid=1
mmm5:
		lperr				; set up the loop on error address.
		jsr	pc, @#modfov
1$:		.word	160252,	125252		; ac
2$:		.word	60000, 0		; fsrc
3$:		.word	0, 0			; fractional res.
4$:		.word	100052,	125252		; integer res.
5$:		.word	0, 0			; error	fractional res.
6$:		.word	52, 125252		; error	integer	res.
7$:		41000				; fps before execution.
		141006				; fps after execution.
		10				; fec
8$:		emt	+2
		br	9$
		emt	+2			; st 517, bad sign.
9$:		jmp	@#mmmdone		; go to	the next test.

; This subroutine, modfov, is called to	setup the
; operands, execute the	modf instruction and check the results.
; It is	called thus:
;
;	acarg:	.word	x, x			; ac operand
;	fsrcarg:.word	x, x			; fsrc operand
;	fres:	.word	x, x			; fractional result
;	intres:	.word	x, x			; integer result
;	erfres:	.word	x, x			; error	fraction result
;	erintres:.word	x, x			; error	integer	result
;	fpsb:	.word	x			; fps before execution
;	fpsa:	.word	x			; fps after execution
;	fec:	.word	x			; fec
;	err1:	error	x			; fec error
;		br	cont
;	err2:	error	x			; integer error
;	cont:					; return address
;
; The operands are set up (using ac0 for the ac	argument). The modf
; instruction is executed. Then	the results are	retrieved.
; The fraction part of the result is compared with fres. If this is correct
; then the integer part	is compared with intres. If both of these are correct
; then the fps is compared with	fpsa. After execution if no errors occurred
; then modfov will return to cont. If the fps was incorrect
; it is	reported here. If the fraction is incorrect it is compared with
; the anticipated bad fraction,	erfres.	If this	doesn't	match
; the true result then the error is reported here. If the anticipated
; failure matches the true result then modfov passes control to	the
; error	call at	err1. Likewise if the integer part of the result is
; not correct then it is compared with the anticipated integer
; failure. If this dosn't match	then the error is reported here.
; If a match is	made however. modfov will return control to the	error
; call at err2.
;
modfov:		mov	(SP)+, R1		; get a	pointer	to the arguments
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	R1, R0			; set up ac0
		ldd	(R0), ac0
		mov	#modp1,	R0		; put a	backround pattern into ac1.
		ldd	(R0), ac1
		mov	30(R1),	R0		; set up the fps.
		ldfps	R0
		mov	#1$, @#$tmp2
		mov	R1, R0			; compute the address of the fsrc.
		add	#4, R0
1$:		modf	(R0), ac0		; execute the test instruction.
		stfps	R4			; get the fps.
		stst	R5			; get fec.
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	#modfd0, R0		; get the fractional result.
		std	ac0, (R0)
		mov	#modfd1, R0		; get the integer result.
		std	ac1, (R0)
		mov	R1, R2			; save the data	in case	of error.
		mov	R2, @#$tmp3
		add	#4, R2
		mov	R2, @#$tmp4
		add	#4, R2
		mov	R2, @#$tmp5
		add	#4, R2
		mov	R2, @#$tmp6
		mov	#modfd0, @#$tmp7
		mov	#modfd1, @#$tmp10
		mov	R4, @#$tmp11
		mov	32(R1),	@#$tmp12
		mov	R5, @#$tmp13
		mov	34(R1),	@#$tmp14
		mov	#modfd0, R2		; check	the fractional result.
		cmp	10(R1),	(R2)
		bne	10$			; branch if incorrect.
		cmp	12(R1),	2(R2)
		bne	10$
		mov	#modfd1, R2		; check	the integer result.
		cmp	14(R1),	(R2)
		bne	15$			; branch if incorrect.
		cmp	16(R1),	2(R2)
		bne	15$
		cmp	32(R1),	R4		; check	the fps.
		bne	20$			; branch if incorrect.
		cmp	34(R1),	R5		; check	the fec.
		bne	25$			; branch if incorrect.
9$:		jmp	44(R1)			; return.

; fractional error.
10$:						; the error was	not anticipated	so
12$:		emt	+2			; report the incorrect frac i ion here.
		br	9$

; integer error.
15$:		cmp	24(R1),	(R2)		; was this error anticipated?
		bne	16$			; branch if not.
		cmp	26(R1),	2(R2)
		bne	16$
		mov	R1, R2			; the error was	anticipated so return
		add	#42, R2			; to the error report in the calling
						; routine.
		jmp	(R2)
16$:						; the error was	not anticipated	so report
17$:		emt	+2			; the integer failure here.
		br	9$

; fps incorrect.
20$:		mov	R4, @#$tmp11		; report incorrect fps.
		mov	32(R1),	@#$tmp12
21$:		emt	+2
		br	9$

; report fec error.
25$:		mov	R5, @#$tmp13
		mov	34(R1),	@#$tmp14
		mov	R1, R2
		add	#36, R2
		jmp	(R2)

modfd0:		.word	0, 0, 0, 0
modfd1:		.word	0, 0, 0, 0
mmmdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 57 - under/over flow, using modd	with traps disabled, test
; This is a test of the	modd instruction's over	flow and under flow
; conditions. A	subroutine is used to set up the operands, execute the
; modd instuction and check the	results.
;
tst57:		scope
; underflow test with exponent of the result = -129, fiu=1, fid=1
nnn1:
		lperr				; set up the loop on error address.
		jsr	pc, @#moddov
1$:		.word	20252, 125252		; ac
		.word	125252,	125252
2$:		.word	20100, 0, 0, 0		; fsrc
3$:		.word	177, -1, -1, -1		; fractional res.
4$:		.word	0, 0, 0, 0		; integer res.
5$:		.word	20252, 125252		; error	fractional res.
		.word	125252,	125252
6$:		.word	0, 0, -1, -1		; error	integer	res.
7$:		42200				; fps before execution.
		142204				; fps after execution.
		12				; fec
8$:		emt	+2			; fec incorrect	on underflow.
		br	9$
		emt	+2			; st 155 (but fd)
9$:

; underflow test with exponent of the result = -193, fiu=0, fid=1
nnn2:
		lperr				; set up the loop on error address.
		jsr	pc, @#moddov
1$:		.word	10000, 0		; ac
		.word	123456,	0
2$:		.word	10200, 0, 0, 0		; fsrc
3$:		.word	0, 0, 0, 0		; fractional res.
4$:		.word	0, 0, 0, 0		; integer res.
5$:		.word	0, 0, 0, 0		; error	fractional res.
6$:		.word	0, 0			; error	integer	res.
		.word	123456,	0
7$:		5213				; fps before execution.
		5204				; fps after execution.
		12
8$:		nop
		br	9$
		emt	+2			; st 047 (but fd).
9$:

; overflow test	with exponent of the result = 128, fiv=1, fid=1
nnn3:
		lperr				; set up the loop on error address.
		jsr	pc, @#moddov
1$:		.word	60252, 125252		; ac
		.word	125252,	125252
2$:		.word	60100, 0, 0, 0		; fsrc
3$:		.word	0, 0, 0, 0		; fractional res.
4$:		.word	177, -1, -1, -1		; integer res.
5$:		.word	0, 0, 0, 0		; error	fractional res.
6$:		.word	177, -1			; error	integer	res.
		.word	125252,	125252
7$:		41200				; fps before execution.
		141206				; fps after execution.
		10				; fec
8$:		emt	+2			; fec bad on overflow.
		br	9$
		emt	+2			; st 520 to 162	into 163 (but fd).
9$:

; overflow test	with exponent of the result = 130, fiv=0, fid=1
nnn4:
		lperr				; set up the loop on error address.
		jsr	pc, @#moddov
1$:		.word	60200, 0		; ac
		.word	125252,	0
2$:		.word	60200, 0, 0, 0		; fsrc
3$:		.word	0, 0, 0, 0		; fractional res.
4$:		.word	0, 0, 0, 0		; integer res.
5$:		.word	0, 0, 0, 0		; error	fractional res.
6$:		.word	400, 0			; error	integer	res.
		.word	125252,	0
7$:		6211				; fps before execution.
		6206				; fps after execution.
		10				; fec
8$:		nop
		br	9$
		emt	+2			; st 520 to 162	into store zero	twice.
9$:		jmp	@#nnndone		; go to	next test.

; This subroutine, moddov, is called to	setup the
; operands, execute the	modd instruction and check the results.
; It is	called thus:
;
;	acarg:	.word	x, x, x, x		; ac operand
;	fsrcarg:.word	x, x, x, x		; fsrc operand
;	fres:	.word	x, x, x, x		; fractional result
;	intres:	.word	x, x, x, x		; integer result
;	erfres:	.word	x, x, x, x		; error	fraction result
;	erintres:.word	x, x, x, x		; error	integer	result
;	fpsb:	.word	x			; fps before execution
;	fpsa:	.word	x			; fps after execution
;	err1:	error	x			; fraction error
;		br	cont
;	err2:	error	x			; integer error
;	cont:					; return address
;
; The operands are set up (using ac0 for the ac	argument). The modd
; instruction is executed. Then	the results are	retrieved.
; the fraction part of the result is compared with fres. If this is correct
; then the integer part	is compared with intres. If both of these are correct
; then the fps is compared with	fpsa. After execution if no errors occurred
; then moddov will return to cont. If the fps was incorrect
; it is	reported here. If the fraction is incorrect it is compared with
; the anticipated bad fraction,	erfres.	If this	doesn't	match
; the true result then the error is reported here. If the anticipated
; failure matches the true result then moddov passes control to	the
; error	call at	err1. Likewise if the integer part of the result is
; not correct then it is compared with the anticipated integer
; failure. If this doen't match	then the error is reported here.
; If a match is	made however, moddov will return control to the	error
; call at err2.
;
moddov:		mov	(SP)+, R1		; get a	pointer	to the arguments
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	R1, R0			; set up ac0
		ldd	(R0), ac0
		mov	#modp1,	R0		; put a	backround pattern into ac1.
		ldd	(R0), ac1
		mov	60(R1),	R0		; set up the fps.
		ldfps	R0
		mov	#1$, @#$tmp2
		mov	R1, R0			; compute the address of the fsrc.
		add	#10, R0
1$:		modd	(R0), ac0		; execute the test instruction.
		stst	R5			; get the fps.
		stfps	R4			; get the fps.
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	#moddd0, R0		; get the fractional result.
		std	ac0, (R0)
		mov	#moddd1, R0		; get the integer result.
		std	ac1, (R0)
		mov	R1, R2			; save the data	in case	of error.
		mov	R2, @#$tmp3
		add	#10, R2
		mov	R2, @#$tmp4
		add	#10, R2
		mov	R2, @#$tmp5
		add	#10, R2
		mov	R2, @#$tmp6
		mov	#moddd0, @#$tmp7
		mov	#moddd1, @#$tmp10
		mov	R4, @#$tmp11
		mov	62(R1),	@#$tmp12
		mov	R5, @#$tmp13
		mov	64(R1),	@#$tmp14
		mov	#moddd0, R2		; check	the fractional result.
		mov	R1, R3
		add	#20, R3
		mov	#4, R0
2$:		cmp	(R2)+, (R3)+
		bne	10$			; branch if incorrect.
		sob	R0, 2$
		mov	#moddd1, R2		; check	the integer result.
		mov	R1, R3
		add	#30, R3
		mov	#4, R0
3$:		cmp	(R2)+, (R3)+
		bne	15$			; branch if incorrect.
		sob	R0, 3$
		cmp	62(R1),	R4		; check	the fps.
		bne	20$			; branch if incorrect.
		cmp	64(R1),	R5		; check	the fec.
		bne	25$
9$:		jmp	74(R1)			; return.

; fractional error.
10$:						; the error was	not anticipated	so
12$:		emt	+2			; report the incorrect fraction	here.
		br	9$

; integer error.
15$:		mov	#moddd1, R2		; was the integer error	anticipated?
		mov	R1, R3
		add	#50, R3
		mov	#4, R5
60$:		cmp	(R2)+, (R3)+
		bne	17$			; branch if not	anticipated.
		sob	R5, 60$
		mov	R1, R2			; the error was	anticipated so return
		add	#72, R2			; to the error report in the calling
						; routine.
		jmp	(R2)
16$:						; the error was	not anticipated	so report
17$:		emt	+2			; the integer failure here.
		br	9$

; fps incorrect.
20$:		mov	R4, @#$tmp11		; report incorrect fps.
		mov	62(R1),	@#$tmp12
21$:		emt	+2
		br	9$

; report fec error.
25$:		mov	R5, @#$tmp13
		mov	64(R1),	@#$tmp14
		mov	R1, R2
		add	#66, R2
		jmp	(R2)

moddd0:		.word	0, 0, 0, 0
moddd1:		.word	0, 0, 0, 0
nnndone:
		rsetup
;_____________________________________________________________________________
;
; TEST 60 - more microcodes coverage
; This test will provide additional micro-code locations coverage
; in fpp1 and fpp2.
;
tst60:		scope
xx1:
		lperr				; set up the loop on error address.
xt1:		mov	#xt1a, @#244
		stfps	#0
		br	xt2
xt1a:		emt	+1			; should not trap

xt2:		mov	#-1, R0
		ldfps	#0
		stfps	R0
		tst	R0
		beq	xt2a
		emt	+1			; fps is not zeroed
xt2a:		mov	#xpat0,	R0
		ldf	-(R0), ac0
		cmp	#xpat0-4, R0
		beq	xt2b
		emt	+1			; R0 was not decr by 4
xt2b:		stfps	R0
		cmp	#4, R0			; check	if fz is set?
		beq	xt3
		emt	+1

xt3:		ldfps	#0
		mov	#xpat0,	R0
		stf	ac0, -(R0)
		cmp	#xpat0-4, R0
		beq	xt3a			; R0 was not decr by 4
		emt	+1
xt3a:		stfps	R0
		tst	R0
		beq	xt4
		emt	+1

xt4:		ldfps	#0
		mov	#xt4a, @#244
		ldfps	#04000			; intrpt on undefined variable
		ldf	@#xpat0, ac0
		divf	@#xpat3, ac0		; get undefined	variable, 0
		emt	+1			; missing interrupt to 244
xt4a:		stfps	R0
		cmp	#104004, R0		; check: fer, fiuv, fz are set?
		beq	xt4b
		emt	+1
xt4b:		mov	#xbuf, R0
		stf	ac0, (R0)
		tst	@#xbuf
		beq	xt5
		emt	+1			; ac0 should remain zeroed

xt5:		mov	#xt5a, @#244
		ldfps	#04000			; intrpt on undefined varibale
		ldcdf	@#xpat3, ac0		; get undefined	variable, 0
		emt	+1			; missing interrupt to 244
xt5a:		stfps	R0
		cmp	#104014, R0		; check: fer, fiuv, fn,	fz are set's
		beq	xt5b
		emt	+1
xt5b:		mov	#xbuf, R0
		stf	ac0, (R0)
		tst	@#xbuf
		beq	xt6
		emt	+1			; ac0 should be	zeroed

xt6:
		lperr				; set up the loop on error address.
		mov	#xt6a, @#244
		ldfps	#04000			; intrpt on undefined varibale
		ldf	@#xpat0, ac0
		addf	@#xpat3, ac0
		emt	+2			; missing interrupt to 244
xt6a:		stfps	R0
		cmp	#104004, R0		; check: fer, fiuv, fz are set?
		beq	xt6b
		emt	+2
xt6b:		mov	#xbuf, R0
		stf	ac0, (R0)
		tst	@#xbuf
		beq	xt7
		emt	+2			; ac0 should be	zeroed

xt7:		ldfps	#0
		ldf	@#xpat4, ac0
		stcfi	ac0, @#xpato
		cmp	#2, @#xpato		; check	data
		beq	xt8
		emt	+1

xt8:		ldfps	#100			; set fl
		ldf	@#xpat4, ac0
		stcfi	ac0, xpato
		cmp	#2, @#xpato+2
		beq	xt9
		emt	+1

; start	of fpp2
xt9:		ldfps	#0
		ldf	@#xpat0, ac0
		addf	@#xpat4, ac0
		stfps	R0
		tst	R0
		beq	xt10
		emt	+2

xt10:		ldfps	#0
		ldf	@#xpat4, ac0
		subf	@#xpat4, ac0
		stfps	R0
		cmp	#4, R0
		beq	xt11
		emt	+2

xt11:		ldfps	#0
		ldf	@#xpat4, ac0
		cmpf	@#xpat4, ac0
		stfps	R0
		cmp	#4, R0			; check	if fz is set?
		beq	xt12
		emt	+2

xt12:		ldfps	#0
		ldf	@#xpat4, ac0
		divf	@#xpat2, ac0
		mov	#xbuf, R0
		stf	ac0, (R0)
		cmp	#040176, @#xbuf		; check	data
		beq	xt13
		emt	+2

xt13:		ldfps	#0
		ldf	@#xpat5, ac0
		divf	@#xpat6, ac0
		stfps	R0
		cmp	#4, R0
		beq	xt13b
		emt	+2
xt13b:		br	xnext

xbuf:		.word	0, 0, 0, 0
xpat0:		.word	0, 0, 0, 0
xpat1:		.word	1, 1, 1, 1
xpat2:		.word	40401, 0, 0, 0
xpat3:		.word	100000,	0, 0, 0
xpat4:		.word	040400,	0, 0, 0
xpat5:		.word	207, 0,	0, 0
xpat6:		.word	77007, 0, 0, 0
xpato:		.word	0, 0, 0, 0
xnext:

		.sbttl "END OF PASS ROUTINE"
;_____________________________________________________________________________
;
; increment the	pass number ($pass)
; indicate end-of-program after	1 pass thru the	program
; type "end pass #xxxxx" (where	xxxxx is a decimal number)
; if sw12=1 inhibit trace trap
; if there is a	monitor	go to it
; if there isn't jump to loop
;
$eop:		scope
		clr	$tstnm			; zero the test	number
		clr	$times			; zero the number of iterations
		inc	$pass			; increment the	pass number
		bic	#100000, $pass		; don't	allow a	negative pass number
		dec	(PC)+			; loop?
$eopct:		.word	1			; 1 pass first time (qv)!!
		bgt	$doagn			; yes
		mov	(PC)+, @(PC)+		; restore counter
$endct:		.word	1
		$eopct
		type	, $endmg		; type "end pass #"
.if ne HOEP					;
		halt				; halt on end-of-pass
		nop				;
.iff						;
		mov	$pass, -(SP)		; save pass count for typeout
.endc						;
		typds				; type pass count in decimal
		type	, $enull		; type a null character	string
$get42:		mov	@#42, R0		; get monitor address
		beq	doagin			; branch if no monitor
		clr	-(SP)			; insure the T-bit is clear
		mov	#$clr.t, -(SP)		; setup	for an rti or rtt
		br	$rtrn			; go do	an rti or rtt to load the PSW
						; with a cleared T-bit
$clr.t:		reset				; clear	the world
$endad:		jsr	pc, (R0)		; go to	the monitor
		nop				; save room
		nop				; for
		nop				; ACT-11
doagin:		mov	@#4, @#$tmp0		; save contents	of location 4
		mov	#1$, @#4		; set up incase	of trap
		mov	#1, @#164000		; notify multi-tester
		br	2$			; no trap so don't reset stack
1$:		add	#4, SP			; reset	stack after trap
2$:		mov	@#$tmp0, @#4		; restore contents of location 4
$doagn:		trap				; push old PSW and PC on stack
		bic	#20, (SP)		; clear	the T-bit
		bit	#bit12,	@swr		; run with trace trap?
		bne	1$			; branch if no
		com	$tbit			; is it	time for trace trap
		bmi	1$			; branch if no
		bis	#20, (SP)		; set trace trap
1$:		mov	#$loop,	-(SP)		; return here from rti
$rtrn:		rti				; return-this is changed to an "rtt"
						; if it	is a legal instruction
$loop:		jmp	@(PC)+			; return to testing
$rtnad:		.word	loop
$tbit:		.word	0			; T-bit	state indicator
$enull:		.byte	-1, -1,	0		; null character string
$endmg:		.asciz	<15><12>/END PASS #/
		.even				;

		.sbttl "SCOPE HANDLER ROUTINE"
;_____________________________________________________________________________
;
; This routine controls	the looping of subtests. It will increment
; and load the test number ($tstnm) into the display reg. (display<7:0>)
; and load the error flag ($erflg) into	display	<15:08>
; She switch options provided by this routine are:
; sw14=1	loop on	test
; sw11=1	inhibit	iterations
; sw9=1		loop on	error
; sw8=1		loop on	test in	swr<7:0>
; Call
;		scope				; scope=iot
;
$scope:
		ckswr				; test for change in soft-swr
1$:		bit	#bit14,	@swr		; loop on present test?
		bne	$over			; yes if sw14=1
; #####start of	code for the xor tester#####
$xtstr:		br	6$			; if running on	the "xor" tester change
						; this instruction to a	"nop" (nop=240)
		mov	@#errvec, -(SP)		; save the contents of the error vector
		mov	#5$, @#errvec		; set for timeout
		tst	@#177060		; time out on xor?
		mov	(SP)+, @#errvec		; restore the error vector
		br	$svlad			; go to	the next test
5$:		cmp	(SP)+, (SP)+		; clear	the stack after	a time out
		mov	(SP)+, @#errvec		; restore the error vector
		br	7$			; loop on the present test
6$:
; #####end of code for the xor tester#####
		bit	#bit8, @swr		; loop on spec.	test?
		beq	2$			; br if	no
		cmpb	@swr, $tstnm		; on the right test? swr<7:0>
		beq	$over			; br if	yes
2$:		tstb	$erflg			; has an error occurred?
		beq	3$			; br if	no
		cmpb	$ermax,	$erflg		; max. errors for this test occurred?
		bhi	3$			; br if	no
		bit	#bit9, @swr		; loop on error?
		beq	4$			; br if	no
7$:		mov	$lperr,	$lpadr		; set loop address to last scope
		br	$over
4$:		clrb	$erflg			; zero the error flag
		clr	$times			; clear	the number of iterations to make
		br	1$			; escape to the	next test
3$:		bit	#bit11,	@swr		; inhibit iterations?
		bne	1$			; br if	yes
		tst	$pass			; if first pass	of program
		beq	1$			; inhibit iterations
		inc	$icnt			; increment iteration count
		cmp	$times,	$icnt		; check	the number of iterations made
		bge	$over			; br if	more iteration required
1$:		mov	#1, $icnt		; reinitialize the iteration counter
		mov	$mxcnt,	$times		; set number of	iterations to do
$svlad:		incb	$tstnm			; count	test numbers
		movb	$tstnm,	$testn		; set test number in apt mailbox
		mov	(SP), $lpadr		; save scope loop address
		mov	(SP), $lperr		; save error loop address
		clr	$escape			; clear	the escape from	error address
		movb	#1, $ermax		; only allow one(1) error on next test
$over:		mov	$tstnm,	@display	; display test number
		mov	$lpadr,	(SP)		; fudge	return address
		rti				; fixes	PS
$mxcnt:		1				; max. number of iterations

		.sbttl "ERROR HANDLER ROUTINE"
;_____________________________________________________________________________
;
; This routine will increment the error	flag and the error count.
; Save the error item number and the address of	the error call
; and go to errtyp on error
; The switch options provided by this routine are:
; sw15=1	halt on	error
; sw13=1	inhibit	error typeouts
; sw10=1	bell on	error
; sw9=1		loop on	error
; Call
;		error	n			; error=emt and	n=error	item number
;
$error:
		ckswr				; test for change in soft-swr
7$:		incb	$erflg			; set the error	flag
		beq	7$			; don't	let the	flag go	to zero
		mov	$tstnm,	@display	; display test number and error	flag
		bit	#bit10,	@swr		; bell on error?
		beq	1$			; no - skip
		type	, $bell			; ring bell
1$:		inc	$erttl			; count	the number of errors
		mov	(SP), $errpc		; get address of error instruction
		sub	#2, $errpc
		movb	@$errpc, $itemb		; strip	and save the error item	code
		bit	#bit13,	@swr		; skip typeout if set
		bne	20$			; skip typeouts
		jsr	pc, ertype		; go to	user error routine
		type	, $crlf
20$:
		cmpb	#aptenv, $env		; running in apt mode
		bne	2$			; no, skip apt error report
		movb	$itemb,	21$		; set item number as error number
		jsr	pc, $aty4		; report fatal error to	apt
21$:		.byte	0
		.byte	0
22$:		br	22$			; APT error loop
2$:		tst	@swr			; halt on error
		bpl	3$			; skip if continue
		halt				; halt on error!
		ckswr				; test for change in soft-swr
3$:		bit	#bit9, @swr		; loop on error	switch set?

		beq	4$			; br if	no
		mov	$lperr,	(SP)		; fudge	return for looping
4$:		tst	$escape			; check	for an escape address
		beq	5$			; br if	none
		mov	$escape, (SP)		; fudge	return address for escape
5$:
		cmp	#$endad, @#42		; APT-11 auto-accept?
		bne	6$			; branch if no
		halt				; yes
6$:
		rti				; return

		.sbttl "SAVE AND RESTORE R0-R5 ROUTINES"
;_____________________________________________________________________________
;
; Save R0-R5
; Call:
;		savreg
; Upon return from $savreg the stack will look like:
; top---(+16)
;  +2---(+18)
;  +4---R5
;  +6---R4
;  +8---R3
; +10---R2
; +12---R1
; +14---R0
;
$savreg:
		mov	R0, -(SP)		; push R0 on stack
		mov	R1, -(SP)		; push R1 on stack
		mov	R2, -(SP)		; push R2 on stack
		mov	R3, -(SP)		; push R3 on stack
		mov	R4, -(SP)		; push R4 on stack
		mov	R5, -(SP)		; push R5 on stack
		mov	22(SP),	-(SP)		; save PS of main flow
		mov	22(SP),	-(SP)		; save PC of main flow
		mov	22(SP),	-(SP)		; save PS of call
		mov	22(SP),	-(SP)		; save PC of call
		rti

; Restore R0-R5
; Call:
;		resreg
;
$resreg:
		mov	(SP)+, 22(SP)		; restore PC of	call
		mov	(SP)+, 22(SP)		; restore PS of	call
		mov	(SP)+, 22(SP)		; restore PC of	main flow
		mov	(SP)+, 22(SP)		; restore PS of	main flow
		mov	(SP)+, R5		; pop stack into R5
		mov	(SP)+, R4		; pop stack into R4
		mov	(SP)+, R3		; pop stack into R3
		mov	(SP)+, R2		; pop stack into R2
		mov	(SP)+, R1		; pop stack into R1
		mov	(SP)+, R0		; pop stack into R0
		rti

		.sbttl "TYPE ROUTINE"
;_____________________________________________________________________________
;
; Routine to type asciz	message. message must terminate	with a 0 byte.
; The routine will insert a number of null characters after a line feed.
; Note1:		$null contains the character to	be used	as the filler character.
; Note2:		$pills contains	the number of filler characters	required.
; Note3:		$fillc contains	the character to fill after.
;
; Call:
; 1) using a trap instruction
;		type	, mesadr		; mesadr is first address of an	asciz string
; or						;
;		type				;
;		mesadr				;
;
$type:		tstb	$tpflg			; is there a terminal?
		bpl	1$			; br if	yes
		halt				; halt here if no terminal
		br	3$			; leave
1$:		mov	R0, -(SP)		; save R0
		mov	@2(SP),	R0		; get address of asciz string
		cmpb	#aptenv, $env		; running in APT mode
		bne	62$			; no, go check for APT console
		bitb	#aptspool, $envm	; spool	message	to APT
		beq	62$			; no, go check for console
		mov	R0, 61$			; setup	message	address	for APT
		jsr	pc, $aty3		; spool	message	to APT
61$:		.word	0			; message address
62$:		bitb	#aptcsup, $envm		; APT console suppressed
		bne	60$			; yes, skip type out
2$:		movb	(R0)+, -(SP)		; push character to be typed on	to stack
		bne	4$			; br if	it isn't the terminator
		tst	(SP)+			; if terminator	pop it off the stack
60$:		mov	(SP)+, R0		; restore R0
3$:		add	#2, (SP)		; adjust return	PC
		rti				; return
4$:		cmpb	#ht, (SP)		; branch if <ht>
		beq	8$
		cmpb	#crlf, (SP)		; branch if not	<crlf>
		bne	5$
		tst	(SP)+			; pop <cr><lf> equiv
		type				; type a cr and	lf
		$crlf
		clrb	$charcnt		; clear	character count
		br	2$			; get next character
5$:		jsr	pc, $typec		; go type this character
6$:		cmpb	$fillc,	(SP)+		; is it	time for filler	chars.?
		bne	2$			; if no	go get next char.
		mov	$null, -(SP)		; get #	of filler chars. needed
						; and the null char.
7$:		decb	1(SP)			; does a null need to be typed?
		blt	6$			; br if	no go pop the null off of stack
		jsr	pc, $typec		; go type a null
		decb	$charcnt		; do not count as a count
		br	7$			; loop

; horizontal tab processor
8$:		movb	#' , (SP)		; replace tab with space
9$:		jsr	pc, $typec		; type a space
		bitb	#7, $charcnt		; branch if not	at
		bne	9$			; tab stop
		tst	(SP)+			; pop space off	stack
		br	2$			; get next character
$typec:		tstb	@$tps			; wait until printer is	ready
		bpl	$typec
		movb	2(SP), @$tpb		; load char to be typed	into data reg.
		cmpb	#cr, 2(SP)		; is character a carriage return?
		bne	1$			; branch if no
		clrb	$charcnt		; yes-clear character count
		br	$typex			; exit
1$:		cmpb	#lf, 2(SP)		; is character a line feed?
		beq	$typex			; branch if yes
		incb	(PC)+			; count	the character
$charcnt:	.word	0			; character count storage
$typex:		rts	pc

		.sbttl "BINARY TO OCTAL (ASCII) AND TYPE"
;_____________________________________________________________________________
; This routine is used to change a 16-bit binary number	to a 6-digit
; octal	(ascii)	number and type	it.
; $typos enter here to setup suppress zeros and	number of digits to type
; Call:
;		mov	num, -(SP)		; number to be typed
;		typos				; call for typeout
;		.byte	n			; n=1 to 6 for number of digits	to type
;		.byte	m			; m=1 or 0
;						; 1=type leading zeros
;						; 0=suppress leading zeros
;
; $typon - enter here to type out with the same	parameters as the last
; $typos or $typoc
; Call:
;		mov	num, -(SP)		; number to be typed
;		typon				; call for typeout
;
; $typoc - enter here for typeout of a 16 bit number
; Call:
;		mov	num, -(SP)		; number to be typed
;		typoc				; call for typeout
;
$typos:		mov	@(SP), -(SP)		; pickup the mode
		movb	1(SP), $ofill		; load zero fill switch
		movb	(SP)+, $omode+1		; number of digits to type
		add	#2, (SP)		; adjust return	address
		br	$typon
$typoc:		movb	#1, $ofill		; set the zero fill switch
		movb	#6, $omode+1		; set for six(6) digits
$typon:		movb	#5, $ocnt		; set the iteration count
		mov	R3, -(SP)		; save R3
		mov	R4, -(SP)		; save R4
		mov	R5, -(SP)		; save R5
		movb	$omode+1, R4		; get the number of digits to type
		neg	R4
		add	#6, R4			; subtract it for max. allowed
		movb	R4, $omode		; save it for use
		movb	$ofill,	R4		; get the zero fill switch
		mov	12(SP),	R5		; pickup the input number
		clr	R3			; clear	the output word
1$:		rol	R5			; rotate msb into "c"
		br	3$			; go do	msb
2$:		rol	R5			; form this digit
		rol	R5
		rol	R5
		mov	R5, R3
3$:		rol	R3			; get lsb of this digit
		decb	$omode			; type this digit?
		bpl	7$			; br if	no
		bic	#177770, R3		; get rid of junk
		bne	4$			; test for 0
		tst	R4			; suppress this	0?
		beq	5$			; br if	yes
4$:		inc	R4			; don't	suppress anymore 0's
		bis	#'0, R3			; make this digit ascii
5$:		bis	#' , R3			; make ascii if	not already
		movb	R3, 8$			; save for typing
		type	, 8$			; go type this digit
7$:		decb	$ocnt			; count	by 1
		bgt	2$			; br if	more to	do
		blt	6$			; br if	done
		inc	R4			; insure last digit isn't a blank
		br	2$			; go do	the last digit
6$:		mov	(SP)+, R5		; restore R5
		mov	(SP)+, R4		; restore R4
		mov	(SP)+, R3		; restore R3
		mov	2(SP), 4(SP)		; set the stack	for returning
		mov	(SP)+, (SP)
		rti				; return
8$:		.byte	0			; storage for ascii digit
		.byte	0			; terminator for type routine
$ocnt:		.byte	0			; octal	digit counter
$ofill:		.byte	0			; zero fill switch
$omode:		.word	0			; number of digits to type

		.sbttl "CONVERT BINARY TO DECIMAL AND TYPE ROUTINE"
;_____________________________________________________________________________
; This routine is used to change a 16-bit binary number	to a 5-digit
; signed decimal (ascii) number	and type it. Depending on whether the
; number is positive or	negative a space or a minus sign will be typed
; before the first digit of the	number.	Leading	zeros will always be
; replaced with	spaces.
; Call:
;		mov	num, (SP)		; put the binary number	on the stack
;		typds				; go to	the routine
;
$typds:
		mov	R0, -(SP)		; push R0 on stack
		mov	R1, -(SP)		; push R1 on stack
		mov	R2, -(SP)		; push R2 on stack
		mov	R3, -(SP)		; push R3 on stack
		mov	R5, -(SP)		; push R5 on stack
		mov	#20200,	-(SP)		; set blank switch and sign
		mov	20(SP),	R5		; get the input	number
		bpl	1$			; br if	input is pos.
		neg	R5			; make the binary number pos.
		movb	#'-, 1(SP)		; make the ascii number	neg.
1$:		clr	R0			; zero the constants index
		mov	#$dblk,	R3		; setup	the output pointer
		movb	#' , (R3)+		; set the first	character to a blank
2$:		clr	R2			; clear	the bcd	number
		mov	$dtbl(R0), R1		; get the constant
3$:		sub	R1, R5			; form this bcd	digit
		blt	4$			; br if	done
		inc	R2			; increase the bcd digit by 1
		br	3$			;
4$:		add	R1, R5			; add back the constant
		tst	R2			; check	if bcd digit=0
		bne	5$			; fall through if 0
		tstb	(SP)			; still	doing leading 0's?
		bmi	7$			; br if	yes
5$:		aslb	(SP)			; msd?
		bcc	6$			; br if	no
		movb	1(SP), -1(R3)		; yes-set the sign
6$:		bis	#'0, R2			; make the bcd digit ascii
7$:		bis	#' , R2			; make it a space if not already a digit
		movb	R2, (R3)+		; put this character in	the output buffer
		tst	(R0)+			; just incrementing
		cmp	R0, #10			; check	the table index
		blt	2$			; go do	the next digit
		bgt	8$			; go to	exit
		mov	R5, R2			; get the lsd
		br	6$			; go change to ascii
8$:		tstb	(SP)+			; was the lsd the first	non-zero?
		bpl	9$			; br if	no
		movb	-1(SP),	-2(R3)		; yes-set the sign for typing
9$:		clrb	(R3)			; set the terminator
		mov	(SP)+, R5		; pop stack into R5
		mov	(SP)+, R3		; pop stack into R3
		mov	(SP)+, R2		; pop stack into R2
		mov	(SP)+, R1		; pop stack into R1
		mov	(SP)+, R0		; pop stack into R0
		type	, $dblk			; now type the number
		mov	2(SP), 4(SP)		; adjust the stack
		mov	(SP)+, (SP)		;
		rti				; return to user
$dtbl:		10000.				;
		1000.				;
		100.				;
		10.				;
$dblk:		.blkw	4			;

		.sbttl "APT COMMUNICATIONS ROUTINE"

$aty1:		movb	#1, $fflg		; to report fatal error
$aty3:		movb	#1, $mflg		; to type a message
		br	$atyc
$aty4:		movb	#1, $fflg		; to only report fatal error
$atyc:
		mov	R0, -(SP)		; push R0 on stack
		mov	R1, -(SP)		; push R1 on stack
		tstb	$mflg			; should type a	message?
		beq	5$			; if not: br
		cmpb	#aptenv, $env		; operating under APT?
		bne	3$			; if not: br
		bitb	#aptspool, $envm	; should spool messages?
		beq	3$			; if not: br
		mov	@4(SP),	R0		; get message addr.
		add	#2, 4(SP)		; bump return addr.
1$:		tst	$msgtype		; see if done w/ last xmission?
		bne	1$			; if not: wait
		mov	R0, $msgad		; put addr in mailbox
2$:		tstb	(R0)+			; find end of message
		bne	2$
		sub	$msgad,	R0		; sub start of message
		asr	R0			; get message lngth in words
		mov	R0, $msglgt		; put length in	mailbox
		mov	#4, $msgtype		; tell APT to take msg.
		br	5$
3$:		mov	@4(SP),	4$		; put msg addr in jsr linkage
		add	#2, 4(SP)		; bump return address
		mov	177776,	-(SP)		; push 177776 on stack
		jsr	pc, $type		; call type macro
4$:		.word	0
5$:
10$:		tstb	$fflg			; should report	fatal error?
		beq	12$			; if not: br
		tst	$env			; running under	APT?
		beq	12$			; if not: br
11$:		tst	$msgtype		; finished last	message?
		bne	11$			; if not: wait
		mov	@4(SP),	$fatal		; get error #
		add	#2, 4(SP)		; bump return addr.
		inc	$msgtype		; tell APT to take error
12$:		clrb	$fflg			; clear	fatal flag
		clrb	$lflg			; clear	log flag
		clrb	$mflg			; clear	message	flag
		mov	(SP)+, R1		; pop stack into R1
		mov	(SP)+, R0		; pop stack into R0
		rts	pc			; return
$mflg:		.byte	0			; messg. flag
$lflg:		.byte	0			; log flag
$fflg:		.byte	0			; fatal	flag
		.even
		aptsize	= 200
		aptenv	= 001
		aptspool= 100
		aptcsup	= 040

		.sbttl "TTY INPUT ROUTINE"

		.enabl lsb

; Software switch register change routine.
; Routine is entered from the trap handler, and	will
; Service the test for change in software switch register trap call
; when operating in tty	flag mode.
$ckswr:		cmp	#swreg,	swr		; is the soft-swr selected?
		bne	15$			; branch if no
		tstb	@$tks			; char there?
		bpl	15$			; if no, don't wait around
		movb	@$tkb, -(SP)		; save the char
		bic	#^c177,	(SP)		; strip-off the	ascii
		cmp	#7, (SP)+		; is it	a Control-G?
		bne	15$			; no, return to	user
		cmpb	$autob,	#1		; are we running in auto-mode?
		beq	15$			; branch if yes
		type	, $cntlg		; echo the Control-G (^G)
$gtswr:		type	, $mswr			; type current contents
		mov	swreg, -(SP)		; save swreg for typeout
		typoc				; go type - octal ascii	(all digits)
		type	, $mnew			; prompt for new swr
19$:		clr	-(SP)			; clear	counter
		clr	-(SP)			; the new swr
7$:		tstb	@$tks			; char there?
		bpl	7$			; if not try again
		movb	@$tkb, -(SP)		; pick up char
		bic	#^c177,	(SP)		; make it 7-bit	ascii
9$:		cmp	(SP), #25		; is it	a Control-U?
		bne	10$			; branch if not
		type	, $cntlu		; yes, echo Control-U (^U)
20$:		add	#6, SP			; ignore previous input
		br	19$			; let's	try it again
10$:		cmp	(SP), #15		; is it	a <cr>?
		bne	16$			; branch if no
		tst	4(SP)			; yes, is it the first char?
		beq	11$			; branch if yes
		mov	2(SP), @swr		; save new swr
11$:		add	#6, SP			; clear	up stack
14$:		type	, $crlf			; echo <cr> and	<lf>
		cmpb	$intag,	#1		; re-enable tty	kbd interrupts?
		bne	15$			; branch if not
		mov	#100, @$tks		; re-enable tty	kbd interrupts
15$:		rti				; return
16$:		jsr	pc, $typec		; echo char
		cmp	(SP), #60		; char < 0?
		blt	18$			; branch if yes
		cmp	(SP), #67		; char > 7?
		bgt	18$			; branch if yes
		bic	#60, (SP)+		; strip-off ascii
		tst	2(SP)			; is this the first char
		beq	17$			; branch if yes
		asl	(SP)			; no, shift present
		asl	(SP)			; char over to make
		asl	(SP)			; room for new one.
17$:		inc	2(SP)			; keep count of	char
		bis	-2(SP),	(SP)		; set in new char
		br	7$			; get the next one
18$:		type	, $ques			; type ?<cr><lf>
		br	20$			; simulate Control-U

		.dsabl lsb

; this routine will input a single character from the tty
; call:
;		rdchr				; input	a single character from	the tty
;		return	here			; character is on the stack
;						; with parity bit stripped off
;
$rdchr:		mov	(SP), -(SP)		; push down the	PC
		mov	4(SP), 2(SP)		; save the PS
1$:		tstb	@$tks			; wait for
		bpl	1$			; a character
		movb	@$tkb, 4(SP)		; read the tty
		bic	#^c<177>, 4(SP)		; get rid of junk if any
		cmp	4(SP), #23		; is it	a Control-S?
		bne	3$			; branch if no
2$:		tstb	@$tks			; wait for a character
		bpl	2$			; loop until its there
		movb	@$tkb, -(SP)		; get character
		bic	#^c177,	(SP)		; make it 7-bit	ascii
		cmp	(SP)+, #21		; is it	a Control-Q?
		bne	2$			; if not discard it
		br	1$			; yes, resume
3$:		cmp	4(SP), #140		; is it	upper case?
		blt	4$			; branch if yes
		cmp	4(SP), #175		; is it	a special char?
		bgt	4$			; branch if yes
		bic	#40, 4(SP)		; make it upper	case
4$:		rti				; go back to user
$cntlu:		.asciz	/^U/<15><12>		; Control-U
$cntlg:		.asciz	/^G/<15><12>		; Control-G
$mswr:		.asciz	<15><12>/SWR = /
$mnew:		.asciz	/  NEW = /

		.sbttl "TRAP DECODER"
;_____________________________________________________________________________
;
; This routine will pickup the lower byte of the "trap"	instruction
; and use it to	index through the trap table for the starting address
; of the desired routine. Then using the address obtained it will
; go to	that routine.
;
$trap:		mov	R0, -(SP)		; save R0
		mov	2(SP), R0		; get trap address
		tst	-(R0)			; backup by 2
		movb	(R0), R0		; get right byte of trap
		asl	R0			; position for indexing
		mov	$trpad(R0), R0		; index	to table
		rts	R0			; go to	routine
	; this is use to handle	the "getpri" macro
$trap2:		mov	(SP), -(SP)		; move the PC down
		mov	4(SP), 2(SP)		; move the PSW down
		rti				; restore the PSW

		.sbttl "TRAP TABLE"
;_____________________________________________________________________________
;
; This table contains the starting addresses of	the routines called
; by the "trap"	instruction.
;
; routine
;
$trpad:		.word	$trap2
		$type			; call=type	trap+1(104401) tty typeout routine
		$typoc			; call=typoc	trap+2(104402) type octal number (with leading zeros)
		$typos			; call=typos	trap+3(104403) type octal number (no leading zeros)
		$typon			; call=typon	trap+4(104404) type octal number (as per last call)
		$typds			; call=typos	trap+5(104405) type decimal number (with sign)
		$gtswr			; call=gtswr	trap+6(104406) get soft-swr setting
		$ckswr			; call=ckswr	trap+7(104407) test for	change in soft-swr
		$rdchr			; call=rdchr	trap+10(104410)	tty type in character routine
		$savreg			; call=savreg	trap+11(104411)	save R0-R5 routine
		$resreg			; call=resreg	trap+12(104412)	restore	R0-R5 routine
		.rset			; call=rsetup	trap+13(104413)	routine	to initialize at end of	each test
		.lper			; call=lperr	trap+14(104414)	routine	to set up loop on error	address
		$term	= .-$trpad


		.sbttl "POWER DOWN AND UP ROUTINES"

	; power	down routine
$pwrdn:		mov	#$illup, @#pwrvec	; set for fast up
		mov	#340, @#pwrvec+2	; prio:7
		mov	R0, -(SP)		; push R0 on stack
		mov	R1, -(SP)		; push R1 on stack
		mov	R2, -(SP)		; push R2 on stack
		mov	R3, -(SP)		; push R3 on stack
		mov	R4, -(SP)		; push R4 on stack
		mov	R5, -(SP)		; push R5 on stack
		mov	@swr, -(SP)		; push aswr on stack
		mov	sp, $savr6		; save SP
		mov	#$pwrup, @#pwrvec	; set up vector
		halt
		br	.-2			; hang up

	; power	up routine
$pwrup:		mov	#$illup, @#pwrvec	; set for fast down
		mov	$savr6,	SP		; get SP
		clr	$savr6			; wait loop for	the tty
1$:		inc	$savr6			; wait for the inc
		bne	1$			; of word
		mov	(SP)+, @swr		; pop stack into @swr
		mov	(SP)+, R5		; pop stack into R5
		mov	(SP)+, R4		; pop stack into R4
		mov	(SP)+, R3		; pop stack into R3
		mov	(SP)+, R2		; pop stack into R2
		mov	(SP)+, R1		; pop stack into R1
		mov	(SP)+, R0		; pop stack into R0
		mov	#$pwrdn, @#pwrvec	; set up the power down	vector
		mov	#340, @#pwrvec+2	; prio:7
		type				; report the power failure
$pwrmg:		.word	powerm			; power	fail message pointer
		mov	(PC)+, (SP)		; restart at start
$pwrad:		.word	start			; restart address
		bic	#20, 2(SP)		; clear	T-bit
		clr	$tbit			; clear	the T-bit flag
		rti
$illup:		halt				; the power up sequence	was started
		br	.-2			; before the power down	was complete
$savr6:		0				; put the SP here

		.sbttl "ERROR TYPE OUT ROUTINE"
;_____________________________________________________________________________
;
; this routine is called to type an error message which	is included
; in the error message data table. it is called	by the $error routine
; or by	first setting $itemb equal to the error	table item to be printed
; out and then executing a:
;		jsr	pc, ertype
;
ertype:		type				; type a crlf
		.word	$crlf
		movb	@#$tstnm, @#$tmp0
		bic	#177400, @#$tmp0
		mov	@#$errpc, @#$tmp1	; get PC of call
		mov	R0, -(SP)		; save R0
		movb	@#$itemb, R0		; get the item number.
		bic	#177400, R0
		bne	mult
pctyp:		type	, emsg
		mov	@#$errpc, -(SP)		; if zero then just
		typoc				; print	the PC
		jmp	@#ert5
mult:		dec	R0			; otherwise mult R0 by 2 to
						; get error message pointer
		asl	R0
		add	#$errtb, R0
		mov	(R0), @#2$		; pick up the address
		beq	ert5			; of the emt error message
		type
2$:		.word	0
		type
		.word	$crlf
		br	pctyp
ert5:		mov	(SP)+, R0		; restore R0.
		rts	pc			; and return.

emsg:		.asciz	/FLOATING POINT ERROR, STOPPED AT PC= /
		.even

		.sbttl "FPP SPURIOUS TRAP TO 244 HANDLER"
;_____________________________________________________________________________
;
; This routine handles unexpected traps	to the FPP trap	vector at 244.
; The last FPP instruction executed and	its address has	been recorded
; these	along with the fec, fps	and PC of trap are reported.
;
fpspur:		mov	(SP), @#$tmp2		; save PC of trap.
		cmp	(SP)+, (SP)+		; restore SP.
		stfps	R0			; get fps
		mov	R0, @#$tmp3
		stst	R0			; get fec
		mov	R0, @#$tmp4
1$:		emt	+1			; most likely bad FP1 chip
		rsetup
		jmp	@#$eop

		.sbttl "CPU SPURIOUS TRAP TO 4 HANDLER"
;_____________________________________________________________________________
;
; This routine reports unexpected cpu traps to vector 4.
;
cpspur:		mov	(SP), @#$tmp2		; save PC of trap.
		cmp	(SP)+, (SP)+
1$:		emt	+4
		rsetup
		jmp	@#$eop

		.sbttl "CPU SPURIOUS TRAP TO 10 HANDLER"
;_____________________________________________________________________________
;
; This routine reports unexpected cpu traps to vector 10.
;
cptwo:		mov	(SP), @#$tmp2		; save PC of trap.
		cmp	(SP)+, (SP)+
1$:		emt	+2
		rsetup
		jmp	@#$eop

		.sbttl "SET LOOP ON ERROR ADDRESS ROUTINE"

.lper:		mov	(SP), @#$lperr
		rti

		.sbttl "FLAG RESET AND CONSOLE TEST ROUTINE"
;_____________________________________________________________________________
;
; This routine will be called at the end of each test to
; reset	the stack, clear the fps and see if the	user has typed
; Control-G on the terminal. If	the user has typed Control-G and
; there	is no physical console switch register then the	contents
; of the software switch register will be typed	in octal on the
; teletype and the user	can modify it.
;
.rset:		cmp	@#swr, #177570		; see if there is a physical
						; console switch register.
		bne	1$			; branch if no.
		ckswr				; otherwise type the contents

						; of the program virtual switch	register
						; and give the user a chance to
						; modify it.
1$:		mov	#fpspur, @#fpvect
		mov	#cpspur, @#errvect
		mov	#cptwo,	@#10
		mov	(SP), R0		; save return address.
		mov	#stack,	SP		; reset	the stack pointer.
		clr	R4			; clear	the fps.
		ldfps	R4
		jmp	(R0)			; return.

		.nlist bex

; special messages:
powerm:		.asciz	<CRLF>/POWER FAILURE. PROGRAM RESTARTING./<CRLF>
null:		.byte	0
$tab:		.asciz	<TAB>
space:		.asciz	/  /

; error	messages:
em1:		.asciz	/PROBABLY BAD FP1 CHIP/
em2:		.asciz	/PROBABLY BAD HYBRID FP CHIP/
em3:		.asciz	/PROBABLY BAD MMU CHIP/
em4:		.asciz	/PROBABLY BAD MMU OR HYBRID FP CHIPS/
;_____________________________________________________________________________
;
		.end
