; Originally was compiled by MACY-11, an assembler running on the PDP-10.
; The source is adapted to be translated by regular MACRO-11.
;
;			IDENTIFICATION
;			--------------
;
; Product code:		AC-F244B-MC
; Product name:		CJKDDB0 KEF11-AA DIAG #2
; Date:			Nov-79
; Maintainer:		Diagnostic Engineering
;
; The information in this document is subject to change without notice
; and should not be construed as a commitment by Digital Equipment
; Corporation. Digital Equipment Corporation assumes no responsibility
; for any errors that may appear in this document.
;
; The software described in this document is furnished to the purchaser
; under a license for use on a single computer system and can be copied
; (with inclusion of Digital's copyright notice) only for use in such
; system, except as may otherwise be provided in writing by Digital.
;
; Digital equipment corporation assumes no responsibility for the use
; or reliability of its software on equipment that is not supplied by
; Digital.
;
; Copyright (c) 1979 Digital Equipment Corp., Maynard, Mass. 01754
;
; Program history:
;
; Date		    Revision	Reason for revision
;
; June, 1979		A	First release. This program was assembled
;				using the PDP-11 maindec sysmac package
;				(maindec-11-dzqac-c3), Jan 19, 1977.
; November, 1979	B	Corrections were made to multi-tester
;				support code.
;_____________________________________________________________________________
;
;			CONTENTS
;			--------
; 1.0	Abstract.
; 2.0	Requirements.
; 2.1	Equipment.
; 2.2	Storage.
; 2.3	Preliminary programs.
; 3.0	Loading procedure.
; 4.0	Starting procedure.
; 4.1	Control switch settings.
; 4.2	Starting address.
; 4.3	Program and operator interaction.
; 5.0	Operating procedure.
; 5.1	Operational switch settings.
; 5.3	Operator action.
; 6.0	Errors.
; 6.1	Summary.
; 6.2	Error recovery.
; 7.0	Restrictions.
; 7.1	Starting restrictions.
; 7.2	Operating restrictions.
; 8.0	Miscellaneous.
; 8.1	Execution times.
; 8.2	Stack pointer.
; 8.3	Pass count.
; 8.4	T-bit trapping.
; 8.5	Software switch register.
; 8.6	ACT, APT and XXDP compatibility.
; 9.0	Program description.
; 9.1	CJKDCA
; 10.0	Listing
; 10.1	CJKDCA
;
; 1.0	Abstract
;
;	The two programs:
;
;	CJKDCB, CJKDDB
;
;	Are design to detect and report logic faults in the
;	F-11 MMU and floating point chip set. The
;	design is an attempt to reach all mirco-code locations.
;	Tests are partitioned into two stand-alone programs
;	described below.
;
;	Note that error reports in these programs are based
;	upon the knowledge that all previous tests (CPU, MMU, FP1)
;	have been run and in most case that there is only a single
;	point fault exists. If the programs or tests
;	are not run in order then error messages may not be
;	accurate.
;
;	A. CJKDCA
;
;	CJKDCA tests: (floating point test 1)
;		ldfps
;		stfps
;		cfcc
;		setf, setd, seti and setl
;		stst
;		ldf and ldd (all source modes)
;		std (mode 0 and 1)
;		addf, addd and subd (most conditions)
;		addf, addd and subd (all conditions not
;				tested in dffpa)
;		cmpd and cmpf
;		divd and divf
;		muld and mulf
;		modd and modf
;
;	B. CJKDDB
;
;	CJKDDB tests: (floating point test 2)
;
;		stf and std (all modes)
;		stcfd and stcdf
;		clrd and clrf
;		negf and negd
;		absf and absd
;		tstf and tstd
;		negf, absf and tstf (all source modes)
;		negf, absf and tstf (all source modes)
;		ldfps (all source modes)
;		ldcif and ldclf
;		ldcid and ldcld
;		ldexp
;		stfps (all destination modes)
;		stcfl and stcfi
;		stcdl and stcdi
;		stexp
;		stst
;
; 2.0	Requirements
;
; 2.1	Equipment
;
;	A processor using the DCF11-AA, KTF11-AA and KEF11-A chip set.
;
; 2.2	Storage
;
;	Both programs require a memory system of at
;	least 16k to load and run.
;
; 2.3	Preliminary programs
;
;	These two diagnostics will assume that the
;	basic central processor is faultless, therefore
;	when in doubt run the DCF11-AA processor diag-
;	nostics before these floating point diagnostics.
;
; 3.0	Loading procedure
;
;	The programs will be supplied on the 11/23
;	diagnostic media. Refer to the XXDP operating
;	manual for further information.
;
; 4.0	Starting procedure
;
; 4.1	Control switch settings
;
;	See section 5.1
;
; 4.2	Program and operator action
;
;	1.	Load program into memory
;	2.	Load address 200
;	3.	Set console switches (if console is present)
;	4.	Press start
;		on first pass the program
;		will identify itself. Note that if there is
;		no physical console the program will request
;		the operator for initial value for the
;		software switch register (see section 8.5).
;		If running under ACT, APT or chain this does
;		not apply.
;	5.	The program will loop and an end of pass will
;		be typed at the end of every pass.
;
; 5.0	Operating procedure
;
; 5.1	Operational switch settings
;
;	The switch setting are:
;
;			Octal
;	sw<15>=1...	100000	Halt on error
;	sw<14>=1...	 40000	Loop on current test
;	sw<13>=1...	 20000	Inhibit error type outs
;	sw<12>=1...	 10000	Inhibit T-bit trapping
;	sw<11>=1...	  4000	Inhibit iterations
;	sw<10>=1...	  2000	Ring TTY bell on error
;	sw<9>=1....	  1000	Loop on error
;	sw<8>=1....	   400	Loop on test specified in sw<6>
;				through sw<0>
;
; 6.0	Errors
;
; 6.1	Summaries
;
;	When an error is encountered, an error message accompanied
;	by the error PC are typed.
;	There are four standard error messages used, describing
;	the probable cause of failure, such as: probably bad MMU chip;
;	bad FP1 chip; bad hybrid FP chip; floating point error.
;
; 6.2	Error recovery
;
;	sw<15:9>=0...	Most errors will cause execution to
;			go to the start of the next test
;			after the message is typed. A few
;			tests are in sections. In these
;			tests an error will cause execution
;			to go to the next section after the
;			message is typed.
;
;	sw<15>=1...	The program will halt after typing
;			the error message. Pressing the
;			console continue will cause the
;			program to continue as if sw<15>=0.
;
; 7.0	Restrictions
;
;	None
;
; 8.0	Miscellaneous
;
; 8.1	Execution times
;
;	Less than 2 seconds for each program on any pass.
;
; 8.2	Stack pointer
;
;	The stack pointer is initialized to 1100 in each of
;	the two programs.
;
; 8.3	Pass count
;
;	The program makes one pass for each end of pass
;	message typed. The end of pass message describes
;	the total number of passes completed.
;
; 8.4	T-bit trapping
;
;	If sw<12>=0 each program will run with trace traps
;	on every other pass. First pass will not enable
;	trace traps. Note sw<12>=1 disables T-bit traps.
;
; 8.5	Software switch register
;
;	Each of the two programs will run with or without
;	a console switch register. If a physical console
;	switch register is present on the system, then these
;	programs will go ahead and use it for the switch
;	functions described in 5.1 above. If however there
;	is no console switch register on the system a
;	software switch register will be used. This
;	software switch register can be examined or modified
;	at any time by the user if he types Control-G while
;	the program is running. This Control-G will cause
;	the contents of the software switch register to be
;	typed on the TTY and ask the user for a new value.
;	when the user types a value and carriage return then
;	the program will resume testing at the same point at
;	which it left off when the user typed Control-G.
;	note that when not running under act, apt or chain
;	the user will be asked for a software switch
;	register value after loading address 200 and
;	starting the program the first time the program is
;	run after loading (only if no console switch
;	register is on the system).
;
; 8.6	ACT, APT and XXDP compatibilty
;
;	These programs are fully compatible with:
;		APT
;		ACT
;		XXDP monitor and chain programs.
;
; 9.0	Program description
;
; Test 1		stf with illegal accumulator test
;
;		This is a test of the st instruction using illegal
;		accumulator 7, mode 0.
;
; Test 2		fdst mode 1, floating mode, test
;
;		This is a test of the stf instruction using fdst
;		mode 1.
;
; Test 3		fdst mode 2 test
;
;		This is a test of both stf and std with fdst mode 2.
;
; Test 4		fdst mode 2, with gr7, test
;
;		This is a test of stf with gr7 mode 2 or immediate
;		mode.
;
; Test 5		fdst mode 4 test
;
;		This is a test of std with fdst mode 4.
;
; Test 6		fdst mode 3 test
;
;		This is a test of fdst mode 3 using std.
;
; Test 7		fdst mode 5 test
;
;		This is a test of fdst mode 5 using std.
;
; Test 10	fdst mode 6, index mode, test
;
;		This is a test of fdst mode 6, index mode, using std.
;
; Test 11	fdst mode 7, index deferred mode, test
;
;		This is a test of fdst mode 7, index deferred mode, 
;		using std.
;
; Test 12	stcfd test
;
;		This is a test of the stcfd instruction.
;
; Test 13	stcdf test
;
;		This is a test of the stcdf instruction.
;
; Test 14	stcfd with illegal accumulator test
;
;		This test stcfd with illegal ac 6.
;
; Test 15	clrd test
;
;		This is a test of the crlf and clrd instructions.
;
; Test 16	clrd with illegal accumulator test
;
;		This is a test of clrd with illegal ac7.
;
; Test 17	negf, absf and tstf source mode 0 with illegal ac7, test
;
;		This is a test of the special dest flows using the
;		negd inst with mode zero and illegal ac7.
;
; Test 20	negf, absf and tstf source mode 0 test
;
;		This is a test the negf, absf and tstf source flows.
;		The negd instruction is used to test mode 0
;
; Test 21	negf, absf and tstf source mode 1 test
;
;		This is a test the negf, absf and tstf source flows.
;		The negd instruction is used to test mode 1
;
; Test 22	negf, absf and tstf source mode 2 test
;
;		This is a test the negf, absf and tstf source flows.
;		The absd instruction is used to test mode 2
;
; Test 23	negf, absf and tstf source mode 4 test
;
;		This is a test the negf, absf and tstf source flows.
;		The absd instruction is used to test mode 4
;
; Test 24	negf, absf and tstf source mode 3 test
;
;		This is a test the negf, absf and tstf source flows.
;		The absd instruction is used to test mode 3
;
; Test 25	negf, absf and tstf source mode 5 test
;
;		This is a test the negf, absf and tstf source flows.
;		The negd instruction is used to test mode 5
;
; Test 26	negf, absf and tstf source mode 6 test
;
;		This is a test the negf, absf and tstf source flows.
;		The absd instruction is used to test mode 6
;
; Test 27	negf, absf and tstf source mode 7 test
;
;		This is a test the negf, absf and tstf source flows.
;		The absd instruction is used to test mode 6
;
; Test 30	negf, absf and tstf source mode 6, gr7, test
;
;		This is a test the negf, absf and tstf source flows.
;		The negd instruction is used to test mode 6
;
; Test 31	negf, absf and tstf source mode 7, gr7, test
;
;		This is a test the negf, absf and tstf source flows.
;		The absd instruction is used to test mode 7
;
; Test 32	Special dest, mode 0, test
;
;		This is a test of the negf absf and tstf destination
;		flows mode 0 using the negd instr.
;
; Test 33	Special dest, mode 1, test
;
;		This is a test of the negf absf and tstf destination
;		flows mode 1 using the negd instr.
;
; Test 34	Special dest, mode 2, test
;
;		This is a test of the negf absf and tstf destination
;		flows mode 2 using the negd instr.
;
; Test 35	Special dest, mode 4, test
;
;		This is a test of the negf absf and tstf destination
;		flows mode 4 using the negd instr.
;
; Test 36	Special dest, mode 3, test
;
;		This is a test of the negf absf and tstf destination
;		flows mode 3 using the negd instr.
;
; Test 37	Special dest, mode 5, test
;
;		This is a test of the negf absf and tstf destination
;		flows mode 5 using the negd instr.
;
; Test 40	Special dest, floating mode 2, test
;
;		This is a test of the negf absf and tstf destination
;		flows mode 2 using the negf instr.
;
; Test 41	Special dest, mode2, gr7 (immediate), test
;
;		This is a test of the negf absf and tstf destination
;		flows mode 2(immediate) using the negd instr.
;
; Test 42	Special dest, mode 6, test
;
;		This is a test of the negf absf and tstf destination
;		flows mode 6 using the negd instr.
;
; Test 43	Specialist, mode 7, test
;
;		This is a test of the negf absf and tstf destination
;		flows mode 7 using the negd instr.
;
; Test 44	negd, absd and tstd test
;
;		This is a test of the negd absd and tstd
;		instructions.
;
; Test 45	Source modes, mode 1 (fl=0), test
;
;		This is a test of source mode 1 using the ldfps instr
;
; Test 46	Source modes, mode 2 (fl=0), test
;
;		This is a test of source mode 2 using the ldfps instr
;
; Test 47	Source modes, mode 4 (fl=0), test
;
;		This is a test of source mode 4 using the ldfps instr
;
; Test 50	Source modes, mode 3 (fl=0), test
;
;		This is a test of source mode 3 using the ldfps instr
;
; Test 51	Source modes, mode 5 (fl=0), test
;
;		This is a test of source mode 5 using the ldfps instr
;
; Test 52	Source modes, mode 6 (fl=0), test
;
;		This is a test of source mode 6 using the ldfps instr
;
; Test 53	Source modes, mode 7 (fl=0), test
;
;		This is a test of source mode 7 using the ldfps instr
;
; Test 54	Source modes, mode 2 gr7 (fl=1), test
;
;		This is a test of the ldcld with immediate
;		addressing mode
;
; Test 55	Source modes, mode 2 (fl=1), test
;
;		This is a test of the ldcld instr with mode 2.
;
; Test 56	ldcif and ldclf test
;
;		This is a test of the ldcif and the ldclf
;		instructions.
;
; Test 57	ldcid and ldcld test
;
;		This is a test of ldcid and ldcld
;
; Test 60	ldexp test
;
;		This is a test of the ldexp inst a subroutine is
;		used to set up operands, execute the ldexp inst and
;		check the results.
;
; Test 61	Destination modes, mode 1 (fl=0), test
;
;		This is a test of destination mode 1 using the stfps
;		instruction
;
; Test 62	Destination modes, mode 2 (fl=0), test
;
;		This is a test of destination mode 2 using the stfps
;		instruction
;
; Test 63	Destination modes, mode 4 (fl=0), test
;
;		This is a test of destination mode 4 using the stfps
;		instruction
;
; Test 64	Destination modes, mode 3 (fl=0), test
;
;		This is a test of destination mode 3 using the stfps
;		instruction
;
; Test 65	Destination modes, mode 5 (fl=0), test
;
;		This is a test of destination mode 5 using the stfps
;		instruction
;
; Test 66	Destination modes, mode 6 (fl=0), test
;
;		This is a test of destination mode 6 using the stfps
;		instruction
;
; Test 67	Destination modes, mode 7 (fl=0), test
;
;		This is a test of destination mode 7 using the stfps
;		instruction
;
; Test 70	Destination modes, mode 2 (fl=0), test
;
;		This is a test of destination mode 2 using stcol
;		with register 0
;
; Test 71	Destination modes, mode 4 (fl=0), test
;
;		This is a test of destination mode 4 using stcdl
;		with register 0
;
; Test 72	stcdi and stcdl test
;
;		This is a test of the stcdi and stcdl instructions.
;		Note that a subroutine, stcsub, is used to set up
;		the operands, execute the stc instruction and check
;		the result.
;
; Test 73	stcfl and stcfi test
;
;		This is a test of stcfl and stcfi. It makes use of
;		the same subroutine, stcsub, which was used to test
;		stcdl and stcdi.
;
; Test 74	stexp test
;
;		This is a test of the stexp instruction
;
; Test 75	stst test
;
;		This is a test of the stst instruction. First an
;		illegal fps op code (instruction) is used to enter
;		an error condition in the fec and fea. The stst is
;		executed and the fec and fea are checked
;
; Test 76	Special case test
;
;		This test is derived from a set of Fortran 4 bench
;		marks. It was found that this code failed even
;		after the floating point unit had passed all of the
;		diagnostics. The hardware was modified to correct
;		the error but since a test deficiency was indicated
;		this test was added. The test loads a mixed number
;		in the fpac and subtracts a whole number from it.
;
; Test 77	Interruptability test
;
;		This test verifies the ability of the KEF11-A to be
;		interrupted during the microcode multiply loop.
;
; 10.		Listing
;
;		mnumber=443
;		prognum=3
;_____________________________________________________________________________
;
		HOEP	= 0			; halt on end-of-pass
		NOSCO   = 0			; no scope trap and gtswr
		INSWR	= 000000		; 100000 for halt on error
;_____________________________________________________________________________
;
		.asect				;
		. = 0				; loop on test

		.title	CJKDDB KEF11-A DIAG PART 2
		.nlist	cnd, mc, md		;
		.list	me			;
;_____________________________________________________________________________

		$tn	= 1
		$swr	= 160000		; halt on error, loop on test, inhibit error typout

		fpvect	= 244
		$swr	= 177400
		$swrmsk	= 200
		tab	= 11
		crlf	= 15
;_____________________________________________________________________________
;
		.sbttl 	"BASIC DEFINITIONS"

		stack	= 1100			; initial address of the stack pointer *** 1100 ***
						; .equiv emt, error - basic definition of error call
.if ne NOSCO                     		;
		scope	= 240			; nop
.iff						;
		scope	= iot			; .equiv iot, scope - basic definition of scope call
.endc						;
						; miscellaneous definitions
		ht	= 11			; code for horizontal tab
		lf	= 12			; code for line feed
		cr	= 15			; code for carriage return
		crlf	= 200			; code for carriage return-line feed
		ps	= 177776		; processor status word
						;
		stklmt	= 177774		; stack limit register
		pirq	= 177772		; program interrupt request register
		dswr	= 177570		; hardware switch register
		ddisp	= 177570		; hardware display register
						;
		type	= 104401		; trap+1 tty typeout routine
		typoc	= 104402		; trap+2 type octal number (with leading zeros)
		typos	= 104403		; trap+3 type octal number (no leading zeros)
		typon	= 104404		; trap+4 type octal number (as per last call)
		typds	= 104405		; trap+5 type decimal number (with sign)
.if ne INSWR                     		;
		gtswr	= 240			; nop
.iff						;
		gtswr	= 104406		; trap+7 get soft-swr setting
.endc						;
		ckswr	= 104407		; trap+7 test for change in soft-swr
		rdchr	= 104410		; trap+10 tty type in character routine
		savreg	= 104411		; trap+11 save R0-R5 routine
		resreg	= 104412		; trap+12 restore R0-R5 routine
		rsetup	= 104413		; trap+13 routine to initialize at end of each test
		lperr	= 104414		; trap+14 routine to set up loop on error address
						;
						; general purpose register definitions
		R0	= %0			; general register
		R1	= %1			; general register
		R2	= %2			; general register
		R3	= %3			; general register
		R4	= %4			; general register
		R5	= %5			; general register
		R6	= %6			; general register
		R7	= %7			; general register
		SP	= %6			; stack pointer
		PC	= %7			; program counter
						;
						; priority level definitions
		pr0	= 0			; priority level 0
		pr1	= 40			; priority level 1
		pr2	= 100			; priority level 2
		pr3	= 140			; priority level 3
		pr4	= 200			; priority level 4
		pr5	= 240			; priority level 5
		pr6	= 300			; priority level 6
		pr7	= 340			; priority level 7
						;
		sw15	= 100000		; "switch register" switch definitions
		sw14	= 40000			;
		sw13	= 20000			;
		sw12	= 10000			;
		sw11	= 4000			;
		sw10	= 2000			;
		sw9	= 1000			;
		sw8	= 400			;
		sw7	= 200			;
		sw6	= 100			;
		sw5	= 40			;
		sw4	= 20			;
		sw3	= 10			;
		sw2	= 4			;
		sw1	= 2			;
		sw0	= 1			;
						;
		bit15	= 100000		; data bit definitions (bit0 to bit15)
		bit14	= 40000			;
		bit13	= 20000			;
		bit12	= 10000			;
		bit11	= 4000			;
		bit10	= 2000			;
		bit9	= 1000			;
		bit8	= 400			;
		bit7	= 200			;
		bit6	= 100			;
		bit5	= 40			;
		bit4	= 20			;
		bit3	= 10			;
		bit2	= 4			;
		bit1	= 2			;
		bit0	= 1			;
						; basic "CPU" trap vector addresses
		errvec	= 4			; time out and other errors
		resvec	= 10			; reserved and illegal instructions
		tbitvec	= 14			; T-bit
		trtvec	= 14			; trace trap
		bptvec	= 14			; breakpoint trap (bpt)
		iotvec	= 20			; input/output trap (iot) **scope**
		pwrvec	= 24			; power fail
		emtvec	= 30			; emulator trap (emt) **error**
		trapvec	= 34			; "trap" trap
		tkvec	= 60			; tty keyboard vector
		tpvec	= 64			; tty printer vector
		pirqvec	= 240			; program interrupt request vector
;_____________________________________________________________________________
;
		.sbttl "FPP REGISTER DEFINITIONS"
		ac0	= %0			;
		ac1	= %1			;
		ac2	= %2			;
		ac3	= %3			;
		ac4	= %4			;
		ac5	= %5			;
		ac6	= %6			;
		ac7	= %7			;
;_____________________________________________________________________________
;
		.macro	vect, offset, adr, val	;
		. 	= offset		;
	.if 	nb, <adr>			;
		.word	adr			;
	.iff					;
		.word	.+2			;
	.endc 					;
	.if	nb, <val>			;
		.word	val			;
	.iff            			;
		.word	0			;
	.endc					;
		.endm				;
;_____________________________________________________________________________
;
; All unused locations from 4-776 contain a ".+2, halt"
; sequence to catch illegal traps and interrupts
; Location 0 contains 0 to catch improperly loaded vectors
;
		.sbttl	"TRAP CATCHER"

		.nlist				;
		vect	0, 0, 			;
		vect	4, 6			;
		vect	10, 12			;
		vect	14, 16			;
		vect	20, 22, 		;
		vect	24, 200			; for APT start up
		vect	30, 32			;
		vect	34, 36			;
		vect	40, 42, 		; hooks required by ACT-11
		vect	44, $apthd, $endad	; set loc.46 to address of $endad in .seop
		.list
;_____________________________________________________________________________
;
		.sbttl	"ACT11 HOOKS"

		.nlist				;
		vect	50, 52			; set loc.52 to zero
		vect	54, 56			;
		vect	60, 62			;
		vect	64, 66			;
		vect	70, 72			;
		vect	74, 76			;
		vect	100, 102		;
		vect	104, 106		;
		vect	110, 112		;
		vect	114, 116 		;
		vect	120, 122		;
		vect	124, 126		;
		vect	130, 132		;
		vect	134, 136		;
		vect	140, 142		;
		vect	144, 146		;
		vect	150, 152		;
		vect	154, 156		;
		vect	160, 162		;
		vect	164, 166		;
		vect	170, 172		;
		.list				;
;_____________________________________________________________________________
;
		. = 174				;
dispreg:	.word	0			; software display register
swreg:		.word	INSWR			; software switch register

		.sbttl "STARTING ADDRESS(ES)"

		jmp	@#start			; jump to starting address of program
;_____________________________________________________________________________
;
		.nlist
		vect	204, 206		;
		vect	210, 212		;
		vect	214, 216		;
		vect	220, 222		;
		vect	224, 226		;
		vect	230, 232		;
		vect	234, 236		;
		vect	240, 242		;
		vect	244, 246		;
		vect	250, 252		;
		vect	254, 256 		;
		vect	260, 262		;
		vect	264, 266 		;
		vect	270, 272 		;
		vect	274, 276 		;
		vect	300, 302		;
		vect	304, 306		;
		vect	310, 312		;
		vect	314, 316		;
		vect	320, 322		;
		vect	324, 326		;
		vect	330, 332		;
		vect	334, 336		;
		vect	340, 342		;
		vect	344, 346 		;
		vect	350, 352 		;
		vect	354, 356 		;
		vect	360, 362 		;
		vect	364, 366 		;
		vect	370, 372 		;
		vect	374, 376 		;
		vect	400, 402		;
		vect	404, 406		;
		vect	410, 412		;
		vect	414, 416		;
		vect	420, 422		;
		vect	424, 426		;
		vect	430, 432		;
		vect	434, 436		;
		vect	440, 442		;
		vect	444, 446 		;
		vect	450, 452 		;
		vect	454, 456 		;
		vect	460, 462 		;
		vect	464, 466 		;
		vect	470, 472 		;
		vect	474, 476 		;
		vect	500, 502		;
		vect	504, 506		;
		vect	510, 512		;
		vect	514, 516		;
		vect	520, 522		;
		vect	524, 526		;
		vect	530, 532		;
		vect	534, 536		;
		vect	540, 542		;
		vect	544, 546 		;
		vect	550, 552 		;
		vect	554, 556 		;
		vect	560, 562 		;
		vect	564, 566 		;
		vect	570, 572 		;
		vect	574, 576 		;
		vect	600, 602		;
		vect	604, 606		;
		vect	610, 612		;
		vect	614, 616		;
		vect	620, 622		;
		vect	624, 626		;
		vect	630, 632		;
		vect	634, 636		;
		vect	640, 642		;
		vect	644, 646 		;
		vect	650, 652 		;
		vect	654, 656 		;
		vect	660, 662 		;
		vect	664, 666 		;
		vect	670, 672 		;
		vect	674, 676 		;
		vect	700, 702		;
		vect	704, 706		;
		vect	710, 712		;
		vect	714, 716		;
		vect	720, 722		;
		vect	724, 726		;
		vect	730, 732		;
		vect	734, 736		;
		vect	740, 742		;
		vect	744, 746 		;
		vect	750, 752 		;
		vect	754, 756 		;
		vect	760, 762 		;
		vect	764, 766 		;
		vect	770, 772 		;
		vect	774, 776 		;
		.list				;

		.sbttl "COMMON TAGS"
;_____________________________________________________________________________
;
; This table contains various common storage locations
; used in the program.

		. = 1100
$cmtag:						; start of common tags
		.word	0
$tstnm:		.byte	0			; contains the test number
$erflg:		.byte	0			; contains error flag
$icnt:		.word	0			; contains subtest iteration count
$lpadr:		.word	0			; contains scope loop address
$lperr:		.word	0			; contains scope return for errors
$erttl:		.word	0			; contains total errors detected
$itemb:		.byte	0			; contains item control byte
$ermax:		.byte	1			; contains max. errors per test
$errpc:		.word	0			; contains PC of last error instruction
$gdadr:		.word	0			; contains address of "good" data
$bdadr:		.word	0			; contains address of "bad" data
$gddat:		.word	0			; contains "good" data
$bddat:		.word	0			; contains "bad" data
		.word	0			; reserved-not to be used
		.word	0
$autob:		.byte	0			; automatic mode indicator
$intag:		.byte	0			; interrupt mode indicator
		.word	0
swr:		.word	dswr			; address of switch register
display:	.word	ddisp			; address of display register
$tks:		177560				; tty kbd status
$tkb:		177562				; tty kbd buffer
$tps:		177564				; tty printer status reg. address
$tpb:		177566				; tty printer buffer reg. address
$null:		.byte	0			; contains null character for fills
$fills:		.byte	2			; contains # of filler characters required
$fillc:		.byte	12			; insert fill chars. after a "line feed"
$tpflg:		.byte	0			; "terminal available" flag (bit<07>=0 - yes)
$regad:		.word	0			; contains the address from
						; which ($reg0) was obtained
$reg0:		.word	0			; contains (($regad)+0)
$reg1:		.word	0			; contains (($regad)+2)
$reg2:		.word	0			; contains (($regad)+4)
$reg3:		.word	0			; contains (($regad)+6)
$reg4:		.word	0			; contains (($regad)+10)
$reg5:		.word	0			; contains (($regad)+12)
$reg6:		.word	0			; contains (($regad)+14)
$reg7:		.word	0			; contains (($regad)+16)
$reg10:		.word	0			; contains (($regad)+20)
$reg11:		.word	0			; contains (($regad)+22)
$reg12:		.word	0			; contains (($regad)+24)
$reg13:		.word	0			; contains (($regad)+26)
$reg14:		.word	0			; contains (($regad)+30)
$reg15:		.word	0			; contains (($regad)+32)
$reg16:		.word	0			; contains (($regad)+34)
$reg17:		.word	0			; contains (($regad)+36)
$reg20:		.word	0			; contains (($regad)+40)
$reg21:		.word	0			; contains (($regad)+42)
$reg22:		.word	0			; contains (($regad)+44)
$reg23:		.word	0			; contains (($regad)+46)
$tmp0:		.word	0			; user defined
$tmp1:		.word	0			; user defined
$tmp2:		.word	0			; user defined
$tmp3:		.word	0			; user defined
$tmp4:		.word	0			; user defined
$tmp5:		.word	0			; user defined
$tmp6:		.word	0			; user defined
$tmp7:		.word	0			; user defined
$tmp10:		.word	0			; user defined
$tmp11:		.word	0			; user defined
$tmp12:		.word	0			; user defined
$tmp13:		.word	0			; user defined
$tmp14:		.word	0			; user defined
$tmp15:		.word	0			; user defined
$tmp16:		.word	0			; user defined
$tmp17:		.word	0			; user defined
$tmp20:		.word	0			; user defined
$tmp21:		.word	0			; user defined
$tmp22:		.word	0			; user defined
$tmp23:		.word	0			; user defined
$times:		0				; max. number of iterations
$escape:	0				; escape on error address
$bell:		.asciz	<207><377><377>		; code for bell
$ques:		.ascii	/?/			; question mark
$crlf:		.ascii	<15>			; carriage return
$lf:		.asciz	<12>			; line feed

		.sbttl "APT MAILBOX-ETABLE"

		.even				;
$mail:						; APT mailbox
$msgty:		.word	0			; amsgty	- message type code
$fatal:		.word	0			; afatal	- fatal error number
$testn:		.word	0			; atestn	- test number
$pass:		.word	0			; apass		- pass count
$devct:		.word	0			; adevct	- device count
$unit:		.word	0			; aunit		- I/O unit number
$msgad:		.word	0			; amsgad	- message address
$msglg:		.word	0			; amsglg	- message length
$etable:					;		APT environment table
$env:		.byte	0			; aenv		- environment byte
$envm:		.byte	0			; aenvm		- environment mode bits
$swreg:		.word	0			; aswreg	- APT switch register
$uswr:		.word	0			; auswr		- user switches
$cpuop:		.word	0			; acpuop	- cpu type, options
						; bits 15-11 - cpu type
						; 11/04=01, 11/05=02, 11/20=03, 11/40=04, 11/45=05
						; 11/70=06, pdq=07, q=10
						; bit 10 - real time clock
						; bit 9 - floating point processor
						; bit 8 - memory management
$etend:

		.sbttl "ERROR POINTER TABLE"

; This table contains the information for each error that can occur.
; The information is obtained by using the index number found in
; location $itemb. This number indicates which item in the table is pertinent.
; Note1: if $itemb is 0 the only pertinent data is $errpc.
; Note2: each item in the table contains 4 pointers explained as follows:
;
;		em				; points to the error message
;		dh				; points to the data header
;		dt				; points to the data
;		df				; points to the data format
$errtb:						;
; item number
		.word	em1
		.word	em2
		.word	em3
;_____________________________________________________________________________
;
		.sbttl	"APT PARAMETER BLOCK"
;
; Setup APT parameter block as defined in the APT-PDP11 diagnostic
; interface spec.
;
$apthd:						;
$hibts:		.word	0			; two high bits of 18 bit mailbox addr.
$mbadr:		.word	$mail			; address of APT mailbox (bits 0-15)
$tstm:		.word	2			; run tim of longest test
$pastm:		.word	4			; run time in secs. of 1st pass on 1 unit (quick verify)
$unitm:		.word	0			; additional runtime (secs) of a pass for each additional unit
		.word	$etend-$mail/2		; length mailbox-etable (words)
						;
start:
		.sbttl "INITIALIZE THE COMMON TAGS"

						; clear the common tags ($cmtag) area
		mov	#$cmtag, R6		; first location to be cleared
		clr	(R6)+			; clear memory location
		cmp	#swr, R6		; done?
		bne	.-6			; loop back if no
		mov	#stack, SP		; setup the stack pointer
; initialize a few vectors
		mov	#$scope, @#iotvec	; iot vector for scope routine
		mov	#340, @#iotvec+2	; level 7
		mov	#$error, @#emtvec	; emt vector for error routine
		mov	#340, @#emtvec+2	; level 7
		mov	#$trap, @#trapvec	; trap vector for trap calls
		mov	#340, @#trapvec+2	; level 7
		mov	#$pwrdn, @#pwrvec	; power failure vector
		mov	#340, @#pwrvec+2	; level 7
		mov	$endct, $eopct		; setup end-of-program counter
		clr	$times			; initialize number of iterations
		clr	$escape			; clear the escape on error address
		movb	#1, $ermax		; allow one error per test
; initialize the T-bit trap vector. then load location "$rtrn", in
; the "end-of-pass" ($eop) routine. with a "rti" or "rtf".
		mov	#$rtrn, @#tbitvec	; set T-bit vector to $rtrn
		mov	#340, @#tbitvec+2	; level 7
		mov	#rti, $rtrn		; set $rtrn to a rti
		mov	#65$, @#resvec		; try to do a rtt
		clr	-(SP)			; dummy PS
		mov	#64$, -(SP)		; and PC
		rtt				; try the rtt
64$:		mov	#rtt, $rtrn		; rtt is legal - set $rtrn to a rtt
		br	66$
65$:		add	#10, SP			; rtt illegal - clean off the stack
66$:		mov	#resvec+2, @#resvec	; restore trap catcher
		clr	$tbit			; clear T-bit switch
		mov	#., $lpadr		; initialize the loop address for scope
		mov	#., $lperr		; setup the error loop address
; size for a hardware switch register. If not found or it is
; equal to a "-1", setup for a software switch register.
		mov	@#errvec, -(SP)		; save error vector
		mov	#67$, @#errvec		; set up error vector
		mov	#dswr, swr		; setup for a hardware switch register
		mov	#ddisp, display		; and a hardware display register
		cmp	#-1, @swr		; try to reference hardware swr
		bne	69$			; branch if no timeout trap occurred
						; and the hardware swr is not=-1
		br	68$			; branch if no timeout
67$:		mov	#68$, (SP)		; set up for trap return
		rti
68$:		mov	#swreg, swr		; point to software swr
		mov	#dispreg, display
69$:		mov	(SP)+, @#errvec		; restore error vector

		clr	$pass			; clear pass count
		bitb	#aptsize, $envm		; test user size under apt
		beq	70$			; yes, use non-apt switch
		mov	#$swreg, swr		; no, use apt switch register
70$:

		.sbttl "TYPE PROGRAM NAME"

	; type the name of the program if first pass
		inc	#-1			; first time?
		bne	71$			; branch if no
		cmp	#$endad, @#42		; ACT-11?
		beq	71$			; branch if yes
		type	, 72$			; type asciz string

		.sbttl "GET VALUE FOR SOFTWARE SWITCH REGISTER"

		tst	@#42			; are we running under XXDP/ACT?
		bne	73$			; branch if yes
		cmpb	$env, #1		; are we running under APT?
		beq	73$			; branch if yes
		cmp	swr, #swreg		; software switch reg selected?
		bne	74$			; branch if no
		gtswr				; get soft-swr settings
		br	74$
73$:		movb	#1, $autob		; set auto-mode indicator
74$:
		br	71$			; get over the asciz
72$:		.asciz	<CRLF>/CJKDDB KEF11-A DIAGNOSTIC PART 2/<CRLF>
		.even				;
71$:						;

loop:
;_____________________________________________________________________________
;
; TEST 1 - stf with illegal accumulator test
; This is a test of the stf instruction using illegal accumulator 7, mode 0.
;
tst1:		scope
ooo1:
		lperr				; set up the loop on error address.
		clr	R0			; set the fps.
		ldfps	R0
		mov	#ooot, @#fpvect		; set up for fp traps.
		mov	#1$, @#$tmp2
1$:		stf	ac0, ac7		; this test instruction should
						; cause a trap.

; report failure of use of illegal accumulator 7 to cause an FPP trap.
ooo2:
		stfps	R0			; get fps.
		mov	R0, @#$tmp3
		stst	R0			; get fec.
		mov	R0, @#$tmp4
3$:		emt	+1			; stf with illegal accumulator. mode
						; 0, didn't trap. st 765 to st 537.
		br	ooodone

; trap to ooot, here, when the expected error occurs.
ooot:		mov	(SP), R0		; make sure the error occurred
		cmp	#ooo2, R0		; at the correct address.
		beq	ooo3			; branch if trap address correct.
		jmp	@#fpspur		; if incorrect go report spurious
						; fp trap.

ooo3:		stfps	R4			; get fps.
		stst	R5			; get fec.
		mov	R4, @#$tmp3		; save data incase of error.
		mov	R5, @#$tmp4
		mov	#100000, R2		; expected fps
		mov	#2, R3			; expected fec
		mov	R2, @#$tmp5
		mov	R3, @#$tmp6
		cmp	(SP)+, (SP)+		; reset the stack.
		cmp	R2, R4			; was fps correct?
		beq	ooo4			; branch if yes.
						; otherwise report fps incorrectly
1$:		emt	+1			; set after use of illegal acc.
		br	ooodone

ooo4:		cmp	R3, R5			; was the fec correct?
		beq	ooodone			; branch if correct.
						; otherwise report incorrect fec
1$:		emt	+1			; after use of illegal acc.

ooodone:
		rsetup				; Go initialize the fps and stack; and
						; see if the user has expressed
						; the desire to change the software
						; virtual console switch register (has
						; the user typed Control-G?).
;_____________________________________________________________________________
;
; TEST 2 - fdst mode 1, floating mode, test
; This is a test of the stf instruction using fdst mode 1.
;
tst2:		scope
ppp1:
		lperr				; set up the loop on error address.
		mov	#-1, R0			; set up a backround pattern in the
		mov	#pppbf0, R1		; input buffer.
		mov	#14, R2
ppp2:		mov	R0, (R1)+
		sob	R2, ppp2
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	#ppptp1, R0		; put test data into ac0
		ldd	(R0), ac0
		mov	#pppbf1, R0		; fdst address.
		clr	R2			; clear the fps.
		ldfps	R2
		mov	#ppp3, @#$tmp2
		mov	R0, @#$tmp3

ppp3:		stf	ac0, (R0)		; test instruction.

		cmp	#pppbf1, R0		; was R0 modified during execution?
		beq	ppp4			; branch if R0 not modified. correct.
		mov	R0, @#$tmp4		; otherwise report error. R0 modified.
1$:		emt	+1
		br	pppdone			; go to next test.

ppp4:		mov	#pppbf1, R0		; check the data in the output buffer.
		mov	#ppptp1, R1
		cmp	(R0)+, (R1)+
		bne	ppp10			; branch if incorrect.
		cmp	(R0)+, (R1)
		bne	ppp10			; branch if incorrect.
		cmp	#-1, (R0)+		; was floating mode used?
		bne	ppp15			; branch if not.
		cmp	#-1, (R0)
		bne	ppp15
		br	pppdone			; go to next test.

pppbf0:		.word	-1, -1, -1, -1, -1, -1

pppbf1:		.word	-1, -1, -1, -1, -1, -1

ppptp1:		.word	123456, 23456
		.word	34567, 45671

; report data in out put buffer incorrect.
ppp10:		mov	#ppptp1, @#$tmp4
		mov	#pppbf1, @#$tmp3
1$:		emt	+1			; bad data.
		br	pppdone

; report floating mode not used, but fd failed.
ppp15:		mov	#ppptp1, @#$tmp4
		mov	#pppbf1, @#$tmp3
1$:		emt	+1			; st 707 to 245 into 244 (but fd).

pppdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 3 - fdst mode 2 test
; This is a test of both stf and std with fdst mode 2.
;
tst3:		scope
; first test stf.
qqq1:
		lperr				; set up the loop on error address.
		mov	#-1, R0			; set up the output buffer.
		mov	#qqqbf0, R1
		mov	#14, R2
qqq2:		mov	R0, (R1)+
		sob	R2, qqq2
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	#qqqtp1, R0		; setup ac0
		ldd	(R0), ac0
		mov	#qqqbf1, R0		; fdst address.
		clr	R2
		ldfps	R2			; set fps.
		mov	#qqq3, @#$tmp2

qqq3:		stf	ac0, (R0)+		; test instruction.
		cmp	#qqqbf1+4, R0		; was R0 incremented by 4 properly?
		beq	qqq4			; branch if R0 correct.
		mov	R0, @#$tmp4		; report R0 incorrect after fdst mode 2.
		mov	#qqqbf1+4, @#$tmp3
1$:		emt	+1			; bad constant used or didn't go 527 to 642
		br	qqqdone
qqq4:		mov	#qqqbf1, R0		; was the output data correct?
		mov	#qqqtp1, R1
		cmp	(R0)+, (R1)+
		bne	qqq10			; branch if incorrect.
		cmp	(R0)+, (R1)+
		bne	qqq10			; branch if incorrect.
		cmp	(R0)+, #-1		; see if any other data buffer words were modified.
		bne	qqq10			; branch if incorrect.
		cmp	(R0)+, #-1
		bne	qqq10			; branch if incorrect.
		br	qqq20

qqqbf0:		.word	-1, -1, -1, -1, -1, -1

qqqbf1:		.word	-1, -1, -1, -1, -1, -1

qqqtp1:		76543
		65432
		54321
		43210
; report output data incorrect:
qqq10:		mov	#qqqtp1, @#$tmp3
		mov	#qqqbf1, @#$tmp4
1$:		emt	+1			; bad data
		br	qqqdone

; now test std mode 2.
qqq20:
		lperr				; set up the loop on error address.
		mov	#qqqbf0, R0		; set up default input data buffer.
		mov	R0, R1
		mov	#14, R2
qqq22:		mov	R0, (R1)+
		sob	R2, qqq22
		mov	#200, R0		; enter floating double mode.
		ldfps	R0
		mov	#qqqtp1, R0		; load ac0
		ldd	(R0), ac0
		mov	#qqqbf1, R0		; set destination address.
		mov	#qqq23, @#$tmp2
qqq23:		std	ac0, (R0)+		; test instruction.
		cmp	#qqqbf1+10, R0		; was R0 incremented by 10 correctly?
		beq	qqq24			; branch if correct.
		mov	R0, @#$tmp4		; report R0 incorrectly incremented.
		mov	#qqqbf1+10, @#$tmp3
1$:		emt	+1			; do not increm by 10 bad constant
		br	qqqdone
qqq24:		mov	#qqqbf1, R0		; did the data reach the output buffer correctly?
		mov	#qqqtp1, R1
		mov	#4, R2
1$:		cmp	(R0)+, (R1)+
		bne	qqq25			; branch if incorrect.
		sob	R2, 1$
		br	qqqdone
; report data incorrect.
qqq25:		mov	#qqqtp1, @#$tmp3
		mov	#qqqbf1, @#$tmp4
1$:		emt	+1			; bad data
qqqdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 4 - fdst mode 2, with gr7, test
; This is a test of stf with gr7 mode 2 or immediate mode.
;
tst4:		scope
rrr1:
		lperr				; set up the loop on error address.
		mov	#rrr3, R0		; set up the data suffer following the test instruction.
		mov	#rrrtp1, R1
		mov	#4, R2
1$:		mov	(R0)+, (R1)+
		sob	R2, 1$
		mov	#200, R0		; enter floating double mode.
		ldfps	R0
		mov	#rrrtp2, R0		; set up ac0
		ldd	(R0), ac0
		mov	#rrr10, @#errvect	; set up for an odd address.
		mov	#rrr2, @#$tmp2
		clr	R1
		clr	R4
; this is the test instruction. it should modify the first location
; after it to be an increment R4, inc R4, instruction instead
; of an increment R1 instruction. the increment R4 should not be
; executed since the PC should be incremented by two during immediate
; mode addressing. thus after the execution of the next 5 instructions
; R1 should contain 3 and R4 should contain 0.
rrr2:		std	ac0, (R7)+		; test instruction.
rrr3:		inc	R1			; the std instruction should change this to inc R4.
		inc	R1
		inc	R1
		inc	R1
		mov	#rrrexp, R0		; see if the data was output correctly.
		mov	#rrr3, R2
		mov	#4, R3
rrr4:		cmp	(R0)+, (R2)+
		bne	rrr25			; branch if incorrect.
		sob	R3, rrr4
		tst	R4			; make sure R4 is 0.
		bne	rrr15			; branch if R4 is incorrect.
		cmp	#3, R1			; see if R1 is correct.
		bne	rrr15			; branch if R1 is incorrect.
		br	rrrdone
; these are test data patterns used to set up the output buffer at rrr3.
rrrtp1:		inc	R1
		inc	R1
		inc	R1
		inc	R1
; this is the data put in ac0 before execution of the std.
rrrtp2:		inc	R4
		inc	R4
		inc	R4
		inc	R4
; this is the expected data at rrr3 after execution of the std.
rrrexp:		inc	R4
		inc	R1
		inc	R1
		inc	R1
; if a failure in the fdst flows results in an odd address trap through
; 4 to here:
rrr10:		mov	(SP), R2		; see if the trap was because of an odd address.
		bit	#1, R2
		bne	rrr11			; branch if yes.
		cmp	R2, #rrr3+2		; see if the trap occurred at the test instruction.
		beq	rrr12			; branch if yes.
		jmp	@#cpspur		; otherwise report a spurious trap through vector 4.
		
; report a failure in the fdst flows resulted in an odd address trap.
rrr11:		mov	R2, @#$tmp2
		mov	#rrr3+2, @#$tmp3
		cmp	(SP)+, (SP)+
1$:		emt	+1			; bad constant #2 + PC odd addr.
		br	rrrdone
rrr12:		mov	R2, @#$tmp2
		cmp	(SP)+, (SP)+
1$:		emt	+1			; odd address trap
		br	rrrdone			; wrong mode used.

; report data incorrect:
rrr25:		mov	#rrr3, @#$tmp3
		mov	#rrrexp, @#$tmp4
1$:		emt	+1			; bad data but gr7 fail
		br	rrrdone

; report PC incorrect modified during the execution of fdst immediate
; mode. the PC should have been incremented by 2 but it wasn't.
; use R1 and R4 to compute the actual action that was taken on the PC.
rrr15:		mov	#rrr3+2, @#$tmp3
		tst	R4			; is R4 clear.
		beq	1$
		mov	#rrr3, @#$tmp4
		br	2$
1$:		mov	#rrr3+2, R2
		add	#-3, R1
		asl	R1
		sub	R1, R2
		mov	R2, @#$tmp4
2$:
3$:		emt	+1			; bad constant PC+
rrrdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 5 - fdst mode 4 test
; This is a test of std with fdst mode 4.
;
tst5:		scope
sss1:
		lperr				; set up the loop on error address.
		mov	#-1, R0			; set up the output buffer.
		mov	#sssbf0, R1
		mov	#10, R2
1$:		mov	R0, (R1)+
		sob	R2, 1$
		mov	#200, R0		; enter floating double mode.
		ldfps	R0
		mov	#ssstp1, R0		; set up ac0
		ldd	(R0), ac0
		mov	#sss10, @#errvect	; set up for a trap to 4.
		mov	#sss2, @#$tmp2
		mov	#sssa1, R0		; set up the destination address.
sss2:		std	ac0, -(R0)		; test instruction.
		inc	R1
		cmp	R0, #sssbf0		; see if R0 was decremented properly.
		bne	sss15			; branch if R0 is incorrect.
		mov	#sssbf0, R0		; was the output data correct?
		mov	#ssstp1, R1
		mov	#4, R2
1$:		cmp	(R0)+, (R1)+
		bne	sss20			; branch if incorrect.
		sob	R2, 1$
		mov	#-1, R0			; is the rest of the output buffer correct, -1?
		mov	#sssa1, R1
		mov	#4, R2
2$:		cmp	R0, (R1)+
		bne	sss25			; branch if incorrect.
		sob	R2, 2$
		br	sssdone

; this is the output data buffer.
sssbf0:		-1
		-1
		-1
		-1
sssa1:		-1
		-1
		-1
		-1

; this is the test data loaded into ac0:
ssstp1:		147250
		36147
		25036
		147250
ssstp2:		-1
		-1
		-1
		-1

; if an odd address trap occurs come here:
sss10:		mov	(SP), R0		; see if the trap accurred on the test instruction.
		cmp	R0, #sss2+2
		beq	sss11			; branch if yes.
		cmp	R0, #sss2+4
		beq	sss11			; branch if yes.
		jmp	@#cpspur		; otherwise go report a spurious trap through 4.
		
; report failure in fdst flows resulted in an odd address.
sss11:		mov	R0, @#$tmp2
2$:		emt	+1			; fdst fork x odd ad res.
		br	sssdone

; report R0 incorrectly decremented.
sss15:		mov	R0, @#$tmp4
		mov	#sssbf0, @#$tmp3
1$:		emt	+1			; R0 not decre prop
		br	sssdone

; report output data incorrect:
sss20:		mov	#sssbf0, @#$tmp3
		mov	#ssstp1, @#$tmp4
1$:		emt	+1			; bad data
		br	sssdone
sss25:		mov	#sssa1, @#$tmp4
		mov	#ssstp2, @#$tmp3
1$:		emt	+1			; data bad outside target area
sssdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 6 - fdst mode 3 test
; This is a test of fdst mode 3 using std.
;
tst6:		scope
ttt1:
		lperr				; set up the loop on error address.
		mov	#tttbf0, R1		; set ip the output data buffer.
		mov	#-1, R0
		mov	#13, R2
1$:		mov	R0, (R1)+
		sob	R2, 1$
		mov	#tttbf0, @#ttta2
		mov	#200, R0		; enter double floating mode.
		ldfps	R0
		mov	#ttttp1, R0		; set up ac0
		ldd	(R0), ac0
		mov	#ttt10, @#errvect	; set up for traps to 4.
		mov	ttt2, @#$tmp2
		mov	#ttta2, R0		; set up the destination address.
ttt2:		std	ac0, @(R0)+		; test instruction.
		cmp	R0, #ttta2+2		; see if R0 was incremented correctly.
		bne	ttt15			; branch if incorrect.
		mov	#tttbf0, R1		; check the output data buffer.
		mov	#ttttp1, R2
		mov	#4, R3
ttt3:		cmp	(R1)+, (R2)+
		bne	ttt20			; branch if not correct.
		sob	R3, ttt3
		br	tttdone

; this is thhe output data buffer:
tttbf0:		-1
		-1
		-1
		-1
		-1
ttta1:		-1
ttta2:		tttbf0
ttta3:		-1
		-1
		-1
ttttp1:		101213
		141516
		71727
		37475

; trap through vector 4 to here.
ttt10:		mov	(SP), R2		; see if the trap address is that of the test instruction
		cmp	R2, #ttt2+2
		beq	ttt11			; branch if yes.
		cmp	R2, #ttt2+4
		beq	ttt11			; branch if yes.
		jmp	@#cpspur		; otherwise go report a spurious trap to 4.

; report a failure in the fdst flows resulted in an odd address trap.
ttt11:		mov	R2, @#$tmp2
		cmp	(SP)+, (SP)+
1$:		emt	+1			; bet fdst x odd adr
		br	tttdone

; report R0 incorrect:
ttt15:		mov	R0, @#$tmp4
		mov	#ttta2+2, @#$tmp3
1$:		emt	+1			; R0 not increment properly
		br	tttdone

; report incorrect output data:
ttt20:		mov	#tttbf0, @#$tmp3
		mov	#ttttp1, @#$tmp4
1$:		emt	+1			; bad data
tttdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 7 - fdst mode 5 test
; This is a test of fdst mode 5 using std.
;
tst7:		scope
uuu1:
		lperr				; set up the loop on error address.
		mov	#uuubf0, R1		; set up the output data buffer.
		mov	#-1, R0
		mov	#13, R2
1$:		mov	R0, (R1)+
		sob	R2, 1$
		mov	#uuubf0, @#uuua1
		mov	#200, R0		; enter double floating mode.
		ldfps	R0
		mov	#uuutp1, R0		; set up ac0
		ldd	(R0), ac0
		mov	#uuu10, @#errvect	; get ready for any traps to 4.
		mov	uuu2, @#$tmp2
		mov	#uuua2, R0		; set up the destination address.
uuu2:		std	ac0, @-(R0)		; test instruction.
		cmp	R0, #uuua2-2		; was R0 decrimented properly?
		bne	uuu15			; branch if R0 is incorrect.
		mov	#uuubf0, R1		; was the data output correctly?
		mov	#uuutp1, R2
		mov	#4, R3
uuu3:		cmp	(R1)+, (R2)+
		bne	uuu20			; branch if data is incorrect.
		sob	R3, uuu3
		br	uuudone

; this is the output data buffer
uuubf0:		-1
		-1
		-1
		-1
		-1
uuua1:		uuubf0
uuua2:		-1
uuua3:		-1
		-1
		-1
uuutp1:		20212
		23242
		26273
		031323

; if a trap to 4 occurs come here.
uuu10:		mov	(SP), R2		; see if the trap occurred on the test instruction.
		cmp	R2, #uuu2+2
		beq	uuu11			; branch if yes.
		cmp	R2, #uuu2+4
		beq	uuu11			; branch if yes.
		jmp	@#cpspur		; otherwise report a spurious trap to 4.
		
; report failure of fdst resulted in an odd address trap to 4.
uuu11:		mov	R2, @#$tmp2
		cmp	(SP)+, (SP)+
1$:		emt	+1			; set fdst x odd adr
		br	uuudone

; report R0 incorrect.
uuu15:		mov	R0, @#$tmp4
		mov	#uuua2+2, @#$tmp3
1$:		emt	+1			; R0 not increment properly
		br	uuudone

; report bad data.
uuu20:		mov	#uuubf0, @#$tmp4
		mov	#uuutp1, @#$tmp3
1$:		emt	+1			; bad data
uuudone:
		rsetup
;_____________________________________________________________________________
;
; TEST 10 - fdst mode 6, index mode, test
; This is a test of fdst mode 6, index mode, using std.
;
tst10:		scope
vvv1:
		lperr				; set up the loop on error address.
		mov	#200, R0		; enter double floating mode.
		ldfps	R0
		mov	#vvvbf0, R1		; set up the out put data buffer.
		mov	#-1, R0
		mov	#4, R2
1$:		mov	R0, (R1)+
		sob	R2, 1$
		mov	#vvv10, @#errvect	; set up vector 4 incase of error.
		mov	#vvvtp1, R0		; set up ac0
		ldd	(R0), ac0
		mov	#vvv2, @#$tmp2
		mov	#vvvbf0-5701, R0	; set up the destination address.
		mov	#1, R1
vvv2:		std	ac0, 5701(R0)		; test instruction.
		cmp	R0, #vvvbf0-5701	; see if R0 was modified.
		bne	vvv15			; branch if incorrect.
		mov	#vvvbf0, R2		; was the output data correct.
		mov	#vvvtp1, R3
		mov	#4, R4
1$:		cmp	(R2)+, (R3)+
		bne	vvv20			; branch if incorrect data.
		sob	R4, 1$
		br	vvvdone
vvvbf0:		-1
		-1
		-1
		-1
vvvtp1:		30313
		23334
		35363
		74041

; come here after a trap through vector 4.
vvv10:		mov	(SP), R2		; see if the trap occurred on the test instr.
		cmp	R2, #vvv2+2
		beq	vvv11			; branch if yes.
		cmp	R2, #vvv2+4
		beq	vvv11			; branch if yes.
		jmp	@#fpspur		; otherwise go report spurious trap to 4.

; report failure of fdst resulted in an odd address trap to 4.
vvv11:		mov	R2, @#$tmp2
		cmp	(SP)+, (SP)+
1$:		emt	+1			; fdst fork x odd add
		br	vvvdone

; report R0 modified.
vvv15:		mov	R0, @#$tmp4
		mov	#vvvbf0-5701, @#$tmp3
1$:		emt	+1			; R0 modified!
		br	vvvdone

; report incorrect data.
vvv20:		mov	#vvvbf0, @#$tmp3
		mov	#vvvtp1, @#$tmp4
1$:		emt	+1			; bad data
vvvdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 11 - fdst mode 7, index deferred mode, test
; This is a test of fdst mode 7, index deferred mode, using std.
;
tst11:		scope
www1:
		lperr				; set up the loop on error address.
		mov	#200, R0		; enter double floating mode.
		ldfps	R0
		mov	#wwwbf0, R1		; set up the output data buffer.
		mov	#-1, R0
		mov	#4, R2
1$:		mov	R0, (R1)+
		sob	R2, 1$
		mov	#www10, @#errvect	; set up for traps to 4.
		mov	#wwwtp1, R0		; set up ac0
		ldd	(R0), ac0
		mov	#www2, @#$tmp2
		mov	#wwwbf1-5701, R0	; set up the destination address.
		mov	#1, R1
		mov	#wwwbf0, @#wwwbf1
www2:		std	ac0, @5701(R0)		; test instruction.
		cmp	R0, #wwwbf1-5701	; is R0 correct?
		bne	www15			; branch if incorrect.
		mov	#wwwbf0, R2		; was the data output correctly?
		mov	#wwwtp1, R3
		mov	#4, R4
1$:		cmp	(R2)+, (R3)+
		bne	www20			; branch if data is incorrect.
		sob	R4, 1$
		br	wwwdone
wwwbf0:		-1
		-1
		-1
		-1
wwwtp1:		41424
		34445
		46475
		051525
wwwbf1:		-1
		-1
		-1
		-1

; trap through 4 to here.
www10:		mov	(SP), R2		; see if the trap occurred on the test instr.
		cmp	R2, #www2+2
		beq	www11			; branch if yes.
		cmp	R2, #www2+4
		beq	www11			; branch if yes.
		jmp	@#fpspur		; otherwise go report spurious trap to 4.

; report failure of fdst fork resulted in an odd address trap to 4.
www11:		mov	R2, @#$tmp2
		cmp	(SP)+, (SP)+
1$:		emt	+1			; fdst fork x odd add
		br	wwwdone

; report R0 modified.
www15:		mov	R0, @#$tmp4
		mov	#wwwbf0-5701, @#$tmp3
1$:		emt	+1			; R0 modified!
		br	wwwdone

; report data incorrect
www20:		mov	#wwwbf0, @#$tmp3
		mov	#wwwtp1, @#$tmp4
1$:		emt	+1			; bad data
wwwdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 12 - stcfd test
; This is a test of the stcfd instruction.
;
tst12:		scope
; ac=0
xxx1:
		lperr				; set up the loop on error address.
		jsr	pc, stcfds
1$:		0				; ac
		0
		0
		0
2$:		0				; res
		0
		0
		0
3$:		0				; error res.
		0
		-1
		-1
4$:		47000				; fps before execution.
		47004				; fps after execution.
		-1				; fec
		147004				; error fps.
5$:		emt	+1			; fdfl<---fdflxst 767
		br	6$
		emt	+1			; but ezbt x st560 to 061 into 261
6$:

xxx2:
		lperr				; set up the loop on error address.
		jsr	pc, stcfds
1$:		17203				; ac
		142536
		47506
		172031
2$:		17203				; res
		142536
		0
		0
3$:		17203				; error res.
		142536
		47506

		172031
4$:		40000				; fps before execution.
		40000				; fps after execution.
		-1				; fec
		-1				; error fpc.
5$:		emt	+1			; x11(1, 0)<---0 x st766
		br	6$
		emt	+1
6$:

xxx3:
		lperr				; set up the loop on error address.
		jsr	pc, stcfds
1$:		50717				; ac
		27374
		75767
		77071
2$:		50717				; res
		27374
		0
		0
3$:		0				; error res.
		0
		0
		0
4$:		47000				; fps before execution.
		47000				; fps after execution.
		-1				; fec
		174002				; error fps.
5$:		emt	+1			; but opic x st251
		br	6$
		emt	+1			; but ezbt x st421
6$:

xxx4:
		lperr				; set up the loop on error address.
		jsr	pc, stcfds
1$:		20212				; ac
		32425
		26272
		02123
2$:		20212				; res
		32425
		0
		0
3$:		20212				; error res.
		32425
		100000
		0
4$:		40000				; fps before execution.
		40000				; fps after execution.
		-1				; fec
		-1				; error fps.
5$:		emt	+1			; but fd in round x st113
		br	6$
		emt	+1
6$:

xxx5:
		lperr				; set up the loop on error address.
		jsr	pc, stcfds
1$:		121314				; ac
		151617
		101112
		131415
2$:		121314				; res
		151617
		0
		0
3$:		21314				; error res.
		151617
		0
		0
4$:		40000				; fps before execution.
		40010				; fps after execution.
		-1				; fec
		-1				; error fps.
5$:		emt	+1			; but enbt x st567 or bad sign st460
		br	6$
		emt	+1
6$:		br	xxxdone

; This subroutine, stcfds, is used to set up the operands, execute
; the stcfd instruction and check the results. A call
; to it is made thus:
;
;		jsr	pc, @#stcfds
;	acarg:	.word	x, x, x, x		; ac operand
;	res:	.word	x, x, x, x		; expected result
;	erres:	.word	x, x, x, x		; error result
;	fpsb:	.word	x			; fps before execution
;	fpsa:	.word	x			; fps after execution
;	fec:	.word	x			; expected fec
;	erfps:	.word	x			; error fps.
;	err1:	error	1			; data error.
;		br	cont
;	err2:	error	1			; fps error.
;	cont:					; return address
;
; The operands are set up (using ac0 as the accumulator). Then
; the stcfd instruction is executed.
; The result is checked against res. If the result is correct then the fps is
; compared with fpsa if this too is correct stcfds returns control
; to the calling routine at cont. If the fps is bad stcfds
; compare it to error fps. If this matches then stcfds will return
; to the error call at err2, otherwise stcfds itself
; reports this failure and then returns to cont. If the result of the
; stcfd is incorrect, the incorrect result is compared with the
; anticipated failing data pattern, erres. If the failure in
; the result was anticipated correctly to be erres then stcfds
; will transfer control to the error call at err1. Otherwise the
; result was incorrect but was not anticipated and stcfds will
; report the failure after which control will be passed to cont.
;
stcfds:		mov	(SP)+, R1		; pick up the pointer to the operands.
		mov	#200, R0		; enter double floating mode.
		ldfps	R0
		mov	R1, R0			; load ac0
		ldd	(R0), ac0
		mov	#-1, R0			; fill the output buffer with -1's.
		mov	#stcft, R2
		mov	#4, R3
1$:		mov	R0, (R2)+
		sob	R3, 1$
		mov	30(R1), R0		; load the fps.
		ldfps	R0
		mov	#2$, @#$tmp2
		mov	#stcft, R0		; set up the destination address.
2$:		stcfd	ac0, (R0)		; test instruction.

		stfps	R4			; get the fps.
		stst	R5			; get the fec.
		mov	R1, R2			; save the data in case of error.
		mov	R2, @#$tmp3
		add	#10, R2
		mov	R2, @#$tmp5
		mov	#stcft, @#$tmp4
		mov	R4, @#$tmp7
		mov	32(R1), @#$tmp10
		mov	R1, R2			; check the result.
		add	#10, R2
		mov	#stcft, R3
		mov	#4, R0
3$:		cmp	(R2)+, (R3)+
		bne	15$			; branch if incorrect.
		sob	R0, 3$
		mov	32(R1), R2
		cmp	R2, R4			; is the fps correct?
		bne	20$			; branch if fps incorrect.
		tst	R2			; if expected fps is negative, then
		bpl	4$			; go ahead and check the fec.
		cmp	36(R1), R5
		bne	25$			; branch if fec is incorrect.
4$:		jmp	46(R1)			; return.

; result incorrect:
15$:		mov	R1, R2			; see if error was anticipated.
		add	#20, R2
		mov	#stcft, R3
		mov	#4, R0
16$:		cmp	(R2)+, (R3)+
		bne	17$			; branch if not anticipated.
		sob	R0, 16$
		jmp	40(R1)			; if error was anticipate: return.

; otherwise report result incorrect here.
17$:

18$:		emt	+1			; data error
		br	4$

; fps incorrect:
20$:		cmp	R4, 34(R1)		; was the error anticipated.
		bne	21$			; branch if not anticipated.
		jmp	44(R1)			; if it was anticipated return.

; the fps error was not anticipated so report fps incorrect here.
21$:
22$:		emt	+1			; fps x
		br	4$

; report fec incorrect:
25$:		mov	36(R1), @#$tmp12
		mov	R5, @#$tmp11
26$:		emt	+1			; fec x
		br	4$

stcft:		-1, -1, -1, -1

xxxdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 13 - stcdf test
; This is a test of the stcdf instruction.
;
tst13:		scope
; ac=0
yyy1:
		lperr				; set up the loop on error address.
		jsr	pc, stcdfs
1$:		0				; ac
		0
		0
		0
2$:		0				; res
		0
		-1
		-1
3$:		0				; error res.
		0
		0
		0
4$:		47200				; fps before execution.
		47204				; fps after execution.
		-1				; fec
		-1				; frrdq fps.
5$:		emt	+1			; fdfl<---fdfl x st767
		br	6$
		emt	+1			; fps incorrect.
6$:

yyy2:
		lperr				; set up the loop on error address.
		jsr	pc, stcdfs
1$:		67574				; ac0
		73727
		170777
		67574
2$:		67574				; res
		73730
		-1
		-1
3$:		67574				; error res.
		73727
		-1
		-1
4$:		40200				; fps before execution.
		40200				; fps after execution.
		-1				; fec
		-1				; error fps.
5$:		emt	+1			; either round failed or went to 766 x1(1, 0)<---0 into 76
		br	6$
		emt	+1
6$:

yyy3:
		lperr				; set up the loop on error address.
		jsr	pc, stcdfs
1$:		77777				; ac0
		-1
		100000
		0
2$:		0				; res
		0
		-1
		-1
3$:		77777				; error res.
		-1
		-1
		-1
4$:		40200				; fps before execution.
		40206				; fps after execution.
		-1				; fec
		40204				; error fps.
5$:		emt	+1
		br	6$
		emt	+1			; but ezbt x st421 to 062 into 262
6$:

yyy4:
		lperr				; set up the loop on error address.
		jsr	pc, stcdfs
h:		77777				; ac0
		-1
		100000
		0
2$:		0				; res
		0
		-1
		-1
3$:		77777				; error res.
		-1
		-1
		-1
4$:		40200				; fps before execution.
		40206				; fps after execution.
		-1				; fec
		140206				; error fps.
5$:		emt	+1
		br	6$
		emt	+1			; but fiv st262 to 123 into 103
6$:

yyy5:
		lperr				; set up the loop on error address.
		jsr	pc, stcdfs
1$:		177777				; ac0
		-1
		100000
		0
2$:		100000				; res
		0
		-1
		-1
3$:		0				; error res.
		0
		-1
		-1
4$:		47200				; fps before execution.
		147216				; fps after execution.
		10				; fec
		47206				; error fps.
5$:		emt	+1			; but fiv st262 fail to 103 int 123
		br	6$
		emt	+1			; but flag st 147 x to st 361 into 365
6$:		br	yyydone

; This subroutine, stcdfs, is used to set up the operands, execute
; the stcdf instruction and check the results. A call
; to it is made thus:
;
;		jsr	pc, @#stcfds
;	acarg:	.word	x, x, x, x		; ac operand
;	res:	.word	x, x, x, x		; expected result
;	erres:	.word	x, x, x, x		; error result
;	fpsb:	.word	x			; fps before execution
;	fpsa:	.word	x			; fps after execution
;	fec:	.word	x			; expected fec
;	erfps:	.word	x			; error fps.
;	err1:	error	1			; data error.
;		br	cont
;	err2:	error	1			; fps error.
;	cont:					; return address
;
; The operands are set up (using ac0 as the acclmulator). Then
; the stcfd instruction is executed.
; The result is checked against res. If the result is correct then the fps is
; compared with fpsa if this too is correct skfds returns control
; to the calling routine at cont. If the fps is bad stcfds
; compare it to error fps. If this matches then stcfds will return
; to the error call at err2. Otherwise stcfds itself
; reports this failure and then returns to cont. If the result of the
; stcfd is incorrect, the incorrect result is compared with the
; anticipated failing data pattern, erres. If the failure in
; the result was anticipated correctly to be erres then stcfds
; will transfer control to the error call at err1. Otherwise the
; result was incorrect but was not anticipated and stcfds will
; report the failure after which control will be passed to cont.
;
stcdfs:		mov	(SP)+, R1		; pick up the pointer to the operands.
		mov	#200, R0		; enter double floating mode.
		ldfps	R0
		mov	R1, R0			; load ac0
		ldd	(R0), ac0
		mov	#-1, R0			; fill the output buffer with -1's.
		mov	#stcdt, R2
		mov	#4, R3
1$:		mov	R0, (R2)+
		sob	R3, 1$
		mov	30(R1), R0		; load the fps.
		ldfps	R0
		mov	#2$, @#$tmp2
		mov	#stcdt, R0		; set up the destination address.
2$:		stcdf	ac0, (R0)		; test instruction.
		stfps	R4			; get the fps.
		stst	R5			; get the fec.
		mov	R1, R2			; save the data in case of error.
		mov	R2, @#$tmp3
		add	#10, R2
		mov	R2, @#$tmp5
		mov	#stcdt, @#$tmp4
		mov	R4, @#$tmp7
		mov	32(R1), @#$tmp10
		mov	R1, R2			; check the result.
		add	#10, R2
		mov	#stcdt, R3
		mov	#4, R0
3$:		cmp	(R2)+, (R3)+
		bne	15$			; branch if incorrect.
		sob	R0, 3$
		mov	32(R1), R2
		cmp	R2, R4			; is the fps correct?
		bne	20$			; branch if fps incorrect.
		tst	R2			; if expected fps is negative, then
		bpl	4$			; go ahead and check the fec.
		cmp	34(R1), R5
		bne	25$			; branch if fec is incorrect.
4$:		jmp	46(R1)			; return.

; result incorrect:
15$:		mov	R1, R2			; see if error was anticipated.
		add	#20, R2
		mov	#stcdt, R3
		mov	#4, R0
16$:		cmp	(R2)+, (R3)+
		bne	17$			; branch if not anticipated.
		sob	R0, 16$
		jmp	40(R1)			; if error was anticipated return.
; otherwise report result incorrect here.
17$:
18$:		emt	+1			; data error
		br	4$

; fps incorrect:
20$:		cmp	R4, 34(R1)		; was the error anticipated.
		bne	21$			; branch if not anticipated.
		jmp	44(R1)			; if it was anticipated return.

; the fps error was not anticipated so report fps incorrect here.
21$:
22$:		emt	+1			; fps x
		br	4$

; report fec incorrect:
25$:		mov	36(R1), @#$tmp12
		mov	R5, @#$tmp11
26$:		emt	+1			; fec x
		br	4$

stcdt:		-1, -1, -1, -1

yyydone:
		rsetup
;_____________________________________________________________________________
;
; TEST 14 - stcfd with illegal accumulator test
; This test stcfd with illegal ac6.
;
tst14:		scope
zzz1:
		lperr				; set up the loop on error address.
		mov	#40000, R0		; dissable interrupts.
		ldfps	R0
		mov	#zzz2, @#$tmp2
zzz2:		stcfd	ac0, ac6		; this test instruction should cause an frror.
		stfps	R4			; get fps.
		stst	R5			; get fec.
		cmp	R4, #140000		; is fps correct?
		bne	zzz10			; branch if incorrect fps.
		cmp	#2, R5			; is fec correct?

		bne	zzz15			; branch if incorrect.
		br	zzzdone

; report fps incorrect after use of illegal accumulator.
zzz10:		mov	R4, @#$tmp4
		mov	#140000, @#$tmp3
1$:		emt	+1			; but fdst st767 x to 567 into 577
		br	zzzdone

; report fec incorrect after use of illegal accumulator.
zzz15:		mov	R5, @#$tmp4
		mov	#2, @#$tmp3
1$:		emt	+1			; fec<---2 st577 x
zzzdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 15 - clrd test
; This is a test of the crlf and clrd instructions.
;
tst15:		scope
aab1:
		lperr				; set up the loop on error address.
		mov	#aabtp1, R0		; set up output buffer
		mov	#aabbf0, R1
		mov	#4, R2
1$:		mov	(R0)+, (R1)+
		sob	R2, 1$
		mov	#aabbf0, R0		; set up destination operand address.
		mov	#213, R1		; set up fps.
		ldfps	R1
		mov	#2$, @#$tmp2
2$:		clrd	(R0)			; test instruction.
		stfps	R5			; get fps.
		mov	#4, R2			; see if result clear, 0.
		mov	#aabbf0, R1
3$:		tst	(R1)+
		bne	aab2			; branch if result incorrect, not 0.
		sob	R2, 3$
		cmp	#204, R5		; see if fps is correct.
		bne	aab3			; branch if incorrect.
		cmp	R0, #aabbf0		; see if R0 is correct.
		bne	aab4			; branch if R0 is incorrect.
		br	aabdone

; result not 0, report error.
aab2:		mov	#aabbf0, @#$tmp3
		mov	#aabtp2, @#$tmp4
1$:		emt	+1			; bad data = 0 x 11+zero st770 x
		br	aabdone

; report fps incorrect:
aab3:		mov	R4, @#$tmp4
		mov	#204, @#$tmp3
1$:		emt	+1			; bad fps
		br	aabdone

; report R0 incorrect.
aab4:		mov	R0, @#$tmp4
		mov	#aabbf0, @#$tmp3
1$:		emt	+1
		br	aabdone

; this is the test data buffer, output data buffer.
aabbf0:		73475
		67707
		127347
		56770
; this is the data used to set up the output buffer.
aabtp1:		73475
		67707
		127347
		56770
; this is the expected data, result:
aabtp2:		0
		0
		0
		0
aabdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 16 - clrd with illegal accumulator test
; This is a test of clrd with illegal ac7.
;
tst16:		scope
ccb1:
		lperr				; set up the loop on error address.
		mov	#40200, R0		; set up the fps. no interrupts and fd=1.
		ldfps	R0
		mov	#ccb2, @#$tmp2

ccb2:		clrd	ac7			; test instruction.
		stfps	R4			; get fps.
		stst	R5			; get fec.
		cmp	R4, #140200		; is the fps correct?
		bne	ccb10			; branch if fps is incorrect.
		cmp	#2, R5			; is the fec correct?
		bne	ccb15			; branch if fec is incorrect.
		br	ccbdone

; report incorrect fps:
ccb10:		mov	R4, @#$tmp4
		mov	#140200, @#$tmp3
1$:		emt	+1			; but fdst st 700x to 607 into 677
		br	ccbdone

; report incorrect fec:
ccb15:		mov	R5, @#$tmp4
		mov	#2, @#$tmp3
1$:		emt	+1			; fec<---2 st 677 x
ccbdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 17 - negf, absf and tstf source mode 0 with illegal ac7, test
; This is a test of the special
; dest flows using the negd inst
; with mode zero and illegal
; ac7.
;
tst17:		scope
vvb1:
		lperr				; set up the loop on error address.
		mov	#40200, R0		; set up the fps, fid=1 and fd=1.
		ldfps	R0
		mov	#vvb2, @#$tmp2

vvb2:		negd	ac7			; test instruction.
		stfps	R4			; get fps.
		stst	R5			; get fec.
		cmp	#140200, R4		; is fps correct?
		bne	vvb10			; branch if fps is incorrect.
		cmp	#2, R5			; is fec correct?
		bne	vvb15			; branch if fec is incorrect.
		br	vvbdone

; report incorrect fps:
vvb10:		mov	#140200, @#$tmp3
		mov	R4, @#$tmp4
1$:		emt	+2			; fps bad
		br	vvbdone

; report fec incorrect:
vvb15:		mov	#2, @#$tmp3
		mov	R5, @#$tmp4
1$:		emt	+2			; fec bad

vvbdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 20 - negf, absf and tstf source mode 0 test
; This is a test the negf, absf and tstf
; source flows. The negd instruction
; is used to test mode 0.
;
tst20:		scope
ddb1:
		lperr				; set up the loop on error address.
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	#ddbtp1, R0		; set up ac0
		ldd	(R0), ac0		; set ac0=0
		clr	R0			; clear the fps.
		ldfps	R0
		mov	#ddbtp2, R0		; load ac0 to be a floating 0.
		ldf	(R0), ac0		; set ac0=zero
						; float
		mov	#201, R0		; set fd mode.
		ldfps	R0
		mov	#ddb2, @#$tmp2

ddb2:		negd	ac0			; test instruction.
		stfps	R5			; get fps.
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	#ddbbf0, R0		; get the result out of ac0
		std	ac0, (R0)
						; see if the result is correct.
		mov	#4, R1
1$:		tst	(R0)+
		bne	ddb5			; branch if the result is incorrect.
		sob	R1, 1$
		cmp	#204, R5		; is the fps correct?
		bne	ddb6			; branch if the fps is incorrect.
		br	ddbdone

; result incorrect, report failure:
ddb5:		mov	#ddbtp2, @#$tmp4	; expect do
		mov	#ddbtp3, @#$tmp3	; prev fo impure
		mov	#ddbbf0, @#$tmp5	; got
1$:		emt	+2
		br	ddbdone

; report fps incorrect:
ddb6:		mov	#204, @#$tmp3
		mov	R5, @#$tmp4
1$:		emt	+2
		br	ddbdone

; these are test data tables and an output buffer.
ddbtp1:		101112
		131415
		161710
		111213
ddbtp2:		0
		0
		0
		0
ddbbf0:		-1
		-1
		-1
		-1
ddbtp3:		0
		0
		161710
		111213
ddbdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 21 - negf, absf and tstf source mode 1 test
; This is a test the negf, absf and tstf
; source flows. The negd instruction
; is used to test mode 1.
;
tst21:		scope
eeb1:
		lperr				; set up the loop on error address.
		mov	#eebtp1, R0		; set up the data buffer.
		mov	#eebbf1, R1
		mov	#4, R2
1$:		mov	(R0)+, (R1)+
		sob	R2, 1$
		mov	#200, R0		; set fd mode.
		ldfps	R0
		mov	#eebbf1, R0		; set up the operand address.
		mov	#eeb2, @#$tmp2
		mov	#eeb10, @#errvect	; set up vector 4 in case of error.

eeb2:		negd	(R0)			; test instruction.
		stfps	R5			; get fps.
		mov	#eebbf1, R1		; see if result is correct.
		mov	#4, R2
1$:		tst	(R1)+
		bne	eeb15			; branch if not correct.
		sob	R2, 1$
		cmp	R0, #eebbf1		; is R0 correct?
		bne	eeb20			; branch if not correct.
		cmp	#204, R5		; is the fps correct?
		bne	eeb25			; branch if not correct.
		br	eebdone

; these are test data tables and a buffer.
eebtp1:		177
		167574
		137271
		107675
eebtp2:		0
		0
		0
		0
eebbf0:		-1
		-1
		-1
		-1
eebbf1:		-1
		-1
		-1
		-1

; if a trap to 4 occurs come here:
eeb10:		mov	(SP), R2		; see if the trap occurred on the test instr.
		cmp	R2, #eeb2+2
		beq	1$			; branch if yes.
		cmp	R2, #eeb2+4
		beq	1$			; branch if yes.
		jmp	@#cpspur		; otherwise go report a spurious trap to 4.
		
; report a failure in the fdst flows resulted in an odd address trap to 4.
1$:		cmp	(SP)+, (SP)+		; reset the stack.
		mov	R2, @#$tmp2

2$:		emt	+2			; odd adres
		br	eebdone			; but fdstx in st 771

; report result incorrect.
eeb15:		mov	#eebtp2, @#$tmp4
		mov	#eebtp1, @#$tmp3
		mov	#eebbf1, @#$tmp5
1$:		emt	+2			; bad data x11*0 st 312x
		br	eebdone

; R0 incorrect:
eeb20:		mov	#eebbf1, @#$tmp3
		mov	R0, @#$tmp4
1$:		emt	+2			; R0 badx
		br	eebdone

; report fps incorrect:
eeb25:		mov	R5, @#$tmp3
		mov	#204, @#$tmp5
1$:		emt	+2			; fps x

eebdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 22 - negf, absf and tstf source mode 2 test
; This is a test the negf, absf and tstf
; source flows. The absd instruction
; is used to test mode 2.
;
tst22:		scope
ffb1:
		lperr				; set up the loop on error address.
		mov	#ffbtp1, R0		; set up the data buffer.
		mov	#ffbbf1, R1
		mov	#4, R2
1$:		mov	(R0)+, (R1)+
		sob	R2, 1$
		mov	#200, R0		; set fd.
		ldfps	R0
		mov	#ffbbf1, R0		; set up the operand address.
		mov	#ffb2, @#$tmp2
		mov	#ffb10, @#errvect	; set up vector 4 in case of an error.

ffb2:		absd	(R0)+			; test instruction.
		stfps	R5			; get fps.
		mov	#ffbbf1, R1		; check result.
		mov	#4, R2
1$:		tst	(R1)+
		bne	ffb15			; branch if incorrect.
		sob	R2, 1$
		cmp	R0, #ffbbf1+10		; is R0 correct?
		bne	ffb20			; branch if incorrect.
		cmp	#204, R5		; is the fps correct?
		bne	ffb25			; branch if incorrect.
		br	ffbdone

; these are test data tables and data buffer.
ffbtp1:		177
		167574
		137271
		107675
ffbtp2:		0
		0
		0
		0
ffbbf0:		-1
		-1
		-1
		-1
ffbbf1:		-1
		-1
		-1
		-1

; if a trap to 4 occurs come here.
ffb10:		mov	(SP), R2		; see if the trap occurred on the test instruction.
		cmp	R2, #ffb2+2
		beq	1$			; branch if yes.
		cmp	R2, #ffb2+4
		beq	1$			; branch if yes.
		jmp	@#cpspur		; otherwise go report spurious trap to 4.
		
; report an fdst flow failure resulted in a trap to 4.
1$:		cmp	(SP)+, (SP)+
		mov	R2, @#$tmp2
2$:		emt	+2			; odd adres
		br	ffbdone			; but fdstx in st 771

; report result incorrect:
ffb15:		mov	#ffbtp2, @#$tmp3
		mov	#ffbtp1, @#$tmp4
		mov	#ffbbf1, @#$tmp5
1$:		emt	+2			; bad data x11*0 st 312x
		br	ffbdone

; report R0 incorrect:
ffb20:		mov	#ffbbf1+4, @#$tmp3
		mov	R0, @#$tmp4
1$:		emt	+2			; R0 badx
		br	ffbdone

; report fps incorrect:
ffb25:		mov	R5, @#$tmp3

		mov	#204, @#$tmp5
1$:		emt	+2			; fps x

ffbdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 23 - negf, absf and tstf source mode 4 test
; This is a test the negf, absf and tstf
; source flows. The absd instruction
; is used to test mode 4.
;
tst23:		scope
ggb1:
		lperr				; set up the loop on error address.
		mov	#ggbtp1, R0		; set up the data buffer.
		mov	#ggbbf0, R1
		mov	#4, R2
1$:		mov	(R0)+, (R1)+
		sob	R2, 1$
		mov	#200, R0		; set fd.
		ldfps	R0
		mov	#ggbbf1, R0		; set up the operand address.
		mov	#ggb2, @#$tmp2
		mov	#ggb10, @#errvect	; set up vector 4 in case of an error.

ggb2:		absd	-(R0)			; test instruction.
		stfps	R5			; get fps.
		mov	#ggbbf0, R1		; check result.
		mov	#4, R2
1$:		tst	(R1)+
		bne	ggb15			; branch if incorrect.
		sob	R2, 1$
		cmp	R0, #ggbbf0		; is R0 correct?
		bne	ggb20			; branch if incorrect.
		cmp	#204, R5		; is the fps correct?
		bne	ggb25			; branch if incorrect.
		br	ggbdone

; these are test data tables and data buffer.
ggbtp1:		177
		117273
		147576
		177071
ggbtp2:		0
		0
		0
		0
ggbbf0:		-1
		-1
		-1
		-1
ggbbf1:		-1
		-1
		-1
		-1

; if a trap to 4 occurs come here.
ggb10:		mov	(SP), R2		; see if the trap occurred on the test instruction.
		cmp	R2, #ggb2+2
		beq	1$			; branch if yes.
		cmp	R2, #ggb2+4
		beq	1$			; branch if yes.
		jmp	@#cpspur		; otherwise go report spurious trap to 4.

; report an fdst flow failure resulted in a trap to 4.
1$:		cmp	(SP)+, (SP)+
		mov	R2, @#$tmp2
2$:		emt	+2			; odd adres
		br	ggbdone			; but fdstx in st 771

; report result incorrect:
ggb15:		mov	#ggbtp2, @#$tmp3
		mov	#ggbtp1, @#$tmp4
		mov	#ggbbf0, @#$tmp5
1$:		emt	+2			; bad data x11*0 st 312x
		br	ggbdone

; report R0 incorrect:
ggb20:		mov	#ggbbf01, @#$tmp3
		mov	R0, @#$tmp4
1$:		emt	+2			; R0 badx
		br	ggbdone

; report fps incorrect:
ggb25:		mov	R5, @#$tmp3
		mov	#204, @#$tmp5
1$:		emt	+2			; fps x

ggbdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 24 - negf, absf and tstf source mode 3 test
; This is a test the negf, absf and tstf
; source flows. The absd instruction
; is used to test mode 3.
;
tst24:		scope
hhb1:
		lperr				; set up the loop on error address.
		mov	#hhbtp1, R0		; set up the data buffer.
		mov	#hhbbf0, R1
		mov	#10, R2
1$:		mov	(R0)+, (R1)+
		sob	R2, 1$
		mov	#200, R0		; set fd.
		ldfps	R0
		mov	#hhbbf1, R0		; set up the operand address.
		mov	#hhb2, @#$tmp2
		mov	#hhb10, @#errvect	; set up vector 4 in case of an error.

hhb2:		absd	@(R0)+			; test instruction.
		stfps	R5			; get fps.
		mov	#hhbbf0, R1		; check result.
		mov	#4, R2
1$:		tst	(R1)+
		bne	hhb15			; branch if incorrect.
		sob	R2, 1$
		cmp	R0, #hhbbf1+2		; is R0 correct?
		bne	hhb20			; branch if incorrect.
		cmp	#204, R5		; is the fps correct?
		bne	hhb25			; branch if incorrect.
		br	hhbdone

; these are test data tables and data buffer.
hhbtp1:		177
		147576
		177071
		107576, hhbbf0, -1, -1, -1

hhbtp2:		0, 0, 0, 0

hhbbf0:		-1
		-1
		-1
		-1
hhbbf1:		-1
		-1
		-1
		-1

; if a trap to 4 occurs come here.
hhb10:		mov	(SP), R2		; see if the trap occurred on the test instruction.
		cmp	R2, #hhb2+2
		beq	1$			; branch if yes.
		cmp	R2, #hhb2+4
		beq	1$			; branch if yes.
		jmp	@#cpspur		; otherwise go report spurious trap to 4.
		
; report an fdst flow failure resulted in a trap to 4.
1$:		cmp	(SP)+, (SP)+
		mov	R2, @#$tmp2
2$:		emt	+2			; odd adres
		br	hhbdone			; but fdstx in st 771

; report result incorrect:
hhb15:		mov	#hhbtp2, @#$tmp3
		mov	#hhbtp1, @#$tmp4
		mov	#hhbbf0, @#$tmp5
1$:		emt	+2			; bad data x11*0 st 3127
		br	hhbdone

; report R0 incorrect:
hhb20:		mov	#hhbbf1+2, @#$tmp3
		mov	R0, @#$tmp4
1$:		emt	+2			; R0 incorrect.
		br	hhbdone

; report fps incorrect:
hhb25:		mov	R5, @#$tmp3
		mov	#204, @#$tmp5
1$:		emt	+2			; fpsx

hhbdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 25 - negf, absf and tstf source mode 5 test
; This is a test the negf, absf and tstf
; source flows. The negd instruction
; is used to test mode 5.
;
tst25:		scope
iib1:
		lperr				; set up the loop on error address.
		mov	#iibtp1, R0		; set up the data buffer.
		mov	#iibbf0, R1
		mov	#10, R2
1$:		mov	(R0)+, (R1)+
		sob	R2, 1$
		mov	#200, R0		; set fd.
		ldfps	R0
		mov	#iibbf1+2, R0		; set up the operand address.
		mov	#iib2, @#$tmp2
		mov	#iib10, @#errvect	; set up vector 4 in case of an error.

iib2:		negd	@-(R0)			; test instruction.
		stfps	R5			; get fps.
		mov	#iibbf0, R1		; check result.
		mov	#4, R2
1$:		tst	(R1)+
		bne	iib15			; branch if incorrect.
		sob	R2, 1$
		cmp	R0, #iibbf1		; is R0 correct?
		bne	iib20			; branch if incorrect.
		cmp	#204, R5		; is the fps correct?
		bne	iib25			; branch if incorrect.
		br	iibdone

; these are test data tables and data buffer.
iibtp1:		176
		177074
		127374
		157677, iibbf0, -1, -1, -1
iibtp2:		0
		0
		0
		0
iibbf0:		-1
		-1
		-1
		-1
iibbf1:		-1
		-1
		-1
		-1

; if a trap to 4 occurs come here.
iib10:		mov	(SP), R2		; see if the trap occurred on the test instruction.
		cmp	R2, #iib2+2
		beq	1$			; branch if yes.
		cmp	R2, #iib2+4
		beq	1$			; branch if yes.
		jmp	@#cpspur		; otherwise go report spurious trap to 4.
		
; report an fdst flow failure resulted in a trap to 4.
1$:		cmp	(SP)+, (SP)+
		mov	R2, @#$tmp2
2$:		emt	+2			; odd adres
		br	iibdone			; but fdstx in st 771

; report result incorrect:
iib15:		mov	#iibtp2, @#$tmp3
		mov	#iibtp1, @#$tmp4
		mov	#iibbf0, @#$tmp5
1$:		emt	+2			; bad data x11*0 st 3127
		br	iibdone

; report R0 incorrect:
iib20:		mov	#iibbf1, @#$tmp3
		mov	R0, @#$tmp4
1$:		emt	+2			; R0 badx
		br	iibdone

; report fps incorrect:
iib25:		mov	R5, @#$tmp3
		mov	#204, @#$tmp5
1$:		emt	+2			; fpsx

iibdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 26 - negf, absf and tstf source mode 6 test
; This is a test the negf, absf and tstf
; source flows. The absd instruction
; is used to test mode 6.
;
tst26:		scope
jjb1:
		lperr				; set up the loop on error address.
		mov	#jjbtp1, R0		; set up the data buffer.
		mov	#jjbbf0, R1
		mov	#4, R2
1$:		mov	(R0)+, (R1)+
		sob	R2, 1$
		mov	#200, R0		; set fd.
		ldfps	R0
		mov	#jjbbf0-7, R0		; set up the operand address.
		mov	#jjb2, @#$tmp2
		mov	#jjb10, @#errvect	; set up vector 4 in case of an error.

jjb2:		absd	7(R0)			; test instruction.
		stfps	R5			; get fps.
		mov	#jjbbf0, R1		; check result.
		mov	#4, R2
1$:		tst	(R1)+
		bne	jjb15			; branch if incorrect.
		sob	R2, 1$
		cmp	R0, #jjbbf0-7		; is R0 correct?
		bne	jjb15			; branch if incorrect.
		cmp	#204, R5		; is the fps correct?
		bne	jjb20			; branch if incorrect.
		br	jjbdone

; these are test data tables and data buffer.
jjbtp1:		177
		161524
		131273
		107174, 
jjbtp2:		0
		0
		0
		0
jjbbf0:		-1
		-1
		-1
		-1
jjbbf1:		-1
		-1
		-1
		-1

; if a trap to 4 occurs come here.
jjb10:		mov	(SP), R2		; see if the trap occurred on the test instruction.
		cmp	R2, #jjb2+2
		beq	1$			; branch if yes.
		cmp	R2, #jjb2+4
		beq	1$			; branch if yes.
		jmp	@#cpspur		; otherwise go report spurious trap to 4.

; report an fdst flow failure resulted in a trap to 4.
1$:		cmp	(SP)+, (SP)+
		mov	R2, @#$tmp2
2$:		emt	+2			; odd adres
		br	jjbdone			; but fdstx in st 771

; report result incorrect:
jjb15:		mov	#jjbtp2, @#$tmp3
		mov	#jjbtp1, @#$tmp4
		mov	#jjbbf0, @#$tmp5
1$:		emt	+2			; bad data x11*0 st 3127
		br	jjbdone

; report R0 incorrect:
jjb20:		mov	#jjbbf0-7, @#$tmp3
		mov	R0, @#$tmp4
1$:		emt	+2			; R0 badx
		br	jjbdone

; report fps incorrect:
jjb25:		mov	R5, @#$tmp3
		mov	#204, @#$tmp5
1$:		emt	+2			; fpsx
jjbdone:
		rsetup

;_____________________________________________________________________________
;
; TEST 27 - negf, absf and tstf source mode 7 test
; This is a test the negf, absf and tstf
; source flows. The absd instruction
; is used to test mode 6.
;
tst27:		scope
kkb1:
		lperr				; set up the loop on error address.
		mov	#kkbtp1, R0		; set up the data buffer.
		mov	#kkbbf0, R1
		mov	#10, R2
1$:		mov	(R0)+, (R1)+
		sob	R2, 1$
		mov	#200, R0		; set fd.
		ldfps	R0
		mov	#kkbbf1-7, R0		; set up the operand address.
		mov	#kkb2, @#$tmp2
		mov	#kkb10, @#errvect	; set up vector 4 in case of an error.

kkb2:		negd	@7(R0)			; test instruction.
		stfps	R5			; get fps.
		mov	#kkbbf0, R1		; check result.
		mov	#4, R2
1$:		tst	(R1)+
		bne	kkb15			; branch if incorrect.
		sob	R2, 1$
		cmp	R0, #kkbbf1-7		; is R0 correct?
		bne	kkb20			; branch if incorrect.
		cmp	#204, R5		; is the fps correct?
		bne	kkb20			; branch if incorrect.
		br	kkbdone

; these are test data tables and data buffer.
kkbtp1:		177
		167574
		137271
		107675, kkbbf0, -1, -1, -1
kkbtp2:		0
		0
		0
		0
kkbbf0:		-1
		-1
		-1
		-1
kkbbf1:		-1
		-1
		-1
		-1

; if a trap to 4 occurs come here.
kkb10:		mov	(SP), R2		; see if the trap occurred on the test instruction.
		cmp	R2, #kkb2+2
		beq	1$			; branch if yes.
		cmp	R2, #kkb2+4
		beq	1$			; branch if yes.
		jmp	@#cpspur		; otherwise go report spurious trap to 4.

; report an fdst flow failure resulted in a trap to 4.
1$:		cmp	(SP)+, (SP)+
		mov	R2, @#$tmp2
2$:		emt	+2			; odd adres
		br	kkbdone			; but fdstx in st 771

; report result incorrect:
kkb15:		mov	#kkbtp2, @#$tmp3
		mov	#kkbtp1, @#$tmp4
		mov	#kkbbf0, @#$tmp5
1$:		emt	+2			; bad data x11*0 st 3127
		br	kkbdone

; report rc incorrect:
kkb20:		mov	#kkbbf1-7, @#$tmp3
		mov	R0, @#$tmp4
1$:		emt	+2			; R0 badx
		br	kkbdone

; report fps incorrect:
kkb25:		mov	R5, @#$tmp3
		mov	#204, @#$tmp5
1$:		emt	+2			; fpsx

kkbdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 30 - negf, absf and tstf source mode 6, gr7, test
; This is a test the negf, absf and tstf
; source flows. The negd instruction
; is used to test mode 6.
;
tst30:		scope
llb1:
		lperr				; set up the loop on error address.
		mov	#llbtp1, R0		; set up the data buffer.
		mov	#llbbf0, R1
		mov	#4, R2
1$:		mov	(R0)+, (R1)+
		sob	R2, 1$
		mov	#200, R0		; set fd.
		ldfps	R0
		mov	#llb2, @#$tmp2
		mov	#llb10, @#errvect	; set up vector 4 in case of an error.

llb2:		negd	llbbf0			; test instruction.
		stfps	R5			; get fps.
		mov	#llbbf0, R1		; check result.
		mov	#4, R2
1$:		tst	(R1)+
		bne	llb15			; branch if incorrect.
		sob	R2, 1$
		cmp	#204, R5		; is the fps correct?
		bne	llb25			; branch if incorrect.
		br	llbdone

; these are test data tables and data buffer.
llbtp1:		127
		137475
		147372
		117057
llbtp2:		0
		0
		0
		0
llbbf0:		-1
		-1
		-1
		-1
llbbf1:		-1
		-1
		-1
		-1

; if a trap to 4 occurs come here.
llb10:		mov	(SP), R2		; see if the trap occurred on the test instruction.
		cmp	R2, #llb2+2
		beq	1$			; branch if yes.
		cmp	R2, #llb2+4
		beq	1$			; branch if yes.
		jmp	@#cpspur		; otherwise go report spurious trap to 4.
; report an fdst flow failure resulted in a trap to 4.
1$:		cmp	(SP)+, (SP)+
		mov	R2, @#$tmp2
2$:		emt	+2			; odd adres
		br	llbdone			; but fdstx in st 771

; report result incorrect:
llb15:		mov	#llbtp2, @#$tmp3
		mov	#llbtp1, @#$tmp4
		mov	#llbbf0, @#$tmp5
1$:		emt	+2			; bad data x11*0 st 3127
		br	llbdone

; report fps incorrect:
llb25:		mov	R5, @#$tmp3
		mov	#204, @#$tmp5
1$:		emt	+2			; fpsx

llbdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 31 - negf, absf and tstf source mode 7, gr7, test
; This is a test the negf, absf and tstf
; source flows. The absd instruction
; is used to test mode 7.
;
tst31:		scope
mmb1:
		lperr				; set up the loop on error address.
		mov	#mmbtp1, R0		; set up the data buffer.
		mov	#mmbbf0, R1
		mov	#10, R2
1$:		mov	(R0)+, (R1)+
		sob	R2, 1$
		mov	#200, R0		; set fd.
		ldfps	R0
		mov	#mmb2, @#$tmp2
		mov	#mmb10, @#errvect	; set up vector 4 in case of an error.

mmb2:		absd	@mmbbf1			; test instruction.
		stfps	R5			; get fps.
		mov	#mmbbf0, R1		; check result.
		mov	#4, R2
1$:		tst	(R1)+
		bne	mmb15			; branch if incorrect.
		sob	R2, 1$
		cmp	#204, R5		; is the fps correct?
		bne	mmb25			; branch if incorrect.
		br	mmbdone

; these are test data tables and data buffer.
mmbtp1:		137
		045607
		101230
		45607, mmbbf0, -1, -1, -1
mmbtp2:		0
		0
		0
		0
mmbbf0:		-1
		-1
		-1
		-1
mmbbf1:		-1
		-1
		-1
		-1

; if a trap to 4 occurs come here.
mmb10:		mov	(SP), R2		; see if the trap occurred on the test instruction.
		cmp	R2, #mmb2+2
		beq	1$			; branch if yes.
		cmp	R2, #mmb2+4
		beq	1$			; branch if yes.
		jmp	@#cpspur		; otherwise go report spurious trap to 4.
; report an fdst flow failure resulted in a trap to 4.
1$:		cmp	(SP)+, (SP)+
		mov	R2, @#$tmp2
2$:		emt	+2			; odd adres
		br	mmbdone			; but fdstx in st 771

; report result incorrect:
mmb15:		mov	#mmbtp2, @#$tmp3
		mov	#mmbtp1, @#$tmp4
		mov	#mmbbf0, @#$tmp5
1$:		emt	+2			; bad data x11*0 st 3127
		br	mmbdone

; report fps incorrect:
mmb25:		mov	R5, @#$tmp3
		mov	#204, @#$tmp5
1$:		emt	+2			; fpsx

mmbdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 32 - special dest, mode 0, test
; This is a test of the negf, absf and tstf destination flows
; mode 0 using the negd instr.
;
tst32:		scope
nnb1:
		lperr				; set up the loop on error address.
		mov	#200, R0		; set fd.
		ldfps	R0
		mov	#nnbtp1, R0		; set up ac0
		ldd	(R0), ac0
		mov	#nnb2, @#$tmp2

nnb2:		negd	ac0			; test instruction.
		stfps	R5			; get fps.
		mov	#200, R0		; set fd.
		ldfps	R0
		mov	#nnbbf0, R0		; get the result.
		std	ac0, (R0)
		mov	#nnbbf0, R0		; is the result correct?
		mov	#nnbtp2, R1
		mov	#4, R2
1$:		cmp	(R0)+, (R1)+
		bne	nnb10			; branch if incorrect.
		sob	R2, 1$
		cmp	#210, R5		; is the fps correct?
		bne	nnb15			; branch if incorrect.
		br	nnbdone

; these are data tables and a data buffer.
nnbtp1:		013572
		46013
		57246
		013570
nnbtp2:		113572
		46013
		57246
		013570
nnbbf0:		0
		0
		0
		0

; report result incorrect:
nnb10:		mov	#nnbbf0, @#$tmp3
		mov	#nnbtp2, @#$tmp4
		cmp	@#nnbtp1, @#nnbbf0
		bne	nnb11
1$:		emt	+1			; e10*200x st 336
		br	nnbdone

; report result incorrect:
nnb11:
1$:		emt	+1			; bad data negf
		br	nnbdone

; report fps incorrect:
nnb15:		mov	R5, @#$tmp4
		mov	#210, @#$tmp3
1$:		emt	+1			; fpsx

nnbdone:
		rsetup

;_____________________________________________________________________________
;
; TEST 33 - special dest, mode 1, test
; This is a test of the negf, absf and tstf destination flows
; mode 1 using the negd instr.
;
tst33:		scope
oob1:
		lperr				; set up the loop on error address.
		mov	#oobtp1, R1		; set up the data buffer.
		mov	#oobtp2, R0
		mov	#4, R2
1$:		mov	(R0)+, (R1)+
		sob	R2, 1$
		mov	#oobtp1, R0
		bic	#100000, (R0)		; make operand positive.
		mov	#oob2, @#$tmp2
		mov	#200, R1		; set fd.
		ldfps	R1

oob2:		negd	(R0)			; test instruction.
		stfps	R5			; get fps.
		mov	#oobtp1, R1		; is the result correct.
		mov	#oobtp2, R2
		mov	#4, R3
1$:		cmp	(R1)+, (R2)+
		bne	oob10			; branch if incorrect.
		sob	R3, 1$
		cmp	#oobtp1, R0		; is R0 correct.
		bne	oob15			; branch if incorrect.
		cmp	#210, R5		; is the fps correct?
		bne	oob20			; branch if incorrect.
		br	oobdone

; these are data tables and a data buffer.
oobtp1:		023245
		26720
		122324
		52672
oobtp2:		123245
		26720
		122324
		52672

; report result incorrect:
oob10:		mov	#oobtp1, @#$tmp3
		mov	#oobtp2, @#$tmp4
1$:		emt	+2			; bad data
		br	oobdone

; report R0 incorrect:
oob15:		mov	#oobtp1, @#$tmp3
		mov	R0, @#$tmp4
1$:		emt	+2			; spec destx
		br	oobdone			; rox

; report fps incorrect:
oob20:		mov	#210, @#$tmp3
		mov	R5, @#$tmp4
1$:		emt	+2

oobdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 34 - special dest, mode 2, test
; This is a test of the negf, absf and tstf destination flows
; mode 2 using the negd instr.
;
tst34:		scope
ppb1:
		lperr				; set up the loop on error address.
		mov	#ppbtp1, R1		; set up the data buffer.
		mov	#ppbtp2, R0
		mov	#4, R2
1$:		mov	(R0)+, (R1)+
		sob	R2, 1$
		mov	#ppbtp1, R0
		bic	#100000, (R0)		; make operand positive.
		mov	#ppb2, @#$tmp2
		mov	#200, R1		; set fd.
		ldfps	R1

ppb2:		negd	(R0)+			; test instruction.
		stfps	R5			; get fps.
		mov	#ppbtp1, R1		; is the result correct.
		mov	#ppbtp2, R2
		mov	#4, R3
1$:		cmp	(R1)+, (R2)+
		bne	ppb10			; branch if incorrect.
		sob	R3, 1$
		cmp	#ppbtp1+10, R0		; is R0 correct.
		bne	ppb15			; branch if incorrect.
		cmp	#210, R5		; is the fps correct?
		bne	ppb20			; branch if incorrect.
		br	ppbdone

; these are data tables and a data buffer.
ppbtp1:		023245
		26720
		122324
		52672
ppbtp2:		123245
		26720
		122324
		52672

; report result incorrect:
ppb10:		mov	#ppbtp1, @#$tmp3
		mov	#ppbtp2, @#$tmp4
1$:		emt	+1			; bad data
		br	ppbdone

; report R0 incorrect:
ppb15:		mov	#ppbtp1+10, @#$tmp3
		mov	R0, @#$tmp4
1$:		emt	+1			; spec destx rox
		br	ppbdone

; report fps incorrect:
ppb20:		mov	#210, @#$tmp3
		mov	R5, @#$tmp4
1$:		emt	+1

ppbdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 35 - special dest, mode 4, test
; This is a test of the negf, afisf and tstf destination flows
; mode 4 using the negd instr.
;
tst35:		scope
qqb1:
		lperr				; set up the loop on error address.
		mov	#qqbtp1, R1		; set up the data buffer.
		mov	#qqbtp2, R0
		mov	#4, R2
1$:		mov	(R0)+, (R1)+
		sob	R2, 1$
		mov	#qqbtp1+10, R0
		bic	#100000, -10(R0)	; make operand positive.
		mov	#qqb2, @#$tmp2
		mov	#200, R1		; set fd.
		ldfps	R1

qqb2:		negd	-(R0)			; test instruction.
		stfps	R5			; get fps.
		mov	#qqbtp1, R1		; is the result correct.
		mov	#qqbtp2, R2
		mov	#4, R3
1$:		cmp	(R1)+, (R2)+
		bne	qqb10			; branch if incorrect.
		sob	R3, 1$
		cmp	#qqbtp1, R0		; is R0 correct.
		bne	qqb15			; branch if incorrect.
		cmp	#210, R5		; is the fps correct?
		bne	qqb20			; branch if incorrect.
		br	qqbdone

; these are data tables and a data buffer.
qqbtp1:		023245
		26720
		122324
		52672
		.word	-1, -1, -1, -1
qqbtp2:		123245
		26720
		122324
		52672

; report result incorrect:
qqb10:		mov	#qqbtp1, @#$tmp3
		mov	#qqbtp2, @#$tmp4
1$:		emt	+1			; bad data
		br	qqbdone

; report R0 incorrect:
qqb15:		mov	#qqbtp1, @#$tmp3
		mov	R0, @#$tmp4
1$:		emt	+1			; spec destx rox
		br	qqbdone

; report fps incorrect:
qqb20:		mov	#210, @#$tmp3
		mov	R5, @#$tmp4
1$:		emt	+1

qqbdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 36 - special dest, mode 3, test
; This is a test of the negf, absf and tstf destination flows
; mode 3 using the negd instr.
;
tst36:		scope
rrb1:
		lperr				; set up the loop on error address.
		mov	#rrbtp1, R1		; set up the data buffer.
		mov	#rrbtp2, R0
		mov	#4, R2
1$:		mov	(R0)+, (R1)+
		sob	R2, 1$
		mov	#rrbtp3, R0
		mov	#rrbtp1, (R0)
		bic	#100000, @#rrbtp1	; make the operand positive.
		mov	#rrb2, @#$tmp2
		mov	#200, R1		; set fd.
		ldfps	R1

rrb2:		negd	@(R0)+			; test instruction.
		stfps	R5			; get fps.
		mov	#rrbtp1, R1		; is the result correct.
		mov	#rrbtp2, R2
		mov	#4, R3
1$:		cmp	(R1)+, (R2)+
		bne	rrb10			; branch if incorrect.
		sob	R3, 1$
		cmp	#rrbtp3+2, R0		; is R0 correct.
		bne	rrb15			; branch if incorrect.
		cmp	#210, R5		; is the fps correct?
		bne	rrb20			; branch if incorrect.
		br	rrbdone

; these are data tables and a data buffer.
rrbtp1:		023245
		26720
		122324
		52672
rrbtp2:		123245
		26720
		123324
		52672
rrbtp3:		rrbtp1

; report result incorrect:
rrb10:		mov	#rrbtp1, @#$tmp3
		mov	#rrbtp2, @#$tmp4
1$:		emt	+1			; bad data
		br	rrbdone

; report R0 incorrect:
rrb15:		mov	#rrbtp3+2, @#$tmp3
		mov	R0, @#$tmp4
1$:		emt	+1			; spec destx rox
		br	rrbdone

; report fps incorrect:
rrb20:		mov	#210, @#$tmp3
		mov	R5, @#$tmp4
1$:		emt	+1

rrbdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 37 - special dest, mode 5, test
; This is a test of the negf, absf and tstf destination flows
; mode 5 using the negd instr.
;
tst37:		scope
ssb1:
		lperr				; set up the loop on error address.
		mov	#ssbtp1, R1		; set up the data buffer.
		mov	#ssbtp2, R0
		mov	#4, R2
1$:		mov	(R0)+, (R1)+
		sob	R2, 1$
		mov	#ssbtp3+2, R0
		mov	#ssbtp1, -2(R0)
		bic	#100000, @#ssbtp1	; make the operand positive.
		mov	#ssb2, @#$tmp2
		mov	#200, R1		; set fd.
		ldfps	R1

ssb2:		negd	@-(R0)			; test instruction.
		stfps	R5			; get fps.
		mov	#ssbtp1, R1		; is the result correct.
		mov	#ssbtp2, R2
		mov	#4, R3
1$:		cmp	(R1)+, (R2)+
		bne	ssb10			; branch if incorrect.
		sob	R3, 1$
		cmp	#ssbtp3, R0		; is R0 correct.
		bne	ssb15			; branch if incorrect.
		cmp	#210, R5		; is the fps correct?
		bne	ssb20			; branch if incorrect.
		br	ssbdone

; these are data tables and a data buffer.
ssbtp1:		023245
		26720
		122324
		52672
ssbtp2:		123245
		26270
		122324
		52672
ssbtp3:		ssbtp1

; report result incorrect:
ssb10:		mov	#ssbtp1, @#$tmp3
		mov	#ssbtp2, @#$tmp4
1$:		emt	+1			; bad data
		br	ssbdone

; report R0 incorrect:
ssb15:		mov	#ssbtp3, @#$tmp3
		mov	R0, @#$tmp4
1$:		emt	+1			; spec destx rox
		br	ssbdone

; report fps incorrect:
ssb20:		mov	#210, @#$tmp3
		mov	R5, @#$tmp4
1$:		emt	+1

ssbdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 40 - special dest, floating mode 2, test
; This is a test of the negf, absf and tstf destination flows
; modf 2 using the negf instr.
;
tst40:		scope
ttb1:
		lperr				; set up the loop on error address.
		mov	#ttbtp1, R1		; set up the data buffer.
		mov	#ttbtp2, R0
		mov	#4, R2
1$:		mov	(R0)+, (R1)+
		sob	R2, 1$
		mov	#ttbtp1, R0
		bic	#100000, (R0)		; make operand positive.
		mov	#ttb2, @#$tmp2
		mov	#000, R1		; set fd.
		ldfps	R1

ttb2:		negf	(R0)+			; test instruction.
		stfps	R5			; get fps.
		mov	#ttbtp1, R1		; is the result correct.
		mov	#ttbtp2, R2
		mov	#4, R3
1$:		cmp	(R1)+, (R2)+
		bne	ttb10			; branch if incorrect.
		sob	R3, 1$
		cmp	#ttbtp1+4, R0		; is R0 correct.
		bne	ttb15			; branch if incorrect.
		cmp	#010, R5		; is the fps correct?
		bne	ttb20			; branch if incorrect.
		br	ttbdone

; these are data tables and a data buffer.
ttbtp1:		023245
		26720
		122324
		52672
ttbtp2:		123245
		26720
		122324
		52672

; report result incorrect:
ttb10:		mov	#ttbtp1, @#$tmp3
		mov	#ttbtp2, @#$tmp4
1$:		emt	+1			; bad data
		br	ttbdone

; report R0 incorrect:
ttb15:		mov	#ttbtp1+4, @#$tmp3
		mov	R0, @#$tmp4
1$:		emt	+1			; spec destx rox
		br	ttbdone

; report fps incorrect:
ttb20:		mov	#010, @#$tmp3
		mov	R5, @#$tmp4
1$:		emt	+1

ttbdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 41 - special dest, mode2, gr7 (immediate), test
; This is a test of the negf, absf and tstf destination flows
; mode 2 (immediate) using the negd instr.
;
tst41:		scope
uub1:
		lperr				; set up the loop on error address.
		mov	#uubtp2, R0
		mov	#uubtp1, R1		; set up the data buffer.
		mov	#4, R2
1$:		mov	(R0)+, (R1)+
		sob	R2, 1$
		mov	#uubtp1, R0
		bic	#100000, @#uubtp1	; make the operand positive.
		mov	#uub2, @#$tmp2
		mov	#200, R1		; set fd.
		ldfps	R1
		clr	R1

uub2:		negd	(R7)+			; test instruction.

uubtp1:		5201, 5201, 5201, 5201

; note that after executing this instruction R1 should contain 3.
		stfps	R5			; get fps.
		mov	#uubtp1, R3		; is the result correct.
		mov	#uubtp2, R2
		mov	#4, R4
1$:		cmp	(R3)+, (R2)+
		bne	uub10			; branch if incorrect.
		sob	R4, 1$
		cmp	#3, R1			; was R1 incremented correctly.
		bne	uub15			; branch if incorrect.
		cmp	#210, R5		; is the fps correct?
		bne	uub20			; branch if incorrect.
		br	uubdone

; these are data table.
uubtp2:		105201
		5201
		5201
		5201

; report result incorrect:
uub10:		mov	#uubtp1, @#$tmp3
		mov	#uubtp2, @#$tmp4
1$:		emt	+1			; bad data
		br	uubdone

; report fps incorrect:
uub20:		mov	#210, @#$tmp3
		mov	R5, @#$tmp4
1$:		emt	+1			; fps
		br	uubdone

; report PC incorrectly incremented during execution.
uub15:		sub	#3, R1
		asl	R1
		mov	#uubtp1+2, R2
		mov	R2, @#$tmp3
		sub	R1, R2
		mov	R2, @#$tmp4
1$:		emt	+1			; PC bad constand b gr7x

uubdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 42 - special dest, mode 6, test
; This is a test of the negf, absf and tstf destination flows
; mode 6 using the negd instr.
;
tst42:		scope
xxb1:
		lperr				; set up the loop on error address.
		mov	#xxbtp1, R1		; set up the data buffer.
		mov	#xxbtp2, R0
		mov	#4, R2
1$:		mov	(R0)+, (R1)+
		sob	R2, 1$
		mov	#xxbtp1-5201, R0
		bic	#100000, @#xxbtp1	; make operand positive.
		mov	#xxb2, @#$tmp2
		mov	#200, R1		; set fd.
		ldfps	R1
		clr	R1

xxb2:		negd	5201(R0)		; test instruction.
		stfps	R5			; get fps.
		tst	R1
		bne	xxb25			; was the PC correct after execution?
		mov	#xxbtp1, R1		; is the result correct.
		mov	#xxbtp2, R2
		mov	#4, R3
1$:		cmp	(R1)+, (R2)+
		bne	xxb10			; branch if incorrect.
		sob	R3, 1$
		cmp	#xxbtp1-5201, R0	; is R0 correct.
		bne	xxb15			; branch if incorrect.
		cmp	#210, R5		; is the fps correct?
		bne	xxb20			; branch if incorrect.
		br	xxbdone

; these are data tables and a data buffer.
xxbtp1:		023245
		26720
		122324
		52672
xxbtp2:		123245
		26720
		122324
		52672

; report PC incorrect after execution.
xxb25:		mov	#xxb2+2, @#$tmp4
		mov	#xxb2+4, @#$tmp3
1$:		emt	+1			; PC not incremented by 2.
		br	xxbdone

; report result incorrect:
xxb10:		mov	#xxbtp1, @#$tmp3
		mov	#xxbtp2, @#$tmp4
1$:		emt	+1			; bad data
		br	xxbdone

; report R0 incorrect:
xxb15:		mov	#xxbtp1-5201, @#$tmp3
		mov	R0, @#$tmp4
1$:		emt	+1			; spec destx rox
		br	xxbdone

; report fps incorrect:
xxb20:		mov	#210, @#$tmp3
		mov	R5, @#$tmp4
1$:		emt	+1

xxbdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 43 - special dest. mode 7, test
; This is a test of the negf, absf and tstf destination flows
; mode 7 using the negd instr.
;
tst43:		scope
yyb1:
		lperr				; set up the loop on error address.
		mov	#yybtp1, R1		; set up the data buffer.
		mov	#yybtp2, R0
		mov	#4, R2
1$:		mov	(R0)+, (R1)+
		sob	R2, 1$
		mov	#yybtp3-5201, R0
		mov	#yybtp1, 5201(R0)
		bic	#100000, @#yybtp1	; make the operand positive.
		mov	#yyb2, @#$tmp2
		mov	#200, R1		; set fd.
		ldfps	R1
		clr	R1

yyb2:		negd	@5201(R0)		; test instruction.
		stfps	R5			; get fps.
		tst	R1			; was the PC correct after execution?
		bne	yyb25
		mov	#yybtp1, R1		; is the result correct.
		mov	#yybtp2, R2
		mov	#4, R3
1$:		cmp	(R1)+, (R2)+
		bne	yyb10			; branch if incorrect.
		sob	R3, 1$
		cmp	#yybtp3-5201, R0	; is R0 correct.
		bne	yyb15			; branch if incorrect.
		cmp	#210, R5		; is the fps correct?
		bne	yyb20			; branch if incorrect.
		br	yybdone

; these are data tables and a data buffer.
yybtp1:		023245
		26720
		122324
		52672
yybtp2:		123245
		26720
		123324
		52672
yybtp3:		yybtp1

; report PC incorrect after execution.
yyb25:		mov	yyb2+2, @#$tmp4
		mov	yyb2+4, @#$tmp3
1$:		emt	+2			; PC not incremented by 2.
		br	yybdone

; report result incorrect:
yyb10:		mov	#yybtp1, @#$tmp3
		mov	#yybtp2, @#$tmp4
1$:		emt	+2			; bad data
		br	yybdone

; report R0 incorrect:
yyb15:		mov	#yybtp3-5201, @#$tmp3
		mov	R0, @#$tmp4
1$:		emt	+2			; spec destx rox
		br	yybdone

; report fps incorrect:
yyb20:		mov	#210, @#$tmp3
		mov	R5, @#$tmp4
1$:		emt	+2

yybdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 44 - negd, absd and tstd test
; This is a test of the negd, absd and tstd instructions.
;
tst44:		scope
; test negd with pos nonzero operand
wwb1:
		lperr				; set up the loop on error address.
		jsr	pc, natsub
1$:		0				; flag=negd.
2$:		16341				; operand.
		55772
		21133
		55447
3$:		116341				; result.
		55772
		21133
		55447
4$:		16341				; error res.
		55772
		21133
		55447
5$:		207				; fps before execution.
		210				; fps after execution.
		200				; error fps.
		-1				; fec
6$:		emt	+2			; e10<---e10*200x st 336
		br	7$
		emt	+2			; but enbt st 336x went to 053 into 453
7$:

; test negd with neg operand.
wwb2:
		lperr				; set up the loop on error address.
		jsr	pc, natsub
1$:		0				; flag=negd.
2$:		152525				; operand.
		53545
		55565
		57505
3$:		52525				; result.
		53545
		55565
		57505
4$:		152525				; error res.
		53545
		55565
		57505
5$:		217				; fps before execution.
		200				; fps after execution.
		210				; error fps.
		-1				; fec
6$:		emt	+2			; e10<---e10*200x s336
		br	7$
		emt	+2			; but enbt x st336 to 453 into 053
7$:

; test absd with positive operand
wwb3:
		lperr				; set up the loop on error address.
		jsr	pc, natsub
1$:		1				; flag=absd.
2$:		60705				; operand.
		124735
		60124
		73560
3$:		60705				; result.
		124735
		60124
		73560
4$:		160705				; error res.
		124735
		60124
		73560
5$:		217				; fps before execution.
		200				; fps after execution.
		210				; error fps.
		-1				; either but op1b
6$:		emt	+2			; but st 055 to 336 into 335
		br	7$
		emt	+2			; or but enbt st 335 to 452 into 052
7$:

; test absd with neg. operand
wwb4:
		lperr				; set up the loop on error address.
		jsr	pc, natsub
1$:		1				; flag=absd.
2$:		154345				; operand.
		76567
		32123
		43234

3$:		54345				; result.
		76567
		32123
		43234
4$:		154345				; error res.
		76567
		32123
		43234
5$:		217				; fps before execution.
		200				; fps after execution.
		-1				; error fps.
		-1
6$:		emt	+2			; e10*e10*200x st 452
		br	7$
		emt	+2
7$:

; test with positive op
wwb5:
		lperr				; set up the loop on error address.
		jsr	pc, natsub
1$:		2				; flag=tstd.
2$:		12321				; operand.
		45654
		70107
		34543
3$:		12321				; result.
		45654
		70107
		34543
4$:		112321				; error res.
		45654
		70107
		34543
5$:		217				; fps before execution.
		200				; fps after execution.
		210				; error fps.
		-1
6$:		emt	+2			; but (op1b) x st044 to 336 into 334
		br	7$
		emt	+2			; but enbt st 334 to 453 into 053
7$:

; test tstd with neg op
wwb6:
		lperr				; set up the loop on error address.
		jsr	pc, natsub
1$:		2				; flag=tstd.
2$:		123765				; operand.
		23407
		34510
		45621
3$:		123765				; result.
		23407
		34510
		45621
4$:		23765				; error res.
		23407
		34510
		45621
5$:		207				; fps before execution.
		210				; fps after execution.
		200				; error fps.
		-1
6$:		emt	+2			; but opb1 st 055 to 335 into 334
		br	7$
		emt	+2			; but enbt st 334 to 053 into 453
7$:

; test tstd 0 op
wwb7:
		lperr				; set up the loop on error address.
		jsr	pc, natsub
1$:		2				; flag=tstd.
2$:		175				; operand.
		176737
		71727
		37574
3$:		175				; result.
		176737
		71727
		37574
4$:		0				; error res.
		0
		0
		0
5$:		200				; fps before execution.
		204				; fps after execution.
		214				; error fps.
		-1
6$:		emt	+2			; but op1b st 255 to 311 or 312 into 310
		br	7$
		emt	+2			; but enbt st 310 to 402 into 002
7$:

; test tstd -0 op fiuv=0
wwb8:
		lperr				; set up the loop on error address.
		jsr	pc, natsub
1$:		2				; flag=tstd.
2$:		100123				; operand.
		21012
		34565
		43210
3$:		100123				; result.
		21012
		34565
		43210
4$:		0				; error res.
		0
		0
		0
5$:		40203				; fps before execution.
		040214				; fps after execution.
		140214				; error fps.
		-1
6$:		emt	+2
		br	7$
		emt	+2			; but fiuv st 257 to 355 into 255
7$:

; test tstd -0 op fiuv=1
wwb9:
		lperr				; set up the loop on error address.
		jsr	pc, natsub
1$:		2				; flag=tstd.
2$:		100137				; operand.
		24613
		57024
		60137
3$:		100137				; result.
		24613
		57024
		60137
4$:		0				; error res.
		0
		0
		0
5$:		44200				; fps before execution.
		144214				; fps after execution.
		044214				; error fps.
		14
6$:		emt	+2			; +
		br	7$
		emt	+2			; but fiuv st 257 to 255 into 355
7$:
		jmp	wwbdone

; This subroutine, natsub, is used to set up the operands, execute
; the either a tstd, an absd or a negd instruction and check the results. A call
; to it is made thus:
;
;		jsr	pc, @#natsub
;	flag:	.word	x			; instruction type flag.
;	acarg:	.word	x, x, x, x		; operand
;	res:	.word	x, x, x, x		; expected result
;	erres:	.word	x, x, x, x		; error result
;	fpsb:	.word	x			; fps before execution
;	fpsa:	.word	x			; fps after execution
;	fec:	.word	x			; expected fec
;	erfps:	.word	x			; error fps.
;	err1:	emt	+2			; data error.
;		br	cont
;	err2:	emt	+2			; fps error.
;	cont:					; return address
;
; The operand is set up in natbf1. Then
; the either the tstd, negd or absd instruction is executed.
; natsub uses the first operand as a flag to determine which instruction
; is to be executed: 0=negd, 1=absd, 2=tstd.
; The result is checked against res. If the result is correct then the fps is
; compared with fpsa. If this too is correct natsub returns control
; to the calling routine at cont. If the fps is bad natsub
; compare it to error fps. If this matches then nat sub will return
; to the error call at err2, otherwise natsub itself
; reports this failure and then returns to cont. If the result of the
; instruction is incorrect, the incorrect result 1$ compared with the
; anticipated failing data pattern, erres. If the failure in
; the result was anticipated correctly to be erres then natsub
; will transfer control to the error call at err1. Otherwise the
; result was incorrect but was not anticipated and natsub will
; report the failure after which control will be passed to cont.
;
natsub:		mov	(SP)+, R1		; get a pointer to the arguments.
		mov	R1, R2			; copy the operand.
		add	#2, R2
		mov	#natbf1, R3
		mov	#4, R4
1$:		mov	(R2)+, (R3)+
		sob	R4, 1$
		mov	32(R1), R0		; load the fps.
		ldfps	R0
		mov	#natbf1, R0		; set up the operand address.
		mov	(R1), R2		; get the flag to determine which
		asl	R2			; instruction to execute.
		asl	R2			; 0=negd, 1=absd, 2=tstd
		mov	#natins, R3
		add	R2, R3
		mov	R3, @#$tmp2
		jmp	(R3)			; go execute the instruction.

natins:		negd	(R0)
		br	2$
		absd	(R0)
		br	2$
		tstd	(R0)
2$:		stfps	R4			; get the fps.
		stst	R5			; get the fec.
		mov	R1, R2
		add	#2, R2
		mov	R2, @#$tmp3
		add	#10, R2
		mov	R2, @#$tmp5
		mov	#natbf1, @#$tmp4
		mov	R4, @#$tmp7
		mov	34(R1), @#$tmp10
		mov	R1, R0			; was the result correct?
		add	#12, R0
		mov	#natbf1, R2
		mov	#4, R3
3$:		cmp	(R0)+, (R2)+
		bne	10$			; branch if incorrect.
		sob	R3, 3$
		cmp	34(R1), R4		; was the fps correct?
		bne	15$			; branch if incorrect.
		tst	34(R1)			; if the expected fps was negative check the fec.
		bpl	4$

		cmp	40(R1), R5		; was the fec correct.
		bne	20$			; branch if incorrect.
4$:		jmp	50(R1)			; return.

; the result was incorrect but was this failure anticipated?
; see if the result was anticipated:
10$:
		mov	(R1), R5
		asl	R5
		asl	R5
		add	#nater1, R5
		mov	R1, R0
		add	#22, R0
		mov	#natbf1, R2
		mov	#4, R3
11$:		cmp	(R0)+, (R2)+
		bne	12$			; branch if not anticipated.
		sob	R3, 11$

; the error was anticipated so return.
		jmp	42(R1)

; the error was not anticipated so report it here.
12$:		jmp	(R5)			; go to the proper error call.

; the fps was incorrect.
15$:		cmp	36(R1), R5		; was this error anticipated?
		bne	16$			; branch if not anticipated.

; the fps error was anticipated so return.
		jmp	46(R1)

; the fps failure was not anticipated so report it here.
16$:		mov	(R1), R2
		asl	R2
		asl	R2
		add	#nater2, R2
		jmp	(R2)			; go to the proper error call.

; report that the fec was incorrect.
20$:		mov	40(R1), @#$tmp12
		mov	R5, @#$tmp11
		mov	(R1), R2
		asl	R2
		asl	R2
		add	#nater3, R2
		jmp	(R2)			; go to the proper error call.

; these are the error calls for each individual instruction and condition.
nater1:		emt	+2			; negd bad data
		br	natret
		emt	+2			; absd bad data
		br	natret
		emt	+2			; tstd bad data

natret:		jmp	50(R1)

; fps incorrect:
nater2:		emt	+2			; negd fpsx
		br	natret
		emt	+2			; absd fpsx
		br	natret
		emt	+2			; tstd fpsx
		br	natret

; fec incorrect:
nater3:		emt	+2			; negd fecx
		br	natret
		emt	+2			; absd fecx
		br	natret
		emt	+2			; tstd fecx
		br	natret

		.word	-1
natbf1:		.word	-1, -1, -1, -1, -1

wwbdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 45 - source modes, mode 1 (fl=0), test
; This is a test of source mode 1
; using the ldfps instr.
;
tst45:		scope
aac1:
		lperr				; set up the loop on error address.
		mov	#aactp1, R0		; set up test data in buffer.
		mov	#147517, (R0)
		mov	#147517, @#$tmp3	; save data in case of error.
		mov	#aac2, @#$tmp2
		mov	#aac20, @#errvect	; set up for traps to 4.
aac2:		ldfps	(R0)			; test instruction.
		stfps	R5			; get fps
		cmp	R0, #aactp1		; is R0 correct?
		bne	aac10			; br if not.
		cmp	#147517, R5		; is fps correct?
		bne	aac11			; br if not.
		br	aacdone

; test buffer and data:
		-1
aactp1:		147517
		-1

; report R0 incorrect.
aac10:		mov	#aactp1, @#$tmp3
		mov	R0, @#$tmp4
1$:		emt	+1			; R0 bad but fsrc failed
		br	aacdone

; report fps incorrect.
aac11:		mov	#147517, @#$tmp3	; report fps incorrect.
		mov	R5, @#$tmp4
1$:		emt	+1
		br	aacdone

; trap here through vector four. see if the trap was during
; execution of the fps instruction being tested. If so report
; failure. otherwise go to the spurious trap to 4 handling.
aac20:
		mov	(SP), R2
		cmp	R2, #aac2+2
		beq	1$
		cmp	R2, #aac2+4
		beq	1$
		jmp	@#cpspur
1$:		cmp	(SP)+, (SP)+
		mov	R2, @#$tmp2
2$:		emt	+1			; odd adres
		br	aacdone			; but fdstx in st 771
aacdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 46 - source modes, mode 2 (fl=0), test
; This is a test of source mode 2
; using the ldfps instr.
;
tst46:		scope
bbc1:
		lperr				; set up the loop on error address.
		mov	#bbctp1, R0		; set up test data in buffer.
		mov	#145212, (R0)
		mov	#145212, @#$tmp3	; save data in case of error.
		mov	#bbc2, @#$tmp2
		mov	#bbc20, @#errvect	; set up for traps to 4.

bbc2:		ldfps	(R0)+			; test instruction.
		stfps	R5			; get fps
		cmp	R0, #bbctp1+2		; is R0 correct?
		bne	bbc10			; br if not.
		cmp	#145212, R5		; is the fps correct?
		bne	bbc11			; br if not.
		br	bbcdone

; test buffer and data:
		-1
bbctp1:		.word	-1
		-1

; report R0 incorrect.
bbc10:		mov	#bbctp1+2, @#$tmp3
		mov	R0, @#$tmp4
1$:		emt	+1			; R0 bad but fsrc failed
		br	bbcdone

; report fps incorrect.
bbc11:		mov	#145212, @#$tmp3	; report fps incorrect.
		mov	R5, @#$tmp4
1$:		emt	+1
		br	bbcdone

; trap here through vector four. see if the trap was during
; execution of the fps instruction being tested. If so report
; failure. otherwise go to the spurious trap to 4 handling.
bbc20:
		mov	(SP), R2
		cmp	R2, #bbc2+2
		beq	1$
		cmp	R2, #bbc2+4
		beq	1$
		jmp	@#cpspur
1$:		cmp	(SP)+, (SP)+
		mov	R2, @#$tmp2
2$:		emt	+1			; odd adres
						; but fdstx in st 771

bbcdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 47 - source modes, mode 4 (fl=0), test
; This is a test of source mode 4
; using the ldfps instr.
;
tst47:		scope
ddc1:
		lperr				; set up the loop on error address.
		mov	#ddctp1+2, R0		; set up the test data buffer.
		mov	#105252, -2(R0)
		mov	#105252, @#$tmp3	; save data in case of error.
		mov	#ddc2, @#$tmp2
		mov	#ddc20, @#errvec
ddc2:		ldfps	-(R0)
		stfps	R5
		cmp	R0, #ddctp1
		bne	ddc10
		cmp	#105252, R5
		bne	ddc11
		br	ddcdone
		-1, -1, -1, -1

ddctp1:		-1
		-1, -1, -1, -1

ddc10:		mov	#ddctp1, @#$tmp3
		mov	R0, @#$tmp4
1$:		emt	+1			; R0 bad but fsrc failed
		br	ddcdone

ddc11:		mov	#105252, @#$tmp3	; report fps incorrect.
		mov	R5, @#$tmp4
1$:		emt	+1
		br	ddcdone

ddc20:		mov	(SP), R2
		cmp	R2, #ddc2+2
		beq	1$
		cmp	R2, #ddc2+4
		beq	1$
		jmp	@#cpspur
1$:		cmp	(SP)+, (SP)+
		mov	R2, @#$tmp2
2$:		emt	+1			; odd adres
ddcdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 50 - source modes, mode 3 (fl=0), test
; This is a test of source mode 3
; using the ldfps instr.
;
tst50:		scope
eec1:
		lperr				; set up the loop on error address.
		mov	#eectp2, R0
		mov	#eectp1, (R0)
		mov	#103456, eectp1
		mov	#103456, @#$tmp3
		mov	#eec2, @#$tmp2
		mov	#eec20, @#errvect	; set up for traps to 4.

eec2:		ldfps	@(R0)+			; test instruction.
		stfps	R5			; get the fps.
		cmp	R0, #eectp2+2		; is R0 correct?
		bne	eec10			; br if not.
		cmp	#103456, R5		; is the fps correct?
		bne	eec11			; br if not.
		br	eecdone

; test buffer and data:
		-1, -1, -1, -1

eectp1:		-1
		-1, -1, -1
eectp2:		eectp1, -1, -1, -1, 

; report R0 incorrect.
eec10:		mov	#eectp2+2, @#$tmp3
		mov	R0, @#$tmp4
1$:		emt	+1			; R0 bad but fsrc failed
		br	eecdone

; report fps incorrect.
eec11:		mov	#103456, @#$tmp3	; report fps incorrect.
		mov	R5, @#$tmp4
1$:		emt	+1
		br	eecdone

; trap here through vector four. see if the trap was during
; execution of the fps instruction being tested. If so report
; failure. otherwise go to the spurious trap to 4 handling.
eec20:		mov	(SP), R2
		cmp	R2, #eec2+2
		beq	1$
		cmp	R2, #eec2+4
		beq	1$
		jmp	@#cpspur
1$:		cmp	(SP)+, (SP)+
		mov	R2, @#$tmp2
2$:		emt	+1			; odd adres
eecdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 51 - source modes, mode 5 (fl=0), test
; This is a test of source mode 5
; using the ldfps instr.
;
tst51:		scope
ffc1:
		lperr				; set up the loop on error address.
		mov	#ffctp2+2, R0		; set up the test data buffer.
		mov	#ffctp1, -2(R0)
		mov	#45412, @#ffctp1
		mov	#45412, @#$tmp3		; save data in case of error.
		mov	#ffc1, @#$tmp2
		mov	#ffc20, @#errvect	; set up for traps to 4.

ffc2:		ldfps	@-(R0)			; test instruction.
		stfps	R5			; get the fps.
		cmp	R0, #ffctp2		; is R0 correct?
		bne	ffc10			; br if not.
		cmp	#45412, R5		; is the fps correct?
		bne	ffc11			; br if not.
		br	ffcdone

; test buffer and data:
		-1
ffctp1:		-1
		-1, -1, -1
ffctp2:		ffctp1, -1, -1, -1

; report R0 incorrect.
ffc10:		mov	#ffctp2, @#$tmp3
		mov	R0, @#$tmp4
1$:		emt	+1			; R0 bad but fsrc failed
		br	ffcdone

; report fps incorrect.
ffc11:		mov	#45412, @#$tmp3		; report fps incorrect.
		mov	R5, @#$tmp4
1$:		emt	+1
		br	ffcdone

; trap here through vector four. see if the trap was during
; execution of the fps instruction being tested. If so report
; failure. otherwise go to the spurious trap to 4 handling.
ffc20:		mov	(SP), R2
		cmp	R2, #ffc2+2
		beq	1$
		cmp	R2, #ffc2+4
		beq	1$
		jmp	@#cpspur
1$:		cmp	(SP)+, (SP)+
		mov	R2, @#$tmp2
2$:		emt	+1			; odd adres
ffcdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 52 - source modes, mode 6 (fl=0), test
; This is a test of source mode 6
; using the ldfps instr.
;
tst52:		scope
ggc1:
		lperr				; set up the loop on error address.
		mov	#ggctp1-5201, R0	; set up the test data buffer.
		mov	#46543, @#ggctp1
		mov	#46543, @#$tmp3		; save data in case of error.
		mov	#ggc2, @#$tmp2
		clr	R1
		mov	#ggc20, @#errvect	; set up for traps to 4.

ggc2:		ldfps	5201(R0)		; test instruction.
		stfps	R4			; get the fps.
		tst	R1			; was PC correct after execution?
		bne	ggc25			; br if not.
		cmp	R0, #ggctp1-5201	; is R0 correct?
		bne	ggc10			; br if not.
		cmp	#46543, R4		; is the fps correct?
		bne	ggc11			; br if not.
		br	ggcdone

; test buffer and data:
		-1
ggctp1:		-1, -1, -1, -1
		-1

; report R0 incorrect.
ggc10:		mov	#ggctp1-5201, @#$tmp3
		mov	R0, @#$tmp4
1$:		emt	+1			; R0 bad but fsrc failed
		br	ggcdone

; report fps incorrect.
ggc11:		mov	#46543, @#$tmp3		; report fps incorrect.
		mov	R4, @#$tmp4
1$:		emt	+1
		br	ggcdone

; report PC incorrect after instruction.
ggc25:		mov	#ggc2+4, @#$tmp3
		mov	#ggc2+2, @#$tmp4
1$:		emt	+1			; PC x
		br	ggcdone

; trap here through vector four. see if the trap was during
; execution of the fps instruction being tested. If so report
; failure. otherwise go to the spurious trap to 4 handling.
ggc20:		mov	(SP), R2
		cmp	R2, #ggc2+2
		beq	1$
		cmp	R2, #ggc2+4
		beq	1$
		jmp	@#cpspur
1$:		cmp	(SP)+, (SP)+
		mov	R2, @#$tmp2
2$:		emt	+1			; odd adres
ggcdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 53 - source modes, mode 7 (fl=0), test
; This is a test of source mode 7
; using the ldfps instr.
;
tst53:		scope
hhc1:
		lperr				; set up the loop on error address.
		mov	#hhctp2-5201, R0	; set up the test data buffer.
		mov	#hhctp1, 5201(R0)
		mov	#4547, @#hhctp1
		mov	#4547, @#$tmp3		; save data in case of error.
		mov	#hhc2, @#$tmp2
		clr	R1
		mov	#hhc20, @#errvect	; set up for traps to 4.

hhc2:		ldfps	@5201(R0)		; test instruction.
		stfps	R4			; get the fps.
		tst	R1			; was PC correct after execution?
		bne	hhc25			; br if not.
		cmp	R0, #hhctp2-5201	; is R0 correct?
		bne	hhc10			; br if not.
		cmp	#4547, R4		; is the fps correct?
		bne	hhc11			; br if not.
		br	hhcdone

; test buffer and data:
		-1
hhctp1:		.word	-1, -1, -1, -1

hhctp2:		.word	-1, -1, -1, -1

; report R0 incorrect.
hhc10:		mov	#hhctp2-5201, @#$tmp3
		mov	R0, @#$tmp4
1$:		emt	+1			; R0 bad but fsrc fared
		br	hhcdone

; report fps incorrect.
hhc11:		mov	#4547, @#$tmp3		; report fps incorrect.
		mov	R4, @#$tmp4
1$:		emt	+1
		br	hhcdone

; report PC incorrect after instruction.
hhc25:		mov	#hhc2+4, @#$tmp3
		mov	#hhc2+2, @#$tmp4
1$:		emt	+1			; PC x
		br	hhcdone

; trap here through vector four. see if the trap was during
; execution of the fps instruction being tested. If so report
; failure. otherwise go to the spurious trap to 4 handling.
hhc20:		mov	(SP), R2
		cmp	R2, #hhc2+2
		beq	1$
		cmp	R2, #hhc2+4
		beq	1$
		jmp	@#cpspur
1$:		cmp	(SP)+, (SP)+
		mov	R2, @#$tmp2
2$:		emt	+1			; odd address
hhcdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 54 - source modes, mode 2 gr7 (fl=1), test
; This is a test of the ldcld with
; immediate addressing mode.
;
tst54:		scope
iic1:
		lperr				; set up the loop on error address.
		mov	#iic2, @#$tmp2		; save data in case of error.
		mov	#iic20, @#errvect	; set up for traps to 4.
		mov	#300, R0
		ldfps	R0
		clr	R1

iic2:		ldcld	(R7)+, ac0		; test instruction.
		5201
		5201
		5201
		5201
		cmp	R1, #3			; was PC correct after execution?
		beq	iicdone			; br if yes.

; report PC incorrect after instruction.
iic3:		mov	#iic2+4, R4
		sub	#3, R1
		asl	R1
		sub	R1, R4
		mov	R4, @#$tmp4
		mov	#iic2+4, @#$tmp3
1$:		emt	+1			; bad constant
		br	iicdone

; trap here through vector four. see if the trap was during
; execution of the fps instruction being tested. If so report
; failure. otherwise go to the spurious trap to 4 handling.
iic20:		mov	(SP), @#$tmp2
		cmp	(SP)+, (SP)+
1$:		emt	+1			; bad constant odd add

iicdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 55 - source modes, mode 2 (fl=1), test
; This is a test of the ldcld instr
; with mode 2.
;
tst55:		scope
tcc1:
		lperr				; set up the loop on error address.
		mov	tcc2, @#$tmp2		; save data in case of error.
		mov	#300, R0
		ldfps	R0
		mov	#tccbf0, R0		; set up the test data buffer.

tcc2:		ldcld	(R0)+, ac0		; test instruction.
		stfps	R4			; get the fps.
		mov	#tccbf1, R1		; get the result.
		mov	#200, R2

		ldfps	R2
		std	ac0, (R1)
		cmp	R0, #tccbf0+4		; is R0 correct?
		beq	tcc3
; report R0 incorrect.
		mov	R0, @#$tmp4
		mov	#tccbf0+4, @#$tmp3
1$:		emt	+1			; bad const
		br	tccdone

tcc3:		cmp	#300, R4		; is the fps correct?
		beq	tccdone

; report fps incorrect.
		mov	R4, @#$tmp4
		mov	#300, @#$tmp3
1$:		emt	+1			; fps x
		br	tccdone

; test buffer and data:
tccbf0:		.word	01234, 67076, 54321, 012345

tccbf1:		-1, -1, -1, -1
tccdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 56 - ldcif and ldclf test
; This is a test of the ldcif and
; the ldclf instructions.
;
tst56:		scope
; zero operand fl=0
kkc1:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcfsub		; go execute instruction.
1$:		.word	0, 0			; fsrc operand.
2$:		.word	0, 0			; expected result.
3$:		.word	-1, -1			; anticipated erroneous result.
4$:		0				; fps before execution.
		4				; fps after execution.

		-1				; anticipated erroneous fps.
5$:		emt	+1			; report result incorrect.
		br	6$
		emt	+1			; report fps incorrect.
6$:

; zero operand fl=0
kkc2:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcfsub		; go execute the instruction.
1$:		.word	0, -1			; fsrc operand.
2$:		.word	0, 0			; expected result.
3$:		4177, 177400			; anticipated erroneous result.
4$:		0				; fps before execution.
		4				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; (but fl) st
		br	6$			; 277 to 300
		emt	+1			; into 301
6$:

; zero operand fl=1
kkc3:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcfsub		; go execute the instruction.
1$:		.word	0, 0			; fsrc operand.
2$:		.word	0, 0			; expected result.
3$:		.word	-1, -1			; anticipated erroneous result.
4$:		100				; fps before execution.
		104				; fps after execution.
		4				; anticipated erroneous fps.
5$:		emt	+1			; report result incorrect.
		br	6$
		emt	+1			; fl was clr'ed
6$:

; operand positive fl=0
kkc4:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcfsub		; go execute the instruction.
1$:		.word	40000, 0		; fsrc operand.
2$:		.word	43600, 0		; expected result.
3$:		.word	47600, 0		; anticipated erroneous result.
4$:		17				; fps before execution.
		0				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; st 107 bad
		br	6$			; constant 231 insd
		emt	+1			; 215
6$:
; operand=1, fl=0
kkc5:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcfsub		; go execute the instruction.
1$:		.word	1, 0			; fsrc operand.
2$:		.word	40200, 0		; expected result.
3$:		.word	44200, 0		; anticipated erroneous result.
4$:		17				; fps before execution.
		0				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; report result incorrect.
		br	6$
		emt	+1			; report fps incorrect.
6$:

; operand=pattern fl=0
kkc6:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcfsub		; go execute the instruction.
1$:		.word	252, 0			; fsrc operand.
2$:		.word	42052, 0		; expected result.
3$:		.word	46052, 0		; anticipated erroneous result.
4$:		0				; fps before execution.
		0				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+0			; report result incorrect.
		br	6$
		emt	+1			; report fps incorrect.
6$:

; operand=-40000 fl=0
kkc7:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcfsub		; go execute the instruction.
1$:		.word	-40000, 0		; fsrc operand.
2$:		.word	143600, 0		; expected result.
3$:		.word	43600, 0		; anticipated erroneous result.
4$:		7				; fps before execution.
		10				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; (set sign) st 146
		br	6$
		emt	+1			; report fps incorrect.
6$:

; operand=-1 fl=0
kkc8:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcfsub		; go execute the instruction.
1$:		.word	-1, 0			; fsrc operand.
2$:		.word	140200, 0		; expected result.
3$:		.word	144000, 400		; anticipated erroneous result.
4$:		0				; fps before execution.
		10				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; st 372 to 152 into
		br	6$			; 112 (buf xnbt)
		emt	+1			; report fps incorrect.
6$:

; operand=pattern fl=0
kkc9:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcfsub		; go execute the instruction.
1$:		.word	125252, 0		; fsrc operand.
2$:		.word	143652, 126000		; expected result.
3$:		.word	43652, 126000		; anticipated erroneous result.
4$:		7				; fps before execution.
		10				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; report result incorrect.
		br	6$
		emt	+1			; report fps incorrect.
6$:

; operand pos fl=1
kxc10:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcfsub		; go execute the instruction.
1$:		.word	40000, 0		; fsrc operand.
2$:		.word	47600, 0		; expected result.
3$:		.word	43600, 0		; anticipated erroneous result.
4$:		117				; fps before execution.
		100				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; st 107 constant
		br	6$			; bad 237 inst 217
		emt	+1			; report fps incorrect.
6$:

; operand=1 fl=1
kkc11:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcfsub		; go execute the instruction.
1$:		.word	0, 1			; fsrc operand.
2$:		.word	40200, 0		; expected result.
3$:		.word	34200, 0		; anticipated erroneous result.
4$:		100				; fps before execution.
		100				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; report result incorrect.
		br	6$
		emt	+1			; report fps incorrect.
6$:

; operand=pattern fl=1
kkc12:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcfsub		; go execute the instruction.
1$:		.word	0, 252			; fsrc operand.
2$:		.word	42052, 0		; expected result.
3$:		.word	36052, 0		; anticipated erroneous result.
4$:		111				; fps before execution.
		100				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; report result incorrect.
		br	6$
		emt	+1			; report fps incorrect.
6$:

; operand=-40000, 0 fl=1
kkc13:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcfsub		; go execute the instruction.
1$:		.word	-40000, 0		; fsrc operand.
2$:		.word	147600, 0		; expected result.
3$:		.word	47600, 0		; anticipated erroneous result.
4$:		107				; fps before execution.
		110				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; set sign
		br	6$
		emt	+1			; report fps incorrect.
6$:

; operand=-1, -1 fl=1
kkc14:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcfsub		; go execute the instruction.
1$:		.word	-1, -1			; fsrc operand.
2$:		.word	140200, 0		; expected result.
3$:		.word	150000, 0		; anticipated erroneous result.
4$:		100				; fps before execution.
		110				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; (but xnbt)
		br	6$
		emt	+1			; report fps incorrect.
6$:

; operand=-pattern fl=1, round mode
kkc15:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcfsub		; go execute the instruction.
1$:		.word	125252, 125252		; fsrc operand.
2$:		.word	147652, 125253		; expected result.
3$:		.word	47652, 125253		; anticipated erroneous result.
4$:		105				; fps before execution.
		110				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; report result incorrect.
		br	6$
		emt	+1			; report fps incorrect.
6$:

; operand=77777, 177500 fl=1, round mode
kkc16:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcfsub		; go execute the instruction.
1$:		.word	77777, 177500		; fsrc operand.
2$:		.word	47777, 177777		; expected result.
3$:		.word	47777, 177776		; anticipated erroneous result.
4$:		117				; fps before execution.
		100				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; st 631 into rnd
		br	6$
		emt	+1			; report fps incorrect.
6$:

; operand=40000, 000100 fl=1, round mode
kkc17:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcfsub		; go execute the instruction.
1$:		.word	40000, 100		; fsrc operand.
2$:		.word	47600, 1		; expected result.
3$:		.word	47600, 0		; anticipated erroneous result.
4$:		102				; fps before execution.
		100				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; report result incorrect.
		br	6$
		emt	+1			; report fps incorrect.
6$:

; operand=40000, 000100 fl=1, trunc mode
kkc18:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcfsub		; go execute the instruction.
1$:		.word	40000, 100		; fsrc operand.
2$:		.word	47600, 0		; expected result.
3$:		.word	47600, 1		; anticipated erroneous result.
4$:		157				; fps before execution.
		140				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; st 631 ... into trnc
		br	6$
		emt	+1			; report fps incorrect.
6$:
; operand=100000, 0 (most neg #) fl=0
kkc19:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcfsub		; go execute the instruction.
1$:		.word	100000, 0		; fsrc operand.
2$:		.word	144000, 0		; expected result.
3$:		.word	143600, 0		; anticipated erroneous result.
4$:		7				; fp$ before execution.
		10				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; st 630 rh+r14+1
		br	6$
		emt	+1			; report fps incorrect.
6$:

; operand=100000, 0 fl=1
kkc20:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcfsub		; go execute the instruction.
1$:		.word	100000, 0		; fsrc operand.
2$:		.word	150000, 0		; expected result.
3$:		.word	147600, 0		; anticipated erroneous result.
4$:		107				; fps before execution.
		110				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; report result incorrect.
		br	6$
		emt	+1			; report fps incorrect.
6$:		br	kkcdone

; This subroutine, ldcfsub, is used to set up the operands, execute
; the ldcif or ldclf instruction and check the results. A call
; to it is made thus:
;
;		jsr	pc, @#ldcfsub
;	acarg:	.word	x, x			; ac operand
;	res:	.word	x, x			; expected result
;	erres:	.word	x, x			; error result
;	fpsb:	.word	x			; fps before execution
;	fpsa:	.word	x			; fps after execution
;	erfps:	.word	x			; error fps
;	err1:	error	1			; data error
;		br	cont
;	err2:	error	1			; fps error
;	cont:					; return address
;
; The operands are set up (using ac0 as the accumulator). Then
; the ldcif or ldclf instruction is executed.
; The result is checked against res. If the result is correct then the fps is
; compared with fpsa if this too is correct ldcfsub returns control
; to the calling routine at cont. If the fps is bad ldcfsub will
; compare it to error fps. If this matches then ldcfsub will return
; to the error call at err2, otherwise ldcfsub itself
; reports this failure and then returns to cont. If the result of the
; ldcif or ldclf is incorrect, the incorrect result is compared with the
; anticipated failing data pattern, erres. If the failure in
; the result was anticipated correctly to be erres then ldcfsub
; will transfer control to the error call at err1. Otherwise the
; result was incorrect but was not anticipated and ldcfsub
; report the failure after which control will be passed to cont.
;
ldcfsub:	mov	(SP)+, R1		; get a pointer to the arguments.
		mov	14(R1), R0		; set the fps.
		ldfps	R0
		mov	#1$, @#$tmp2
		mov	R1, R0
1$:		ldcif (R0), ac0			; test instruction ldcif or ldclf.
		stfps	R4			; get fps.
		mov	#ldct, R0		; get the result.
		mov	#200, R2
		ldfps	R2
		std	ac0, (R0)
		mov	#ldct, R2		; see if the result was correct.
		mov	R2, @#$tmp4
		mov	R1, @#$tmp3
		mov	R1, R3
		add	#4, R3
		mov	R3, @#$tmp5
		mov	R4, @#$tmp7
		mov	16(R1), @#$tmp10
		mov	R1, R0
		add	#4, R0
		mov	#2, R3
2$:		cmp	(R0)+, (R2)+
		bne	10$			; br if incorrect.
		sob	R3, 2$
		cmp	16(R1), R4		; see if the fps was correct.
		bne	15$			; br if incorrect.
3$:		jmp	30(R1)			; return.

; result in correct so see if the failure was anticipated.
10$:		mov	#ldct, R2
		mov	R1, R0
		add	#10, R0
		mov	#2, R3
11$:		cmp	(R0)+, (R2)+
		bne	13$
		sob	R3, 11$
		jmp	22(R1)

; the failure was not anticipated so report the error here.
13$:
14$:		emt	+1			; bad res
		br	3$

; the fps was incorrect so see if it was anticipated.
15$:		cmp	20(R1), R4
		bne	16$
		jmp	26(R1)

; fps error not anticipated so report it here.
16$:
17$:		emt	+1			; bad fps
		br	3$

; data buffer:
ldct:		.word	0, 0, 0, 0

kkcdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 57 - ldcid and ldcld test
; This is a test of ldcid and ldcld.
;
tst57:		scope
; operand=0 fl=0, fd=1
llc1:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcdsub		; go execute the instruction.
1$:		.word	0, 0			; fsrc operand.
2$:		.word	0, 0, 0, 0		; expected result.
3$:		.word	-1, -1, -1, -1		; anticipated erroneous result.
4$:		213				; fps before execution.
		204				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; report result incorrect.
		br	6$
		emt	+1			; report fps incorrect.
6$:

; operand=0 fl=0, fd=1
llc2:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcdsub		; go execute the instruction.
1$:		.word	0, -1			; fsrc operand.
2$:		.word	0, 0, 0, 0		; expected result.
3$:		.word	4177, 177400, 0, 0	; anticipated erroneous result.
4$:		200				; fps before execution.
		204				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; (but fl)s+277
		br	6$			; to 300 into 301
		emt	+1			; report fps incorrect.
6$:

; operand=0 fl=1 fd=1
llc3:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcdsub		; go execute the instruction.
1$:		.word	0, 0			; fsrc operand.
2$:		.word	0, 0, 0, 0		; expected result.
3$:		.word	-1, -1, -1, -1		; anticipated erroneous result.
4$:		211				; fps before execution.
		204				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; report result incorrect.
		br	6$
		emt	+1			; report fps incorrect.
6$:

; operand=40000 fl=0 fd=1
llc4:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcdsub		; go execute the instruction.
1$:		.word	40000, 0		; fsrc operand.
2$:		.word	43600, 0, 0, 0		; expected result.
3$:		.word	47600, 0, 0, 0		; anticipated erroneous result.
4$:		217				; fps before execution.
		200				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; st 107 bad const
		br	6$
		emt	+1			; report fps incorrect.
6$:

; operand=-40000 fl=0 fd=1
llc5:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcdsub		; go execute the instruction.
1$:		.word	-40000, 0		; fsrc operand.
2$:		.word	143600, 0, 0, 0		; expected result.

3$:		.word	43600, 0, 0, 0		; anticipated erroneous result.

4$:		200				; fps before execution.
		210				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; (set sign) st 176
		br	6$
		emt	+1			; report fps incorrect.
6$:

; operand=40000, 0 fl=1 fd=1
llc6:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcdsub		; go execute the instruction.
1$:		.word	40000, 0		; fsrc operand.
2$:		.word	47600, 0, 0, 0		; expected result.
3$:		.word	43600, 0, 0, 0		; anticipated erroneous result.
		317				; fps before execution.
		300				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; st 107 bad cons
		br	6$
		emt	+274			; report fps incorrect.
6$:

; operand=0, 1 fl=1 fd=1
llc7:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcdsub		; go execute the instruction.
1$:		.word	0, 1			; fsrc operand.
2$:		.word	40200, 0, 0, 0		; expected result.
3$:		.word	34200, 0, 0, 0		; anticipated erroneous result.
4$:		300				; fps before execution.
		300				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; report fps incorrect.
		br	6$
		emt	+1			; report fps incorrect.
6$:

; operand=77777, 177777 fl=1 fd=1
llc8:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldcdsub		; go execute the instruction.
1$:		.word	77777, 177777		; fsrc operand.
2$:		.word	47777, 177777, 177000, 0; expected result.
3$:		.word	-1, -1, -1, -1		; anticipated erroneous result.
4$:		317				; fps before execution.
		300				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; report result incorrect.
		br	6$
		emt	+1			; report fps incorrect.
6$:

; operand=-pattern fl=1 fd=1

llc9:
		lperr				; set up the loop on error address.
		jsr	pc, ldcdsub		; go execute the instruction.
1$:		.word	-1, -252		; fsrc operand.
2$:		.word	142052, 0, 0, 0		; expected result.
3$:		.word	136052, 0, 0, 0		; anticipated erroneous result.
4$:		307				; fps before execution.
		310				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; report result incorrect.
		br	6$
		emt	+1			; report fps incorrect.
6$:

; operand=pattern fl=1 fd=1 ft=1
llc10:
		lperr				; set up the loop on error address.
		jsr	pc, ldcdsub		; go execute the instruction.
1$:		.word	12345, 67012		; fsrc operand.
2$:		.word	47247, 025560, 050000, 0; expected result.
3$:		.word	-1, -1, -1, -1		; anticipated erroneous result.
4$:		352				; fps before execution.
		340				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; report result incorrect.
		br	6$
		emt	+1			; report fps incorrect.
6$:		br	llcdone

; This subroutine, ldcdsub, is used to set up the operands, execute
; the ldcid or ldcld instruction and check the results. A call
; to it is made thus:
;
;		jsr	pc, @#ldcdsub
;	acarg:	.word	x, x			; ac operand
;	res:	.word	x, x, x, x		; expected result
;	erres:	.word	x, x, x, x		; error result
;	fpsb:	.word	x			; fps before execution
;	fpsa:	.word	x			; fps after execution
;	erfps:	.word	x			; error fps.
;	err1:	error	1			; data error.
;		br	cont
;	err2:	error	1			; fps error.
;	cont:					; return address
;
; The operands are set up (using ac0 as the ac simulator). Then
; the ldcid or ldcld instruction is executed.
; the result is checked against res. If the result is correct then the fps is
; compared with fpsa if this too is correct ldcdsub returns control
; to the calling routine at cont. If the fps is bad ldcdsub
; compare it to error fps. If this matches then ldcdsub will return
; to the error call at err2, otherwise ldcdsub itself
; reports this failure and then returns to cont. If the result of the
; ldcid or ldcld is incorrect, the incorrect result is compared with the
; anticipated failing data pattern, erres. If the failure in
; the result was anticipated correctly to be erres then ldcdsub
; will transfer control to the error call at err1. Otherwise the
; result was incorrect but was not anticipated and ldcdsub will
; report the failure after which control will be passed to cont.
;
ldcdsub:	mov	(SP)+, R1		; get a pointer to the arguments.
		mov	24(R1), R0		; set the fps.
		ldfps	R0
		mov	#1$, @#$tmp2
		mov	R1, R0
1$:		ldcid	(R0), ac0		; test instruction, ldcid or ldcld.
		stfps	R4			; get fps.
		mov	#ldct, R0		; get the result.
		mov	#200, R2
		ldfps	R2
		std	ac0, (R0)

; see if the result is correct.
		mov	#ldct, R2
		mov	R2, @#$tmp4
		mov	R1, @#$tmp3
		mov	R1, R3
		add	#4, R3
		mov	R3, @#$tmp5
		mov	R4, @#$tmp7
		mov	26(R1), @#$tmp10
		mov	R1, R0
		add	#4, R0
		mov	#2, R3
2$:		cmp	(R0)+, (R2)+
		bne	10$			; br if incorrect.
		sob	R3, 2$
		cmp	26(R1), R4		; is the fps correct?
		bne	15$			; br if incorrect.
3$:		jmp	40(R1)			; return.

; the result was incorrect so see if the error was anticipated.
10$:		mov	#ldct, R2
		mov	R1, R0
		add	#14, R0
		mov	#2, R3
11$:		cmp	(R0)+, (R2)+
		bne	13$
		sob	R3, 11$
		jmp	32(R1)
13$:
; error not anticipated so report result incorrect here.
14$:		emt	+1			; bad res
		br	3$

; the fps was incorrect. see if failure was anticipated.
15$:		cmp	30(R1), R4
		bne	16$
		jmp	36(R1)

; fps error was not anticipated so report failure here.
16$:
17$:		emt	+1			; bad fps
		br	3$
llcdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 60 - ldexp test
; This is a test of the ldexp inst
; a subroutine is used to set up
; operands, execute the ldexp inst and
; check the results.
;
tst60:		scope
; non-zero res. valid expon=210 (excess 200)=10
mmc1:
		lperr				; set up the loop on error address.
		jsr	pc, ldxsub		; go execute the instruction.
1$:		.word	12345, 67012, 34567, 012345; ac0 operand.
2$:		.word	10			; exponent operand.
3$:		.word	42145, 67012, 34567, 012345; expected result.
4$:		.word	2145, 67012, 34567, 012345	; anticipated erroneous result.
5$:		47217				; fps before execution.
		47200				; fps after execution.
		147200				; anticipated erroneous fps.
		-1				; expected fec.
6$:		emt	+1			; e12+e12+200 bad
		br	7$			; st 624
7$:		emt	+1			; report fps incorrect.
						; st 625 into 304

; non-zero res neg.
mmc2:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldxsub		; expon=377
1$:		.word	123456, 70123, 45670, 123456	; ac0 operand.
2$:		.word	177			; exponent operand.
3$:		.word	177656, 70123, 45670, 123456	; expected result.
4$:		.word	137656, 70123, 45670, 123456	; anticipated erroneous result.

5$:		47207				; fps before execution.
		47210				; fps after execution.
		147210				; anticipated erroneous fps.
		-1				; expected fec.
6$:		emt	+1			; report result incorrect.
		br	7$
		emt	+1			; report fps incorrect.
7$:

; non-zero res. exp=256=(56)real
mmc3:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldxsub		; go execute the instruction.
1$:		.word	73261, 057645, 43323, 101760	; ac0 operand.
2$:		.word	56			; exponent operand.
3$:		.word	53461, 057645, 43323, 101760	; expected result.
4$:		.word	-1, -1, -1, -1		; anticipated frroneous result.
5$:		47200				; fps before execution.
		47200				; fps after execution.
		147200				; anticipated erroneous fps.
		-1				; expected fec.
6$:		emt	+1			; report result incorrect.
		br	7$
		emt	+1			; report fps incorrect.
7$:

; exp=27 (excess 200)=-151 (oct)
mmc4:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldxsub		; go execute the instruction.
1$:		.word	12223, 24252, 62720, 21222	; ac0 operand.
2$:		.word	-151			; exponent operand.
3$:		.word	5623, 24252, 62720, 21222	; expected result.
4$:		.word	-1, -1, -1, -1		; anticipated erroneous result.
5$:		47200				; fps before execution.
		47200				; fps after execution.
		147200				; anticipated erroneous fps.
		-1				; expected fec.
6$:		emt	+1			; report result incorrect.
		br	7$
		emt	+1			; (but ezbt) st 544 to 504 into 704 0 (but exbt) st 704 i
7$:

; exp=0 (excess 200)=-200 (oct), positive frac
; fiv=1
mmc5:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldxsub		; go execute the instruction.
1$:		.word	30131, 32334, 35363, 73031	; ac0 operand.
2$:		.word	-200			; exponent operand.
3$:		.word	00131, 32334, 35363, 73031	; expected result.
4$:		.word	0, 0, 0, 0		; anticipated erroneous result.
5$:		42200				; fps before execution.
		142204				; fps after execution.
		42202				; anticipated erroneous fps.
		12				; expected fec.
6$:		emt	+1			; (but exbt) st 704 to 64 inst 264
		br	7$
		emt	+1			; (but fiu) st 264 x
7$:

; exp=0 (excess 200)=-200 (oct), neg fract, fiu=1
mmc6:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldxsub		; go execute the instruction.
1$:		.word	140414, 24344, 45464, 74045; ac0 operand.
2$:		.word	-200			; exponent operand.
3$:		.word	100014, 24344, 45464, 74045; expected result.
4$:		.word	0, 0, 0, 0		; anticipated erroneous result.
5$:		42200				; fps before execution.
		142214				; fps after execution.
		42214				; anticipated erroneous fps.
		12				; expected fec.
6$:		emt	+1			; report result incorrect.
		br	7$
		emt	+1			; report fps incorrect.
7$:

; exp=0 (excess 200)=-200 (oct), pos frac, fiu=0
mmc7:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldxsub		; go execute the instruction.
1$:		.word	51525, 35455, 5675, 05152	; ac0 operand.
2$:		.word	-200			; exponent operand.
3$:		.word	0, 0, 0, 0		; expected result.
4$:		.word	00125, 35455, 5675, 05152	; anticipated erroneous result.
		45200				; fps before execution.
		45204				; fps after execution.
		145204				; anticipated erroneous fps.
		-1				; expected fec.
6$:		emt	+1			; (but fiu) st 264 x
						; report result incorrect
		br	7$
		emt	+1			; report fps incorrect.
7$:

; exp=-1405 (excess 200)=-1605 (oct), fiu=1
mmc8:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldxsub		; go execute the instruction.
1$:		.word	61626, 62636, 46566, 67606	; ac0 operand.
2$:		.word	-1605			; exponent operand.
3$:		.word	76626, 62636, 46566, 67606	; expected result.
4$:		.word	0, 0, 0, 0		; anticipated erroneous result.

5$:		42200				; fps before execution.
		142200				; fps after execution.
		42204				; anticipated erroneous fps.
		12				; expected fec.
6$:		emt	+1			; (but ezbt) st 544 to 704 into 504
		br	7$
		emt	+1			; report fps incorrect.
7$:

; exp=-17416 (excess 200)=-17616 (oct), fiu=0
mmc9:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldxsub		; go execute the instruction.
1$:		.word	71727, 37475, 76777, 17273	; ac0 operand.
2$:		.word	-17616			; exponent operand.
3$:		.word	0, 0, 0, 0		; expected result.
4$:		.word	74527, 37475, 76777, 17273	; anticipated erroneous result.
5$:		45200				; fps before execution.
		45204				; fps after execution.
		145200				; anticipated erroneous fps.
		-1				; expected fec.
6$:		emt	+1			; (but fiu) st 504
		br	7$
		emt	+1			; report fps incorrect.
7$:

; exp=-1601 (excess 200)=-2001 (oct), fiu=1
mmc10:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldxsub		; go execute the instruction.
1$:		.word	01020, 30405, 06070, 00102	; ac0 operand.
2$:		.word	-2001			; exponent operand.
3$:		.word	37620, 30405, 06070, 00102	; expected result.
4$:		.word	0, 0, 0, 0		; anticipated erroneous result.
5$:		42200				; fps before execution.
		142200				; fps after execution.
		42204				; anticipated erroneous fps.
		12				; expected fec.
6$:		emt	+1			; (but fiu) st 504
		br	7$
		emt	+1			; report fps incorrect.
7$:

; exp=1206 (excess 200)=1006 (oct) fiv=1
mmc11:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldxsub		; go execute the instruction.
1$:		.word	12131, 14151, 16171, 10111	; ac0 operand.
2$:		.word	1006			; exponent operand.
3$:		.word	41531, 14151, 16171, 10111	; expected result.
4$:		.word	0, 0, 0, 0		; anticipated erroneous result.
5$:		41200				; fps before execution.
		141202				; fps after execution.
		41204				; anticipated erroneous fps.
		10				; expected fec.
6$:		emt	+1			; (but fiv) st 104
		br	7$
		emt	+1			; report fps incorrect.
7$:

; exp=16315 (excess 200)=16115 (oct) fiv=0
mmc12:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldxsub		; go execute the instruction.
1$:		.word	27262, 25242, 23222, 21202	; ac0 operand.
2$:		.word	16115			; exponent operand.
3$:		.word	0, 0, 0, 0		; expected result.
4$:		.word	63262, 25242, 23222, 21202	; anticipated erroneous result.
5$:		46200				; fps before execution.
		46206				; fps after execution.
		146202				; anticipated erroneous fps.
		-1				; expected fec.
6$:		emt	+1			; (but fiv) st 104
		br	7$
		emt	+1			; report fps incorrect.
7$:

; exp=11011 (excess 200)=10611 (oct) fiv=1
mmc13:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldxsub		; go execute the instruction.
1$:		.word	30313, 32333, 34353, 36373	; ac0 operand.
2$:		.word	10611			; exponent operand.
3$:		.word	2313, 32333, 34353, 36373	; expected result.
4$:		.word	0, 0, 0, 0		; anticipated erroneous result.
5$:		41200				; fps before execution.
		141202				; fps after execution.
		41204				; anticipated erroneous fps.
		10				; expected fec.
6$:		emt	+1			; (but fiv) st 144
		br	7$
		emt	+1			; report fps incorrect.
7$:

; exp=17123 (excess 200)=16723 (oct) fiv=0
mmc14:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldxsub		; go execute the instruction.
1$:		.word	40414, 42434, 44454, 46474	; ac0 operand.
2$:		.word	16723			; exponent operand.
3$:		.word	0, 0, 0, 0		; expected result.
4$:		.word	24614, 42434, 44454, 46474	; anticipated erroneous result.
5$:		46200				; fps before execution.
		46206				; fps after execution.
		146202				; anticipated erroneous fps.
		-1				; expected fec.
6$:		emt	+1			; (but fiv) st 144
		br	7$
		emt	+1			; report fps incorrect.
7$:

; exp=254 (oct)=454 (excess 200) fiv=1
mmc15:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldxsub		; go execute the instruction.
1$:		.word	50515, 52535, 54555, 56575	; ac0 operand.
2$:		.word	254			; exponent operand.
3$:		.word	13115, 52535, 54555, 56575	; expected result.
4$:		.word	0, 0, 0, 0		; anticipated erroneous result.
5$:		41200				; fps before execution.
		141202				; fps after execution.
		41204				; anticipated erroneous fps.
		10				; expected fec.
6$:		emt	+1			; (but fiv) st344
		br	7$
		emt	+1			; report fps incorrect.
7$:

; exp=313 (oct)=513 (excess 200) fiv=0
mmc16:
		lperr				; set up the loop on error address.
		jsr	pc, @#ldxsub		; go execute the instruction.
1$:		.word	60616, 62636, 64656, 66676	; ac0 operand.
2$:		.word	313			; exponent operand.
3$:		.word	0, 0, 0, 0		; expected result.
4$:		.word	22616, 62636, 64656, 66676	; anticipated erroneous result.
5$:		46200				; fps before execution.
		46206				; fps after execution.
		146202				; anticipated erroneous fps.
		-1				; expected fec.
6$:		emt	+1			; (but fiv) st 344
		br	7$
		emt	+1			; report fps incorrect.
7$:
		br	mmcdone

; This subroutine, ldxsub, is used to set up the operands, execute
; the ldexp instruction and check the results. A call
; to it is made thus:
;
;		jsr	pc, @#ldxsub
;	acarg:	.word	x, x, x, x		; ac operand
;	exp:	.word	x			; exponent
;	res:	.word	x, x, x, x		; expected result
;	erres:	.word	x, x, x, x		; error result
;	fpsb:	.word	x			; fps before execution
;	fpsa:	.word	x			; fps after execution
;	erfps:	.word	x			; error fps.
;	fec:	.word	x			; expected fec
;	err1:	error	1			; data error.
;		br	cont
;	err2:	error	1			; fps error.
;	cont:					; return address
;
; The operands are set up (using ac0 as the accumulator). Then
; the ldexp instruction is executed.
; the result is checked against res. If the result is correct then the fps is
; compared with fpsa if this too is correct ldxsub returns control
; to the calling routine at cont. If the fps is bad ldxsub
; compare it to error fps. If this matches then ldxsub will return
; to the error call at err2, otherwise ldxsub itself
; reports this failure and then returns to cont. If the result of the
; ldexp is incorrect, the incorrect result is compared with the
; anticipated failing data pattern. erres. If the failure in
; the result was anticipated correctly to be erres then ldxsub
; will transfer control to the error call at err1. Otherwise the
; result was incorrect but was not anticipated and ldxsub will
; report the failure after which control will be passed to cont.
;
ldxsub:		mov	(SP)+, R1		; get a pointer to the arguments.
		mov	#200, R0		; load the ac0 operand.
		ldfps	R0
		mov	R1, R0
		ldd	(R0), ac0
		mov	#1$, @#$tmp2
		mov	32(R1), R0		; set up the fps.
		ldfps	R0
		mov	R1, R0
		add	#10, R0
1$:		ldexp	(R0), ac0		; test instruction.
		stfps	R4			; get the fps.
		stst	R5			; get the fec.
		mov	#200, R0		; get the result.
		ldfps	R0
		mov	#ldxt, R0
		std	ac0, (R0)
		mov	R4, @#$tmp7
		mov	34(R1), @#$tmp10
		mov	R5, @#$tmp11
		mov	40(R1), @#$tmp12
		mov	R1, R2
		mov	R2, @#$tmp3
		add	#10, R2
		mov	(R2), @#$tmp4
		add	#2, R2
		mov	R2, @#$tmp5
		mov	#ldxt, @#$tmp6
		mov	#ldxt, R2		; see if the result was correct.
		mov	R1, R3
		add	#12, R3
		mov	#4, R0
2$:		cmp	(R2)+, (R3)+
		bne	10$			; branch if not correct.
		sob	R0, 2$
		cmp	R4, 34(R1)		; see if the fps was correct.
		bne	15$			; branch if not correct.
		tst	34(R1)
		bpl	3$
		cmp	R5, 40(R1)		; see if the fec was correct.
		bne	20$			; branch if not correct.
3$:		jmp	50(R1)			; return.

; the result was incorrect so see if the failure was anticipated.
10$:		mov	#ldxt, R2
		mov	R1, R3
		add	#22, R3
		mov	#4, R0
11$:		cmp	(R2)+, (R3)+
		bne	12$
		sob	R0, 11$
		jmp	42(R1)

; the error was not anticipated so report it here.
12$:
13$:		emt	+1			; bad res
		br	3$

; see if the fps error was anticipated.
15$:		cmp	36(R1), R4
		bne	16$
		jmp	46(R1)
16$:
; the fps was not anticipated so report it here.
17$:		emt	+1			; bad fps
		br	3$			; but ezbty8
						; st 063
20$:

; report fec incorrect.
21$:		emt	+1			; bad fec
		br	3$

; data buffer:
ldxt:		.word	0, 0, 0, 0
mmcdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 61 - destination modes, mode 1 (fl=0), test
; This is a test of destination mode 1 using
; the stfps instruction.
;
tst61:		scope
nnc1:
		lperr				; set up the loop on error address.
		mov	#nnctb0, R0		; set up the data buffer.
		mov	#6, R1
1$:		mov	#-1, (R0)+
		sob	R1, 1$
		mov	#102345, R0
		mov	#nnc2, @#$tmp2
		mov	#nnc25, @#errvect	; set up for traps to 4.
		ldfps	R0			; set up fps.
		mov	#nnctb1, R0

nnc2:		stfps	(R0)			; test instruction.
		cmp	R0, #nnctb1		; is R0 correct?
		bne	nnc10			; branch if not correct.
		cmp	@#nnctb1, #102345	; is result correct?
		bne	nnc15			; branch if not correct.
		cmp	@#nnctb1+2, #-1		; is the result correct?
		bne	nnc20			; branch if not correct.
		br	nncdone

; test data buffer:
nnctb0:		.word	-1, -1
nnctb1:		.word	-1, -1, -1, -1

; report R0 incorrect.
nnc10:		mov	R0, @#$tmp4
		mov	#nnctb1, @#$tmp3
1$:		emt	+1			; R0 bad (but
		br	nncdone			; fdst)x

; report result incorrect.
nnc15:		mov	#102345, @#$tmp3	; st 634
		mov	@#nnctb1, @#$tmp4
1$:		emt	+1			; bad data
		br	nncdone

; report result incorrect.
nnc20:		mov	#-1, @#$tmp3
		mov	@#nnctb1+2, @#$tmp4
1$:		emt	+1			; (but gr7, fl)
		br	nncdone			; st 357 to 416
						; into 417

; if a trap to vector 4 occurs come here to see if the trap occurred
; during execution of the FPP instruction being tested, if not go
; to the spurious trap to 4 handler.
nnc25:		mov	(SP), R4
		cmp	R4, #nnc2+2
		beq	1$
		jmp	@#cpspur
1$:		mov	(SP), @#$tmp2
		cmp	(SP)+, (SP)+
2$:		emt	+1			; (but fdst)+ st634
nncdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 62 - destination modes, mode 2 (fl=0), test
; This is a test of destination mode 2 using
; the stfps instruction.
;
tst62:		scope
ooc1:
		lperr				; set up the loop on error address.
		mov	#ooctb0, R0		; set up the data buffer.
		mov	#6, R1
1$:		mov	#-1, (R0)+
		sob	R1, 1$
		mov	#105412, R0
		mov	#ooc2, @#$tmp2
		mov	#ooc25, @#errvect	; set up for traps to vector 4.
		ldfps	R0			; set up fps.
		mov	#ooctb1, R0

ooc2:		stfps	(R0)+			; test instruction.
		cmp	R0, #ooctb1+2		; is R0 correct?
		bne	ooc10			; branch if not correct.
		cmp	@#ooctb1, #105412	; is the result correct?
		bne	ooc15			; branch if not correct.
		cmp	@#ooctb1+2, #-1		; is the result correct?
		bne	ooc20			; branch if not correct.
		br	oocdone

; test data buffer:
ooctb0:		.word	-1, -1
ooctb1:		.word	-1, -1, -1, -1

; report R0 incorrect.
ooc10:		mov	R0, @#$tmp4
		mov	#ooctb1+2, @#$tmp3
1$:		emt	+1			; R0 bad (but
		br	oocdone			; fdst)x

; report result incorrect.
ooc15:		mov	#105412, @#$tmp3	; st 634
		mov	@#ooctb1, @#$tmp4
1$:		emt	+1			; bad data
		br	oocdone

; report result incorrect.
ooc20:		mov	#-1, @#$tmp3
		mov	@#ooctb1+2, @#$tmp4
1$:		emt	+1			; (but gr7, fl)
		br	oocdone			; st 357 to 416
						; into 417

; if a trap to vector 4 occurs come here to see if the trap occurred
; during execution of the FPP instruction being tested, if not go
; to the spurious trap to 4 handler.
ooc25:		mov	(SP), R4
		cmp	R4, #ooc2+2
		beq	1$
		jmp	@#cpspur

1$:		mov	(SP), @#$tmp2
		cmp	(SP)+, (SP)+
2$:		emt	+1			; (but fdst)+ st634
oocdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 63 - destination modes, mode 4 (fl=0), test
; This is a test of destination mode 4 using
; the stfps instruction.
;
tst63:		scope
ppc1:
		lperr				; set up the loop on error address.
		mov	#ppctb0, R0		; set up the data buffer.
		mov	#6, R1
1$:		mov	#-1, (R0)+
		sob	R1, 1$
		mov	#105555, R0
		mov	#ppc2, @#$tmp2
		mov	#ppc25, @#errvect	; set up for traps to vector 4.
		ldfps	R0			; set up fps.
		mov	#ppctb1+2, R0
ppc2:		stfps	-(R0)			; test instruction.
		cmp	R0, #ppctb1		; is R0 correct?
		bne	ppc10			; branch if not correct.
		cmp	@#ppctb1, #105555	; is the result correct?
		bne	ppc15			; branch if not correct.
		cmp	@#ppctb1+2, #-1		; is the result correct?
		bne	ppc20			; branch if not correct.
		br	ppcdone

; test data buffer:
ppctb0:		.word	-1, -1
ppctb1:		.word	-1, -1, -1, -1

; report R0 incorrect.
ppc10:		mov	R0, @#$tmp4
		mov	#ppctb1, @#$tmp3
1$:		emt	+1			; R0 bad (but
		br	ppcdone			; fdst)x

; report result incorrect.
ppc15:		mov	#105555, @#$tmp3	; st 634
		mov	@#ppctb1, @#$tmp4
1$:		emt	+1			; bad data
		br	ppcdone

; report result incorrect.
ppc20:		mov	#-1, @#$tmp3
		mov	@#ppctb1+2, @#$tmp4
1$:		emt	+1			; (but gr7, fl)
		br	ppcdone			; st 357 to 416
						; into 417

; if a trap to vector 4 occurs come here to see if the trap occurred
; during execution of the FPP instruction being tested, if not go
; to the spurious trap to 4 handler.
ppc25:		mov	(SP), R4
		cmp	R4, #ppc2+2
		beq	1$
		jmp	@#cpspur
1$:		mov	(SP), @#$tmp2
		cmp	(SP)+, (SP)+
2$:		emt	+1			; (but fdst)+ st634
ppcdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 64 - destination modes, mode 3 (fl=0), test
; This is a test of destination mode 3 using
; the stfps instruction.
;
tst64:		scope
qqc1:
		lperr				; set up the loop on error address.
		mov	#qqctb0, R0		; set up the data buffer.
		mov	#10, R1
1$:		mov	#-1, (R0)+
		sob	R1, 1$
		mov	#106653, R0
		mov	#qqc2, @#$tmp2
		mov	#qqc25, @#errvect	; set if for traps to vector 4.
		ldfps	R0			; set up fps.
		mov	#qqctb2, R0
		mov	#qqctb1, (R0)

qqc2:		stfps	@(R0)+			; test instruction.
		cmp	R0, #qqctb2+2		; is R0 correct?
		bne	qqc10			; branch if not correct.
		cmp	@#qqctb1, #106653	; is the result correct?
		bne	qqc15			; branch if not correct.
		cmp	@#qqctb2, #qqctb1	; is the result correct?
		bne	qqc20			; branch if not correct.
		br	qqcdone

; test data buffer:
qqctb0:		.word	-1, -1
qqctb1:		.word	-1, -1, -1, -1
qqctb2:		.word	-1, -1

; report R0 incorrect.
qqc10:		mov	R0, @#$tmp4
		mov	#qqctb2+2, @#$tmp3
1$:		emt	+1			; R0 bad (but
		br	qqcdone			; fdst)x

; report result incorrect.
qqc15:		mov	#106653, @#$tmp3	; st 654
		mov	@#qqctb1, @#$tmp4
1$:		emt	+1			; bad data
		br	qqcdone

; report result incorrect.
qqc20:		mov	#qqctb2, @#$tmp3	; (but fdst)
		mov	@#qqctb1+2, @#$tmp4
1$:		emt	+1
		br	qqcdone

; if a trap to vector 4 occurs come here to see if the trap occurred
; during execution of the FPP instruction being tested, if not go
; to the spurious trap to 4 handler.
qqc25:		mov	(SP), R4
		cmp	R4, #qqc2+2
		beq	1$
		jmp	@#cpspur
1$:		mov	(SP), @#$tmp2
		cmp	(SP)+, (SP)+
2$:		emt	+1			; (but fdst)+ st654
qqcdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 65 - destination modes, mode 5 (fl=0), test
; This is a test of destination mode 5 using
; the stfps instruction.
;
tst65:		scope
rrc1:
		lperr				; set up the loop on error address.
		mov	#rrctb0, R0		; set up the data buffer.
		mov	#6, R1
1$:		mov	#-1, (R0)+
		sob	R1, 1$
		mov	#004301, R0
		mov	#rrc2, @#$tmp2
		mov	#rrc25, @#errvect	; set up for traps to vector 4.
		ldfps	R0			; set up fps.
		mov	#rrctb2+2, R0
		mov	#rrctb1, -2(R0)

rrc2:		stfps	@-(R0)			; test instruction.
		cmp	R0, #rrctb2		; is R0 correct?
		bne	rrc10			; branch if not correct.
		cmp	@#rrctb1, #004301	; is the result correct?
		bne	rrc15			; branch if not correct.
		cmp	@#rrctb2, #rrctb1	; is the result correct?
		bne	rrc20			; branch if not correct.
		br	rrcdone

; test data buffer:
rrctb0:		.word	-1, -1
rrctb1:		.word	-1, -1, -1, -1
rrctb2:		.word	-1, -1

; report R0 incorrect.
rrc10:		mov	R0, @#$tmp4
		mov	#rrctb2, @#$tmp3
1$:		emt	+1			; R0 bad (but
		br	rrcdone			; fdst)x

; report result incorrect.
rrc15:		mov	#004301, @#$tmp3	; st 634
		mov	@#rrctb1, @#$tmp4
1$:		emt	+1			; bad data
		br	rrcdone

; report result incorrect.
rrc20:		mov	#rrctb2, @#$tmp3	; but fdst)
		mov	@#rrctb1+2, @#$tmp4
1$:		emt	+1			; (but gr7, fl)
		br	rrcdone			; st 357 to 416
						; into 417

; if a trap to vector 4 occurs come here to see if the trap occurred
; during execution of the FPP instruction being tested, if not go
; to the spurious trap to 4 handler.
rrc25:		mov	(SP), R4
		cmp	R4, #rrc2+2
		beq	1$
		jmp	@#cpspur
1$:		mov	(SP), @#$tmp2
		cmp	(SP)+, (SP)+
2$:		emt	+1			; (but fdst)+ st634
rrcdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 66 - destination modes, mode 6 (fl=0), test
; This is a test of destination mode 6 using
; the stfps instruction.
;
tst66:		scope
ssc1:
		lperr				; set up the loop on error address.
		mov	#ssctb0, R0		; set up the data buffer.
		mov	#6, R1
1$:		mov	#-1, (R0)+
		sob	R1, 1$
		mov	#102514, R0
		mov	#ssc2, @#$tmp2
		mov	#ssc25, @#errvect	; set up for traps to vector 4.
		ldfps	R0			; set up fps.
		clr	R1
		mov	#ssctb1-5201, R0

ssc2:		stfps	5201(R0)		; test instruction.
		cmp	R1, #0			; was PC correct after execution?
		bne	ssc30			; branch if not correct.
		cmp	R0, #ssctb1-5201	; is R0 correct?
		bne	ssc10			; branch if not correct.
		cmp	@#ssctb1, #102514	; is the result correct?
		bne	ssc15			; branch if not correct.
		cmp	@#ssctb1+2, #-1		; is the result correct?
		bne	ssc20			; branch if not correct.
		br	sscdone

; test data buffer:
ssctb0:		.word	-1, -1
ssctb1:		.word	-1, -1, -1, -1

; report R0 incorrect.
ssc10:		mov	R0, @#$tmp4
		mov	#ssctb1-5201, @#$tmp3
1$:		emt	+1			; R0 bad
		br	sscdone

; report result incorrect.
ssc15:		mov	#102534, @#$tmp3
		mov	@#ssctb1, @#$tmp4
1$:		emt	+1			; bad data
		br	sscdone

; report result incorrect.
ssc20:		mov	#-1, @#$tmp3
		mov	@#ssctb1+2, @#$tmp4
1$:		emt	+1			; (but gr7, fl)
		br	sscdone			; st 357 to 416
						; into 417

; if a trap to vector 4 occurs come here to see if the trap occurred
; during execution of the fpj instruction being tested, if not go
; to the spurious trap to 4 handler.
ssc25:		mov	(SP), R4
		cmp	R4, #ssc2+2
		beq	1$
		jmp	@#cpspur
1$:		mov	(SP), @#$tmp2
		cmp	(SP)+, (SP)+
2$:		emt	+1			; (but fdst)+ st634
		br	sscdone

; report PC not incremented by 2 during execution.
ssc30:
1$:		emt	+1			; PC not
						; incremented
						; by 2
sscdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 67 - destination modes, mode 7 (fl=0), test
; This is a test of destination mode 7 using
; the stfps instruction.
;
tst67:		scope
ttc1:
		lperr				; set up the loop on error address.
		mov	#ttctb0, R0		; set up the data buffer.
		mov	#10, R1
1$:		mov	#-1, (R0)+
		sob	R1, 1$
		mov	#103747, R0
		mov	#ttc2, @#$tmp2
		mov	#ttc25, @#errvect	; set up for traps to vector 4.
		ldfps	R0			; set up fps.
		clr	R1
		mov	#ttctb2-5201, R0
		mov	#ttctb1, 5201(R0)

ttc2:		stfps	@5201(R0)		; test instruction.
		cmp	#0, R1			; was PC correct after execution?
		bne	ttc30			; branch if not correct.
		cmp	R0, #ttctb2-5201	; is R0 correct?
		bne	ttc10			; branch if not correct.
		cmp	@#ttctb1, #103747	; is the result correct?
		bne	ttc15			; branch if not correct.
		cmp	@#ttctb1+2, #-1		; is the result correct?
		bne	ttc20			; branch if not correct.
		br	ttcdone

; test data buffer:
ttctb0:		.word	-1, -1
ttctb1:		.word	-1, -1, -1, -1
ttctb2:		.word	-1, -1

; report R0 incorrect.
ttc10:		mov	R0, @#$tmp4
		mov	#ttctb2-5201, @#$tmp3
1$:		emt	+1			; R0 bad
		br	ttcdone

; report result incorrect.
ttc15:		mov	#103747, @#$tmp3
		mov	@#ttctb1, @#$tmp4
1$:		emt	+1			; bad data
		br	ttcdone

; report result incorrect.
ttc20:		mov	#-1, @#$tmp3
		mov	@#ttctb1+2, @#$tmp4
1$:		emt	+1			; (but gr7, fl)
		br	ttcdone			; st 357 to 416
						; into 417

; if a trap to vector 4 occurs come here to see if the trap occurred
; during execution of the FPP instruction being tested, if not go
; to the spurious trap to 4 handler.
ttc25:		mov	(SP), R4
		cmp	R4, #ttc2+2
		beq	1$
		jmp	@#cpspur
1$:		mov	(SP), @#$tmp2
		cmp	(SP)+, (SP)+
2$:		emt	+1			; (but fsdt)+ st634
		br	ttcdone

; report PC not incremented by 2 during execution.
ttc30:
1$:		emt	+1			; PC not
						; incremented
ttcdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 70 - destination modes, mode 2 (fl=1), test
; This is a test of destination mode
; using stcol with register 0.
;
tst70:		scope
uuc1:
		lperr				; set up the loop on error address.
		mov	#300, R0		; set up fps.
		ldfps	R0
		mov	#uuctp1, R0		; set up the ac0 operand.
		ldd	(R0), ac0
		mov	#uuc2, @#$tmp2
		mov	#uucbf0, R0

uuc2:		stcdl	ac0, (R0)+		; test instruction.
		cmp	R0, #uucbf0+4		; is R0 correct?
		beq	uucdone			; branch if correct.

; report R0 incorrect.
uuc3:		mov	R0, @#$tmp4
		mov	#uucbf0+4, @#$tmp3
1$:		emt	+1			; R0 not incr by 4
		br	uucdone

; test data buffer.
uuctp1:		.word	0, 0, 0, 0
		-1
uucbf0:		.word	-1, -1, -1
uucdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 71 - destination modes, mode 4 (fl=1), test
; This is a test of destination mode
; 4 using stcdl with register 0.
;
tst71:		scope
vvc1:
		lperr				; set up the loop on error address.
		mov	#300, R0		; set up fps.
		ldfps	R0
		mov	#vvctp1, R0		; set up the ac0 operand.
		ldd	(R0), ac0
		mov	#vvc2, @#$tmp2
		mov	#vvcbf0+4, R0

vvc2:		stcdl	ac0, -(R0)		; test instruction.

		cmp	R0, #vvcbf0		; is R0 correct?
		beq	vvcdone

; report R0 incorrect.
vvc3:		mov	R0, @#$tmp4
		mov	#vvcbf0, @#$tmp3
1$:		emt	+1			; R0 not decr by 4
		br	vvcdone

; test data buffer:
vvctp1:		.word	0, 0, 0, 0

		-1
vvcbf0:		.word	-1, -1, -1

vvcdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 72 - stcdi and stcdl test
; This is a test of the stcdi and
; stcdl instructions. Note that a
; subroutine, stcsub, is used to
; set up the operands. Execute the stc
; instruction and check the result.
;
tst72:		scope
; first test stc with exp=100 (excess 200)
wwc1:
		lperr				; set up the loop on error address.
		jsr	pc, @#stcsub		; go execute the instruction.
1$:		.word	20000, 0, 0, 0		; ac0 operand.
2$:		.word	0, 0			; expected result.
3$:		.word	-1, -1			; error res.
4$:		40300				; fps before execution.
		40304				; fps after execution.
		140304				; anticipated erroneous fps.
		-1				; report result incorrect.
5$:		emt	+1			; result incorp.
		br	6$
		emt	+1			; either (but flag)
6$:						; st 662
						; or clear flag
						; st 774

; exp=0 (oct) fl=1 fic=0
wwc2:
		lperr				; set up the loop on error address.
		jsr	pc, @#stcsub		; go execute the instruction.
1$:		.word	40000, 0, 0, 0		; ac
						; ac0 operand.
2$:		.word	0, 0			; expected result.
3$:		.word	-1, -1			; anticipated erroneous result.
4$:		40313				; fps before execution.
		40304				; fps after execution.
		140304				; anticipated erroneous fps.
		-1				; expected fec.
5$:		emt	+1			; report result incorrect.
		br	6$
		emt	+1			; report fps incorrect.
6$:

; exp=37 (oct) fl=1 fic=1
wwc4:
		lperr				; set up the loop on error address.
		jsr	pc, @#stcsub		; go execute the instruction.
1$:		.word	47667, 75757, 157737, 167773	; ac0 operand.
2$:		.word	55675, 173757		; expected result.
3$:		.word	122102, 004021		; anticipated erroneous result.
4$:		40717				; fps before execution.
		40700				; fps after execution.
		140705				; anticipated erroneous fps.
		-1				; expected fec.
5$:		emt	+1			; (but enbt) st 632
		br	6$
		emt	+1			; report fps incorrect.
6$:

; exp=40 (oct) fl=1 fic=1
wwc5:
		lperr				; set up the loop on error address.
		jsr	pc, @#stcsub		; go execute the instruction.
1$:		.word	50000, 0, 0, 0		; ac0 operand.
2$:		.word	0, 0			; expected result.
3$:		.word	-1, -1			; anticipated erroneous result.
4$:		40700				; fps before execution.
		140705				; fps after execution.
		40705				; anticipated erroneous fps.
		6				; expected fec.
5$:		emt	+1			; report result incorrect.
		br	6$
		emt	+1			; (but fic) st 004
						; report fps incorrect.
						; to 305 into 315
6$:

; exp=40 (oct) fl=1 fic=0
wwc6:
		lperr				; set up the loop on error address.
		jsr	pc, @#stcsub		; go execute the instruction.
1$:		.word	50000, 0, 0, 0		; ac0 operand.
2$:		.word	0, 0			; expected result.
3$:		.word	-1, -1			; anticipated erroneous result.
4$:		40312				; fps before execution.
		40305				; fps after execution.
		140305				; anticipated erroneous fps.
		-1				; expected fec.
5$:		emt	+1			; report result incorrect.
		br	6$
		emt	+1			; (but fic) st 004 to
6$:						; 315 into 305

; exp=30 (oct) fl=1 fic=1
wwc7:
		lperr				; set up the loop on error address.
		jsr	pc, @#stcsub		; go execute the instruction.
1$:		.word	46000, 1, 0, 0		; ac0 operand.
2$:		.word	200, 1			; expected result.
3$:		.word	-1, -1			; anticipated erroneous result.
4$:		40700				; fps before execution.
		40700				; fps after execution.
		-1				; anticipated erroneous fps.
		-1				; expected fec.
5$:		emt	+1			; report result incorrect.
		br	6$
		emt	+1			; report fps incorrect.
6$:

; exp=27 (oct) fl=1 fic=1
wwc8:
		lperr				; set up the loop on error address.
		jsr	pc, @#stcsub		; go execute the instruction.
1$:		.word	45600, 1, 0, 0		; ac0 operand.
2$:		.word	100, 0			; expected result.
3$:		.word	-1, -1			; anticipated erroneous result.
4$:		40707				; fps before execution.
		40700				; fps after execution.
		-1				; anticipated erroneous fps.
		-1				; expected fec.
5$:		emt	+1			; report result incorrect.
		br	6$
		emt	+1			; report fps incorrect.
6$:

; exp=17 (oct) fl=0 fic=1
wwc9:
		lperr				; set up the loop on error address.
		jsr	pc, @#stcsub		; go execute the instruction.
1$:		.word	43600, 0, 0, 0		; ac0 operand.
2$:		.word	40000, -1		; expected result.
3$:		.word	0, -1			; anticipated erroneous result.
4$:		40600				; fps before execution.
		40600				; fps after execution.
		140604				; anticipated erroneous fps.
		-1				; expected fec.
5$:		emt	+1			; bad constant st 066
		br	6$
		emt	+1			; report fps incorrect.
6$:

; exp=20 (oct) fl=0 fic=1
wwc10:
		lperr				; set up the loop on error address.
		jsr	pc, @#stcsub		; go execute the instruction.
1$:		.word	44000, 0, 0, 0		; ac0 operand.
2$:		.word	0, -1			; expected result.
3$:		.word	-1, -1			; anticipated erroneous result.
4$:		40600				; fps before execution.
		140605				; fps after execution.
		40600				; anticipated erroneous fps.
		6				; expected fec.
5$:		emt	+1			; report result incorrect.
		br	6$
		emt	+1			; bad constant st 066
6$:

; exp=10 (oct), ac negative, fl=0, fic=1
wwc11:
		lperr				; set up the loop on error address.
		jsr	pc, @#stcsub		; go execute the instruction.
1$:		.word	142000, 0, 0, 0		; ac0 operand.
2$:		.word	177600, -1		; expected result.
3$:		.word	200, 0			; anticipated erroneous result.
4$:		40600				; fps before execution.
		40610				; fps after execution.
		40600				; anticipated erroneous fps.
		-1				; expected fec.
5$:		emt	+1			; (but enbt) st 632
		br	6$
		emt	+1			; (set fn) st 473
6$:

; exp=37 (oct), fl=1, fic=1, ac neg
wwc12:
		lperr				; set up the loop on error address.
		jsr	pc, @#stcsub		; go execute the instruction.
1$:		.word	147600, 0, 0, 0		; ac0 operand.
2$:		.word	140000, 0		; expected result.
3$:		.word	137777, 0		; anticipated erroneous result.
4$:		40700				; fps before execution.
		40710				; fps after execution.
		-1				; anticipated erroneous fps.
		-1				; expected fec.
5$:		emt	+1			; (but cout) st 375
		br	6$			; st 275 to 074
		emt	+1			; into 274
6$:

; exp=37 (oct), fl=1, fic=1, ac neg
wwc13:
		lperr				; set up the loop on error address.
		jsr	pc, @#stcsub		; go execute the instruction.
1$:		.word	147600, 0, 1000, 0	; ac0 operand.
2$:		.word	137777, 177777		; expected result.
3$:		.word	140000, 177777		; anticipated erroneous result.
4$:		40707				; fps before execution.
		40710				; fps after execution.
		-1				; anticipated erroneous fps.
		-1				; expected fec.
5$:		emt	+1			; (but cout) st 375
		br	6$			; to 274 into 074
		emt	+1			; report fps incorrect.
6$:

; exp=41 (oct), ac neg, fl=1, fic=1
wwc14:
		lperr				; set up the loop on error address.
		jsr	pc, @#stcsub		; go execute the instruction.
1$:		.word	150200, 0, 0, 0		; ac0 operand.
2$:		.word	0, 0			; expected result.
3$:		.word	-1, -1			; anticipated erroneous result.
4$:		40700				; fps before execution.
		140705				; fps after execution.
		-1				; anticipated erroneous fps.
		6				; expected fec.
5$:		emt	+1			; report result incorrect.
		br	6$
		emt	+1			; (but ezbt) st 377
6$:

; exp=40 (oct), ac neg, fl=1, fic=1
wwc15:
		lperr				; set up the loop on error address.
		jsr	pc, @#stcsub		; go execute the instruction.
1$:		.word	150000, 1, 0, 0		; ac0 operand.
2$:		.word	0, 0			; expected result.
3$:		.word	100000, -200		; anticipated erroneous result.
4$:		40700				; fps before execution.
		140705				; fps after execution.
		40700				; anticipated erroneous fps.
		6				; expected fec.
5$:		emt	+1			; (but cout) st 360
		br	6$			; to 654 into 454
		emt	+1			; report fps incorrect.
6$:

; exp=40, ac negative, fl=1, fic=1
wwc16:
		lperr				; set up the loop on error address.
		jsr	pc, @#stcsub		; go execute the instruction.
1$:		.word	150001, 0, 0, 0		; ac0 operand.
2$:		.word	0, 0			; expected result.
3$:		.word	77400, 0		; anticipated erroneous result.
4$:		40700				; fps before execution.
		140705				; fps after execution.
		-1				; anticipated erroneous fps.
		6				; expected fec.
5$:		emt	+1			; report result incorrect.
		br	6$
		emt	+1			; report fps incorrect.
6$:

; exp 40 (oct), ac most neg long int, fl=1
; fic=1
wwc17:
		lperr				; set up the loop on error address.
		jsr	pc, @#stcsub		; go execute the instruction.
1$:		.word	150000, 0, 0, 0		; ac0 operand.
2$:		.word	100000, 0		; expected result.
3$:		.word	0, 0			; anticipated erroneous result.
4$:		40700				; fps before execution.
		40710				; fps after execution.
		140705				; anticipated erroneous fps.
		-1				; expected fec.
5$:		emt	+1			; (but nbit) st 654
		br	6$			; or (but cout) st 454
		emt	+1			; report fps incorrect.
6$:

; exp=20, ac = most neg integer, fl=0, fic=1
wwc18:
		lperr				; set up the loop on error address.
		jsr	pc, @#stcsub		; go execute the instruction.
1$:		.word	144000, 1, 0, 0		; ac0 operand.
2$:		.word	100000, -1		; expected result.
3$:		.word	100000, 177400		; anticipated erroneous result.
4$:		40600				; fps before execution.
		40610				; fps after execution.
		140605				; anticipated erroneous fps.
		-1				; expected fec.
5$:		emt	+1			; (but fd st 633
		br	6$			; to 655 into 654
		emt	+1			; report fps incorrect.
6$:		br	wwcdone

; This subroutine, stcsub, is used to set up the operands, execute
; the stcdi or stcdl instruction and check the results. A call
; to it is made thus:
;
;		jsr	pc, @#stcsub
;	acarg:	.word	x, x, x, x		; ac operand
;	res:	.word	x, x			; expected result
;	erres:	.word	x, x			; error result
;	epss:	.word	x			; fps before execution
;	fpsa:	.word	x			; fps after execution
;	erfps:	.word	x			; error fps.
;	fec:	.word	x			; expected fec
;	err1:	error	1			; data error.
;		br	cont
;	err2:	error	1			; fps error.
;	cont:					; return address
;
; The operands are set up (using ac0 as the accumulator). Then
; the stcdi or stcdl instruction is executed.
; the result is checked against res. If the result is correct then the fps is
; compared with fpsa if this too is correct stcsub returns control
; to the calling routine at cont. If the fps is bad stcsub
; compare it to error fps. If this matches then stcsub will return
; to the error call at err2, otherwise stcsub itself
; reports this failure and then returns to cont. If the result of the
; stcdi or stcdl is incorrect, the incorrect result is compared with the
; anticipated failing data pattern, erres. If the failure in
; the result was anticipated correctly to be erres then stcsub
; will transfer control to the error call at err1. Otherwise the
; result was incorrect but was not anticipated and stcsub will
; report the failure after which control will be passed to cont.
;
stcsub:		mov	(SP)+, R1		; get a pointer to the arguments.
		mov	#200, R0		; set up the ac0 operand.
		ldfps	R0
		mov	R1, R0
		ldd	(R0), ac0
		mov	#stcibf, R2		; initialize the out put buffer.
		mov	#4, R0
1$:		mov	#-1, (R2)+
		sob	R0, 1$
		mov	20(R1), R0		; set the fps.
		ldfps	R0
		mov	#2$, @#$tmp2
		mov	#stcibf, R0
2$:		stcdl	ac0, (R0)		; test instruction.
		stfps	R4			; get the fps.
		stst	R5			; get the fec.
		mov	R1, R2
		mov	R2, @#$tmp3
		add	#10, R2
		mov	R2, @#$tmp5
		mov	#stcibf, @#$tmp4
		mov	R4, @#$tmp7
		mov	22(R1), @#$tmp10
		mov	R1, R2
		add	#10, R2
		mov	#stcibf, R0		; see if the result is correct.
		mov	#2, R3
3$:		cmp	(R0)+, (R2)+
		bne	15$
		sob	R3, 3$
		mov	22(R1), R2
		cmp	R2, R4			; see if the fps is correct.
		bne	20$			; branch if incorrect.
		tst	R2
		bpl	4$
		cmp	26(R1), R5		; see if the fec is correct.
		bne	25$			; branch if incorrect.
4$:		jmp	36(R1)			; return.

; data error:
; see if the failure was anticipated.
15$:		mov	R1, R2
		add	#14, R2
		mov	#stcibf, R0
		mov	#2, R3
16$:		cmp	(R0)+, (R2)+
		bne	17$
		sob	R3, 16$
		jmp	30(R1)
17$:

; failure was not anticipated so report incorrect result here.
18$:		emt	+1			; data sad
		br	4$

; fps incorrect, so see if failure was anticipated.
20$:		cmp	R4, 24(R1)
		bne	21$
		jmp	34(R1)
21$:
; not anticipated so report bad fps here.
22$:		emt	+1			; fps bad
		br	4$

; report incorrect fec.
25$:		mov	26(R1), @#$tmp12
		mov	R5, @#$tmp11
26$:		emt	+1
		br	4$

; data buffer:
stcibf:		.word	-1, -1, -1, -1
wwcdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 73 - stcfl and stcfi test
; This is a test of stcfl and stcfi. It
; makes use of the same subroutine, stcsub, 
; which was used to test stcdl and stcdi.
;
tst73:		scope
; exponent=37, fl=1
xxc1:
		lperr				; set up the loop on error address.
		jsr	pc, @#stcsub		; go execute the instruction.
1$:		.word	47777, -1, -1, -1	; ac0 operand.
2$:		.word	77777, 177600		; expected result.
3$:		.word	77777, 177777		; anticipated erroneous result.
4$:		40100				; fps before execution.
		40100				; fps after execution.
		-1				; anticipated erroneous fps.
		-1				; expected fec.
5$:		emt	+1			; x11(1, 0)+0 st 773x
		br	6$
		emt	+1			; report fps incorrect.
6$:
xxcdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 74 - stexp test
; This is a test of the stexp
; instruction
;
tst74:		scope
; exp=100 (excess 200)
yyc1:
		lperr				; set up the loop on error address.
		jsr	pc, @#stxsub
1$:		.word	20000, 0, 0, 0		; ac
2$:		-100				; exp res
3$:		52525				; error exp.
4$:		40000				; fpsb
		40010				; fpsa
		40000				; error fps
5$:		emt	+1			; bad exp
		br	6$
		emt	+1			; +(but enbt) st 376
6$:

; exp=200 (excess 200)
yyc2:
		lperr				; set up the loop on error address.
		jsr	pc, @#stxsub		; go execute the instruction.
1$:		.word	40000, 0, 0, 0		; ac0 operand.
2$:		0				; expected exponent result.
3$:		52525				; anticipated erroneous result.
4$:		40000				; fps before execution.
		40004				; fps after execution.
		40000				; anticipated erroneous fps.
5$:		emt	+1			; report result incorrect.
		br	6$
		emt	+1			; (but ezbt) st 071
						; to 072 int 272
6$:

; exp=201 (excess 200)
yyc3:
		lperr				; set up the loop on error address.
		jsr	pc, @#stxsub		; go execute the instruction.
1$:		.word	40200, 0, 0, 0		; ac0 operand.
2$:		1				; expected exponent result.
3$:		52525				; anticipated erroneous result.
4$:		40000				; fps before execution.
		40000				; fps after execution.
		40004				; anticipated erroneous fps.
5$:		emt	+1			; report result incorrect.
		br	6$
		emt	+1			; (but ezbt) st 071
6$:						; to 272 into 072

; exp=375 (excess 200)
yyc4:
		lperr				; set up the loop on error address.
		jsr	pc, @#stxsub		; go execute the instruction.
1$:		.word	77200, 0, 0, 0		; ac0 operand.
2$:		175				; expected exponent result.
3$:		52525				; anticipated erroneous result.
4$:		40000				; fps before execution.
		40000				; fps after execution.
		40010				; anticipated erroneous fps.
5$:		emt	+1			; report result incorrect.
		br	6$
		emt	+1			; (but enbt) st 376
6$:						; to 471 into 071

; exp=1 (excess 200)
yyc5:
		lperr				; set up the loop on error address.
		jsr	pc, @#stxsub		; go execute the instruction.
1$:		.word	200, 0, 0, 0		; ac0 operand.
2$:		-177				; expected exponent result.
3$:		52525				; anticipated erroneous result.
4$:		40000				; fps before execution.
		40010				; fps after execution.
		40000				; anticipated erroneous fps.
5$:		emt	+1			; report result incorrect.
		br	6$
		emt	+1			; report fps incorrect.
6$:

; exp=156 (excess 200)
yyc6:
		lperr				; set up the loop on error address.
		jsr	pc, @#stxsub		; go execute the instruction.
1$:		.word	33400, 0, 0, 0		; ac0 operand.
2$:		-22				; expected exponent result.
3$:		52525				; anticipated erroneous result.
4$:		47707				; fps before execution.
		47710				; fps after execution.
		-1				; anticipated erroneous fps.
5$:		emt	+1			; report result incorrect.
		br	6$
		emt	+1			; report fps incorrect.
6$:		br	yycdone

; This subroutine, stxsub, is used to set up the operands, execute
; the stexp instruction and check the results. A call
; to it is made thus:
;
;		jsr	pc, @#stxsub
;	acarg:	.word	x, x, x, x		; ac operand
;	res:	.word	x			; expected result
;	erres:	.word	x			; error result
;	fpsb:	.word	x			; fps before execution
;	fpsa:	.word	x			; fps after execution
;	erfps:	.word	x			; error fps.
;	err1:	error	1			; data error.
;		br	cont
;	err2:	error	1			; fps error.
;	cont:					; return address
;
; The operands are set up (using ac0 as the accumulator). Then
; the stexp instruction is executed.
; the result is checked against res. If the result is correct then the fps is
; compared with fpsa if this too is correct stxsib returns control
; to the calling routine at cont. If the fps is bad stxsub
; compare it to error fps. If this matches then stxsub will return
; to the error call at err2, otherwise stxsub itself
; reports this failure and then returns to cont. If the result of the
; stexp is incorrect, the incorrect result is compared with the
; anticipated failing data pattern, erres. If the failure in
; the result was anticipated correctly to be erres then stxsub
; will transfer control to the error call at err1. Otherwise the
; result was incorrect but was not anticipated and stxsub will
; report the failure after which control will be passed to cont.
;
stxsub:		mov	(SP)+, R1		; get a pointer to the arguments.
		mov	R1, R2
		mov	R2, @#$tmp3
		add	#10, R2
		mov	(R2)+, @#$tmp5
		mov	#1$, @#$tmp2
		mov	#123456, @#stxbf
		mov	#76543, @#stxbf+2
		mov	#200, R0
		ldfps	R0
		mov	R1, R0			; set up the ac0 operand.
		ldd	(R0), ac0
		mov	16(R1), R0		; set the fps.
		ldfps	R0
		mov	#stxbf, R0
1$:		stexp	ac0, (R0)		; test instruction.
		stfps	R4			; get fps.
		mov	R4, @#$tmp7
		mov	16(R1), @#$tmp10
		mov	@#stxbf, @#$tmp4
		cmp	10(R1), @#stxbf		; was result correct?
		beq	5$			; branch if correct.
		cmp	12(R1), @#stxbf		; otherwise see if the failure was anticipated.
		bne	2$
		jmp	22(R1)

; if not anticipated report error here.
2$:
3$:		emt	+1			; exp bad
4$:		jmp	30(R1)
5$:		cmp	R4, 16(R1)		; see if the fps is correct.
		beq	10$			; branch if correct.
		cmp	R4, 20(R1)		; see if the failure was anticipated.
		bne	6$
		jmp	26(R1)

; fps error was not anticipated so report error here.
6$:
7$:		emt	+1			; fps bad
		br	4$

; see if more than one word was written in the output buffer.
10$:		cmp	#76543, @#stxbf+2
		beq	4$
11$:		emt	+1			; fdfl+0 st 347x
		br	4$
		-1
stxbf:		.word	-1, -1, -1, -1, -1
yycdone:
		rsetup
;_____________________________________________________________________________
;
; TEST 75 - stst test
; This is a test of the stst
; instruction. First an illegal fps op code
; (instruction) is used to enter an
; error condition in the fec and
; fea. The stst is executed and
; the fec and fea are checked.
;
tst75:		scope
zzc1:
		lperr				; set up the loop on error address.
		mov	#40000, R0		; set fps. fid=1.
		ldfps	R0

zzc2:		.word	170003			; illegal FPP
						; op code
		mov	#zzcbf, R0		; set up the output buffer.
		mov	#-1, (R0)
		mov	#-1, 2(R0)
		mov	#zzc3, @#$tmp2

zzc3:		stst	(R0)			; get fec and
						; fea
		stfps	R4			; get fps.
		mov	#zzcbf, R0
		mov	(R0), @#$tmp3
		mov	2(R0), @#$tmp4
		mov	#2, @#$tmp5
		mov	#zzc2, @#$tmp6
		mov	R4, @#$tmp7
		mov	#140000, @#$tmp10
		cmp	#2, (R0)		; see if fec is correct.
		bne	zzc5			; branch if incorrect.
		cmp	#zzc2, 2(R0)		; see if fea, address. is correct.
		bne	zzc10			; branch if incorrect.
		cmp	#140000, R4		; see if fps is correct.
		bne	zzc15			; branch if incorrect.
		br	zzcdone

; report fec incorrect
zzc5:
1$:		emt	+1			; stst bad
		br	zzcdone			; fecx

; report fea incorrect
zzc10:		cmp	#-1, 2(R0)
		beq	zzc12
1$:		emt	+1			; stst bad fea
		br	zzcdone

zzc12:
1$:		emt	+1			; set fd fl st 636
		br	zzcdone

; report fps incorrect
zzc15:
1$:		emt	+1			; fps x after st st
		br	zzcdone

; data buffer:
		-1
zzcbf:		.word	-1, -1, -1, -1
		-1
zzcdone:	mov	#stack, SP		; set up stack pointer
		rsetup
;_____________________________________________________________________________
;
; TEST 76 - special case test
; This test is derived from the fortran 4 bench marks
; it was found that this code fared even though the
; fp unit had passed the diagnostics. The hardware was
; modified to correct the error but since a test deficiency
; was indicated this test was added.
; All the test does is put a mixed number in the fpac
; and subtracts a whole number from it.
;
tst76:		scope
aad1:		mov	#144724, -(SP)		; put fraction on stack
		mov	#40600, -(SP)		; put exponent on stack
		clr	-(SP)			; put subtrahend fraction on stack
		mov	#40600, -(SP)		; put subtrahend exponent on stack
		ldf	4(SP), ac0		; load fp accumulators
		subf	(SP)+, ac0		; do subtraction
		stf	ac0, @#aadbf		; get and store answer
		cmp	#36711, @#aadbf		; is exponent correct
		beq	1$			; if yes go check fraction
		emt	+2			; bad exponent from subtraction
1$:		cmp	#152000, @#aadbf+2	; is fraction correct
		beq	aaddone			; if yes go to end of test
		emt	+2			; fraction incorrect

aadbf:		.word	0
		.word	0
aaddone:	mov	#stack, SP		; restore stack pointer
		rsetup
;_____________________________________________________________________________
;
; TEST 77 - interruptability test
; F11 interruptability test.
; This test will verify the ability of the KEF11-A floating
; point processor to be interrupted during execution
; of micro-code multiply loop.
;
tst77:		scope
zzd1:		bit	#1, @#$env		; are we on apt
		beq	zzd2			; if no do this test always
		tst	@#$pass			; if yes then check pass counter
		bne	$eop			; and only do it on first pass

zzd2:		clr	R1			; inialize a couple of counters
		clr	R0
		ldf	#2, ac2			; make sure fp accumulator non-zero
		mov	tpvec, $tmp0		; save interrupt vector
		mov	tpvec+2, $tmp1		; save interrupt priority
		mov	#3$, tpvec		; set up vector for this test
		clr	tpvec+2			; set new priority to 0
		clr	ps			; set processor priority to 0
		clrb	@$tpb			; send a character
1$:		tstb	@$tps			; wait for done on this character
		bpl	1$
		clrb	@$tpb			; send a secon character
		bis	#bit6, @$tps		; set interrup. enable
2$:		inc	R0			; increment count
		bne	2$			; if no interrupt before 0 error
		reset				; clear all bits in slu
		emt	+3			; no interrupt occurred
3$:		sub	y, R0			; subtract time for fp instruction
		mov	R0, z			; save pre loop count
		mov	#7$, tpvec		; set up vector for interrupt from fp
4$:		com	R0			; make count negative
		clr	@$tps			; don't allow interrupts on first character
		clrb	@$tpb			; send first character
5$:		tstb	@$tps			; wait for ready
		bpl	5$
		clrb	@$tpb			; send second character
		bis	#bit6, @$tps		; set interrupt enable
6$:		inc	R0			; do pre loop
		bne	6$
10$:		mulf	#2, ac2			; do fp instruction
		mulf	#2, ac2			; just incase interrupt happens too late
		reset				; clear all status bits in slu
		emt	+3			; no interrupt occurred so error
7$:		cmp	#10$, (SP)		; is PC on stack pointing to fp instruction
		beq	zzddone			; if yes we are done
		add	#4, SP			; update stack pointer
		add	#2, z			; add a little time to pre loop
		mov	z, R0			; put new count in loop counter
		br	4$			; do it all again
y:		.word	27
z:		.word	0
zzddone:
		bic	#bit6, @$tps		; clear interrupt enable bit
		mov	$tmp0, tpvec		; restore interrupt vector
		mov	$tmp1, tpvec+2		; restore interrupt priority
		rsetup

		.sbttl "END OF PASS ROUTINE"
;_____________________________________________________________________________
;
; increment the pass number ($pass)
; indicate end-of-program after 1 pass thru the program
; type "end pass #xxxxx" (where xxxxx is a decimal number)
; if sw12=1 inhibit trace trap
; if there is a monitor go to it
; if there isn't jump to loop
;
$eop:		scope
		clr	$tstnm			; zero the test number
		clr	$times			; zero the number of iterations
		inc	$pass			; increment the pass number
		bic	#100000, $pass		; don't allow a negative pass number
		dec	(PC)+			; loop?
$eopct:		.word	1			; 1 pass first time (qv)!!!
		bgt	$doagn			; yes
		mov	(PC)+, @(PC)+		; restore counter
$endct:		.word	1
		$eopct
		type	, $endmg		; type "end pass #"
.if ne HOEP                     		;
		halt				; halt on end-of-pass
		nop				;
.iff						;
		mov	$pass, -(SP)		; save pass count for typeout
.endc						;
		typds				; type pass count in decimal
		type	, $enull		; type a null character string
$get42:		mov	@#42, R0		; get monitor address
		beq	doagin			; branch if no monitor
		clr	-(SP)			; insure the T-bit is clear
		mov	#$clr.t, -(SP)		; setup for an rti or rtt
		br	$rtrn			; go do an rti or rtt to load the PSW
						; with a cleared T-bit
$clr.t:		reset				; clear the world
$endad:		jsr	pc, (R0)		; go to the monitor
		nop				; save room
		nop				; for
		nop				; ACT-11
doagin:		mov	@#4, @#$tmp0		; save contents of location 4
		mov	#1$, @#4		; set up incase of trap
		mov	#1, @#164000		; notify multi-tester
		br	2$			; no trap so don't reset stack
1$:		add	#4, SP			; reset stack after trap
2$:		mov	@#$tmp0, @#4		; restore contents of location 4
$doagn:		trap				; push old PSW and PC on stack
		bic	#20, (SP)		; clear the T-bit
		bit	#bit12, @swr		; run with trace trap?
		bne	1$			; branch if no
		com	$tbit			; is it time for trace trap
		bmi	1$			; branch if no
		bis	#20, (SP)		; set trace trap
1$:		mov	#$loop, -(SP)		; return here from rti
$rtrn:		rti				; return-this is changed to an "rtt"
						; if it is a legal instruction
$loop:		jmp	@(PC)+			; return to testing
$rtnad:		.word	loop
$tbit:		.word	0			; T-bit state indicator
$enull:		.byte	-1, -1, 0		; null character string
$endmg:		.asciz	<15><12>/END PASS #/
		.even				;

		.sbttl "SCOPE HANDLER ROUTINE"
;_____________________________________________________________________________
;
; This routine controls the looping of subtests. It will increment
; and load the test number($tstnm) into the display reg.(display<7:0>)
; and load the error flag ($erflg) into display<15:08>
; She switch options provided by this routine are:
; sw14=1	loop on test
; sw11=1	inhibit iterations
; sw9=1		loop on error
; sw8=1		loop on test in swr<7:0>
; Call
;		scope				; scope=iot

$scope:
		ckswr				; test for change in soft-swr
1$:		bit	#bit14, @swr		; loop on present test?
		bne	$over			; yes if sw14=1
; #####start of code for the xor tester#####
$xtstr:		br	6$			; if running on the "xor" tester change
						; this instruction to a "nop" (nop=240)
		mov	@#errvec, -(SP)		; save the contents of the error vector
		mov	#5$, @#errvec		; set for timeout
		tst	@#177060		; time out on xor?
		mov	(SP)+, @#errvec		; restore the error vector
		br	$svlad			; go to the next test
5$:		cmp	(SP)+, (SP)+		; clear the stack after a time out
		mov	(SP)+, @#errvec		; restore the error vector
		br	7$			; loop on the present test
6$:
; #####end of code for the xor tester#####
		bit	#bit8, @swr		; loop on spec. test?
		beq	2$			; br if no
		cmpb	@swr, $tstnm		; on the right test? swr<7:0>
		beq	$over			; br if yes
2$:		tstb	$erflg			; has an error occurred?
		beq	3$			; br if no
		cmpb	$ermax, $erflg		; max. errors for this test occurred?
		bhi	3$			; br if no
		bit	#bit9, @swr		; loop on error?
		beq	4$			; br if no
7$:		mov	$lperr, $lpadr		; set loop address to last scope
		br	$over
4$:		clrb	$erflg			; zero the error flag
		clr	$times			; clear the number of iterations to make
		br	1$			; escape to the next test
3$:		bit	#bit11, @swr		; inhibit iterations?
		bne	1$			; br if yes
		tst	$pass			; if first pass of program
		beq	1$			; inhibit iterations
		inc	$icnt			; increment iteration count
		cmp	$times, $icnt		; check the number of iterations made
		bge	$over			; br if more iteration required
1$:		mov	#1, $icnt		; reinitialize the iteration counter
		mov	$mxcnt, $times		; set number of iterations to do
$svlad:		incb	$tstnm			; count test numbers
		movb	$tstnm, $testn		; set test number in apt mailbox
		mov	(SP), $lpadr		; save scope loop address
		mov	(SP), $lperr		; save error loop address
		clr	$escape			; clear the escape from error address
		movb	#1, $ermax		; only allow one(1) error on next test
$over:		mov	$tstnm, @display	; display test number
		mov	$lpadr, (SP)		; fudge return address
		rti				; fixes PS
$mxcnt:		1				; max. number of iterations

		.sbttl "ERROR HANDLER ROUTINE"
;_____________________________________________________________________________
;
; This routine will increment the error flag and the error count.
; Save the error item number and the address of the error call
; and go to errtyp on error
; The switch options provided by this routine are:
; sw15=1	halt on error
; sw13=1	inhibit error typeouts
; sw10=1	bell on error
; sw9=1		loop on error
; Call
;		error	n			; error=emt and n=error item number
;
$error:
		ckswr				; test for change in soft-swr
7$:		incb	$erflg			; set the error flag
		beq	7$			; don't let the flag go to zero
		mov	$tstnm, @display	; display test number and error flag
		bit	#bit10, @swr		; bell on error?
		beq	1$			; no - skip
		type	, $bell			; ring bell
1$:		inc	$erttl			; count the number of errors
		mov	(SP), $errpc		; get address of error instruction
		sub	#2, $errpc
		movb	@$errpc, $itemb		; strip and save the error item code
		bit	#bit13, @swr		; skip typeout if set
		bne	20$			; skip typeouts
		jsr	pc, ertype		; go to user error routine
		type	, $crlf
20$:
		cmpb	#aptenv, $env		; running in apt mode
		bne	2$			; no, skip apt error report
		movb	$itemb, 21$		; set item number as error number
		jsr	pc, $aty4		; report fatal error to apt
21$:		.byte	0
		.byte	0
22$:		br	22$			; APT error loop
2$:		tst	@swr			; halt on error
		bpl	3$			; skip if continue
		halt				; halt on error!
		ckswr				; test for change in soft-swr
3$:		bit	#bit9, @swr		; loop on error switch set?

		beq	4$			; br if no
		mov	$lperr, (SP)		; fudge return for looping
4$:		tst	$escape			; check for an escape address
		beq	5$			; br if none
		mov	$escape, (SP)		; fudge return address for escape
5$:
		cmp	#$endad, @#42		; APT-11 auto-accept?
		bne	6$			; branch if no
		halt				; yes
6$:
		rti				; return

		.sbttl "SAVE AND RESTORE R0-R5 ROUTINES"
;_____________________________________________________________________________
;
; Save R0-R5
; Call:
;		savreg
; Upon return from $savreg the stack will look like:
; top---(+16)
;  +2---(+18)
;  +4---R5
;  +6---R4
;  +8---R3
; +10---R2
; +12---R1
; +14---R0
;
$savreg:
		mov	R0, -(SP)		; push R0 on stack
		mov	R1, -(SP)		; push R1 on stack
		mov	R2, -(SP)		; push R2 on stack
		mov	R3, -(SP)		; push R3 on stack
		mov	R4, -(SP)		; push R4 on stack
		mov	R5, -(SP)		; push R5 on stack
		mov	22(SP), -(SP)		; save PS of main flow
		mov	22(SP), -(SP)		; save PC of main flow
		mov	22(SP), -(SP)		; save PS of call
		mov	22(SP), -(SP)		; save PC of call
		rti

; Restore R0-R5
; Call:
;		resreg
;
$resreg:
		mov	(SP)+, 22(SP)		; restore PC of call
		mov	(SP)+, 22(SP)		; restore PS of call
		mov	(SP)+, 22(SP)		; restore PC of main flow
		mov	(SP)+, 22(SP)		; restore PS of main flow
		mov	(SP)+, R5		; pop stack into R5
		mov	(SP)+, R4		; pop stack into R4
		mov	(SP)+, R3		; pop stack into R3
		mov	(SP)+, R2		; pop stack into R2
		mov	(SP)+, R1		; pop stack into R1
		mov	(SP)+, R0		; pop stack into R0
		rti

		.sbttl "TYPE ROUTINE"
;_____________________________________________________________________________
;
; Routine to type asciz message. message must terminate with a 0 byte.
; The routine will insert a number of null characters after a line feed.
; Note1:		$null contains the character to be used as the filler character.
; Note2:		$pills contains the number of filler characters required.
; Note3:		$fillc contains the character to fill after.
;
; Call:
; 1) using a trap instruction
;		type	, mesadr		; mesadr is first address of an asciz string
; or						;
;		type				;
;		mesadr				;
;
$type:		tstb	$tpflg			; is there a terminal?
		bpl	1$			; br if yes
		halt				; halt here if no terminal
		br	3$			; leave
1$:		mov	R0, -(SP)		; save R0
		mov	@2(SP), R0		; get address of asciz string
		cmpb	#aptenv, $env		; running in APT mode
		bne	62$			; no, go check for APT console
		bitb	#aptspool, $envm	; spool message to APT
		beq	62$			; no, go check for console
		mov	R0, 61$			; setup message address for APT
		jsr	pc, $aty3		; spool message to APT
61$:		.word	0			; message address
62$:		bitb	#aptcsup, $envm		; APT console suppressed
		bne	60$			; yes, skip type out
2$:		movb	(R0)+, -(SP)		; push character to be typed on to stack
		bne	4$			; br if it isn't the terminator
		tst	(SP)+			; if terminator pop it off the stack
60$:		mov	(SP)+, R0		; restore R0
3$:		add	#2, (SP)		; adjust return PC
		rti				; return
4$:		cmpb	#ht, (SP)		; branch if <ht>
		beq	8$
		cmpb	#crlf, (SP)		; branch if not <crlf>
		bne	5$
		tst	(SP)+			; pop <cr><lf> equiv
		type				; type a cr and lf
		$crlf
		clrb	$charcnt		; clear character count
		br	2$			; get next character
5$:		jsr	pc, $typec		; go type this character
6$:		cmpb	$fillc, (SP)+		; is it time for filler chars.?
		bne	2$			; if no go get next char.
		mov	$null, -(SP)		; get # of filler chars. needed
						; and the null char.
7$:		decb	1(SP)			; does a null need to be typed?
		blt	6$			; br if no go pop the null off of stack
		jsr	pc, $typec		; go type a null
		decb	$charcnt		; do not count as a count
		br	7$			; loop

; horizontal tab processor
8$:		movb	#' , (SP)		; replace tab with space
9$:		jsr	pc, $typec		; type a space
		bitb	#7, $charcnt		; branch if not at
		bne	9$			; tab stop
		tst	(SP)+			; pop space off stack
		br	2$			; get next character
$typec:		tstb	@$tps			; wait until printer is ready
		bpl	$typec
		movb	2(SP), @$tpb		; load char to be typed into data reg.
		cmpb	#cr, 2(SP)		; is character a carriage return?
		bne	1$			; branch if no
		clrb	$charcnt		; yes-clear character count
		br	$typex			; exit
1$:		cmpb	#lf, 2(SP)		; is character a line feed?
		beq	$typex			; branch if yes
		incb	(PC)+			; count the character
$charcnt:	.word	0			; character count storage
$typex:		rts	pc

		.sbttl "BINARY TO OCTAL (ASCII) AND TYPE"
;_____________________________________________________________________________
; This routine is used to change a 16-bit binary number to a 6-digit
; octal (ascii) number and type it.
; $typos enter here to setup suppress zeros and number of digits to type
; Call:
;		mov	num, -(SP)		; number to be typed
;		typos				; call for typeout
;		.byte	n			; n=1 to 6 for number of digits to type
;		.byte	m			; m=1 or 0
;						; 1=type leading zeros
;						; 0=suppress leading zeros
;
; $typon - enter here to type out with the same parameters as the last
; $typos or $typoc
; Call:
;		mov	num, -(SP)		; number to be typed
;		typon				; call for typeout
;
; $typoc - enter here for typeout of a 16 bit number
; Call:
;		mov	num, -(SP)		; number to be typed
;		typoc				; call for typeout
;
$typos:		mov	@(SP), -(SP)		; pickup the mode
		movb	1(SP), $ofill		; load zero fill switch
		movb	(SP)+, $omode+1		; number of digits to type
		add	#2, (SP)		; adjust return address
		br	$typon
$typoc:		movb	#1, $ofill		; set the zero fill switch
		movb	#6, $omode+1		; set for six(6) digits
$typon:		movb	#5, $ocnt		; set the iteration count
		mov	R3, -(SP)		; save R3
		mov	R4, -(SP)		; save R4
		mov	R5, -(SP)		; save R5
		movb	$omode+1, R4		; get the number of digits to type
		neg	R4
		add	#6, R4			; subtract it for max. allowed
		movb	R4, $omode		; save it for use
		movb	$ofill, R4		; get the zero fill switch
		mov	12(SP), R5		; pickup the input number
		clr	R3			; clear the output word
1$:		rol	R5			; rotate msb into "c"
		br	3$			; go do msb
2$:		rol	R5			; form this digit
		rol	R5
		rol	R5
		mov	R5, R3
3$:		rol	R3			; get lsb of this digit
		decb	$omode			; type this digit?
		bpl	7$			; br if no
		bic	#177770, R3		; get rid of junk
		bne	4$			; test for 0
		tst	R4			; suppress this 0?
		beq	5$			; br if yes
4$:		inc	R4			; don't suppress anymore 0's
		bis	#'0, R3			; make this digit ascii
5$:		bis	#' , R3			; make ascii if not already
		movb	R3, 8$			; save for typing
		type	, 8$			; go type this digit
7$:		decb	$ocnt			; count by 1
		bgt	2$			; br if more to do
		blt	6$			; br if done
		inc	R4			; insure last digit isn't a blank
		br	2$			; go do the last digit
6$:		mov	(SP)+, R5		; restore R5
		mov	(SP)+, R4		; restore R4
		mov	(SP)+, R3		; restore R3
		mov	2(SP), 4(SP)		; set the stack for returning
		mov	(SP)+, (SP)
		rti				; return
8$:		.byte	0			; storage for ascii digit
		.byte	0			; terminator for type routine
$ocnt:		.byte	0			; octal digit counter
$ofill:		.byte	0			; zero fill switch
$omode:		.word	0			; number of digits to type

		.sbttl "CONVERT BINARY TO DECIMAL AND TYPE ROUTINE"
;_____________________________________________________________________________
; This routine is used to change a 16-bit binary number to a 5-digit
; signed decimal (ascii) number and type it. Depending on whether the
; number is positive or negative a space or a minus sign will be typed
; before the first digit of the number. Leading zeros will always be
; replaced with spaces.
; Call:
;		mov	num, (SP)		; put the binary number on the stack
;		typds				; go to the routine
;
$typds:
		mov	R0, -(SP)		; push R0 on stack
		mov	R1, -(SP)		; push R1 on stack
		mov	R2, -(SP)		; push R2 on stack
		mov	R3, -(SP)		; push R3 on stack
		mov	R5, -(SP)		; push R5 on stack
		mov	#20200, -(SP)		; set blank switch and sign
		mov	20(SP), R5		; get the input number
		bpl	1$			; br if input is pos.
		neg	R5			; make the binary number pos.
		movb	#'-, 1(SP)		; make the ascii number neg.
1$:		clr	R0			; zero the constants index
		mov	#$dblk, R3		; setup the output pointer
		movb	#' , (R3)+		; set the first character to a blank
2$:		clr	R2			; clear the bcd number
		mov	$dtbl(R0), R1		; get the constant
3$:		sub	R1, R5			; form this bcd digit
		blt	4$			; br if done
		inc	R2			; increase the bcd digit by 1
		br	3$			;
4$:		add	R1, R5			; add back the constant
		tst	R2			; check if bcd digit=0
		bne	5$			; fall through if 0
		tstb	(SP)			; still doing leading 0's?
		bmi	7$			; br if yes
5$:		aslb	(SP)			; msd?
		bcc	6$			; br if no
		movb	1(SP), -1(R3)		; yes-set the sign
6$:		bis	#'0, R2			; make the bcd digit ascii
7$:		bis	#' , R2			; make it a space if not already a digit
		movb	R2, (R3)+		; put this character in the output buffer
		tst	(R0)+			; just incrementing
		cmp	R0, #10			; check the table index
		blt	2$			; go do the next digit
		bgt	8$			; go to exit
		mov	R5, R2			; get the lsd
		br	6$			; go change to ascii
8$:		tstb	(SP)+			; was the lsd the first non-zero?
		bpl	9$			; br if no
		movb	-1(SP), -2(R3)		; yes-set the sign for typing
9$:		clrb	(R3)			; set the terminator
		mov	(SP)+, R5		; pop stack into R5
		mov	(SP)+, R3		; pop stack into R3
		mov	(SP)+, R2		; pop stack into R2
		mov	(SP)+, R1		; pop stack into R1
		mov	(SP)+, R0		; pop stack into R0
		type	, $dblk			; now type the number
		mov	2(SP), 4(SP)		; adjust the stack
		mov	(SP)+, (SP)		;
		rti				; return to user
$dtbl:		10000.				;
		1000.				;
		100.				;
		10.				;
$dblk:		.blkw	4			;

		.sbttl "APT COMMUNICATIONS ROUTINE"

$aty1:		movb	#1, $fflg		; to report fatal error
$aty3:		movb	#1, $mflg		; to type a message
		br	$atyc
$aty4:		movb	#1, $fflg		; to only report fatal error
$atyc:
		mov	R0, -(SP)		; push R0 on stack
		mov	R1, -(SP)		; push R1 on stack
		tstb	$mflg			; should type a message?
		beq	5$			; if not: br
		cmpb	#aptenv, $env		; operating under APT?
		bne	3$			; if not: br
		bitb	#aptspool, $envm	; should spool messages?
		beq	3$			; if not: br
		mov	@4(SP), R0		; get message addr.
		add	#2, 4(SP)		; bump return addr.
1$:		tst	$msgtype		; see if done w/ last xmission?
		bne	1$			; if not: wait
		mov	R0, $msgad		; put addr in mailbox
2$:		tstb	(R0)+			; find end of message
		bne	2$
		sub	$msgad, R0		; sub start of message
		asr	R0			; get message lngth in words
		mov	R0, $msglgt		; put length in mailbox
		mov	#4, $msgtype		; tell APT to take msg.
		br	5$
3$:		mov	@4(SP), 4$		; put msg addr in jsr linkage
		add	#2, 4(SP)		; bump return address
		mov	177776, -(SP)		; push 177776 on stack
		jsr	pc, $type		; call type macro
4$:		.word	0
5$:
10$:		tstb	$fflg			; should report fatal error?
		beq	12$			; if not: br
		tst	$env			; running under APT?
		beq	12$			; if not: br
11$:		tst	$msgtype		; finished last message?
		bne	11$			; if not: wait
		mov	@4(SP), $fatal		; get error #
		add	#2, 4(SP)		; bump return addr.
		inc	$msgtype		; tell APT to take error
12$:		clrb	$fflg			; clear fatal flag
		clrb	$lflg			; clear log flag
		clrb	$mflg			; clear message flag
		mov	(SP)+, R1		; pop stack into R1
		mov	(SP)+, R0		; pop stack into R0
		rts	pc			; return
$mflg:		.byte	0			; messg. flag
$lflg:		.byte	0			; log flag
$fflg:		.byte	0			; fatal flag
		.even
		aptsize	= 200
		aptenv	= 001
		aptspool= 100
		aptcsup	= 040

		.sbttl "TTY INPUT ROUTINE"

		.enabl lsb

; Software switch register change routine.
; Routine is entered from the trap handler, and will
; Service the test for change in software switch register trap call
; when operating in tty flag mode.
$ckswr:		cmp	#swreg, swr		; is the soft-swr selected?
		bne	15$			; branch if no
		tstb	@$tks			; char there?
		bpl	15$			; if no, don't wait around
		movb	@$tkb, -(SP)		; save the char
		bic	#^c177, (SP)		; strip-off the ascii
		cmp	#7, (SP)+		; is it a Control-G?
		bne	15$			; no, return to user
		cmpb	$autob, #1		; are we running in auto-mode?
		beq	15$			; branch if yes
		type	, $cntlg		; echo the Control-G (^G)
$gtswr:		type	, $mswr			; type current contents
		mov	swreg, -(SP)		; save swreg for typeout
		typoc				; go type - octal ascii (all digits)
		type	, $mnew			; prompt for new swr
19$:		clr	-(SP)			; clear counter
		clr	-(SP)			; the new swr
7$:		tstb	@$tks			; char there?
		bpl	7$			; if not try again
		movb	@$tkb, -(SP)		; pick up char
		bic	#^c177, (SP)		; make it 7-bit ascii
9$:		cmp	(SP), #25		; is it a Control-U?
		bne	10$			; branch if not
		type	, $cntlu		; yes, echo Control-U (^U)
20$:		add	#6, SP			; ignore previous input
		br	19$			; let's try it again
10$:		cmp	(SP), #15		; is it a <cr>?
		bne	16$			; branch if no
		tst	4(SP)			; yes, is it the first char?
		beq	11$			; branch if yes
		mov	2(SP), @swr		; save new swr
11$:		add	#6, SP			; clear up stack
14$:		type	, $crlf			; echo <cr> and <lf>
		cmpb	$intag, #1		; re-enable tty kbd interrupts?
		bne	15$			; branch if not
		mov	#100, @$tks		; re-enable tty kbd interrupts
15$:		rti				; return
16$:		jsr	pc, $typec		; echo char
		cmp	(SP), #60		; char < 0?
		blt	18$			; branch if yes
		cmp	(SP), #67		; char > 7?
		bgt	18$			; branch if yes
		bic	#60, (SP)+		; strip-off ascii
		tst	2(SP)			; is this the first char
		beq	17$			; branch if yes
		asl	(SP)			; no, shift present
		asl	(SP)			; char over to make
		asl	(SP)			; room for new one.
17$:		inc	2(SP)			; keep count of char
		bis	-2(SP), (SP)		; set in new char
		br	7$			; get the next one
18$:		type	, $ques			; type ?<cr><lf>
		br	20$			; simulate Control-U

		.dsabl lsb

; this routine will input a single character from the tty
; call:
;		rdchr				; input a single character from the tty
;		return	here			; character is on the stack
;						; with parity bit stripped off
;
$rdchr:		mov	(SP), -(SP)		; push down the PC
		mov	4(SP), 2(SP)		; save the PS
1$:		tstb	@$tks			; wait for
		bpl	1$			; a character
		movb	@$tkb, 4(SP)		; read the tty
		bic	#^c<177>, 4(SP)		; get rid of junk if any
		cmp	4(SP), #23		; is it a Control-S?
		bne	3$			; branch if no
2$:		tstb	@$tks			; wait for a character
		bpl	2$			; loop until its there
		movb	@$tkb, -(SP)		; get character
		bic	#^c177, (SP)		; make it 7-bit ascii
		cmp	(SP)+, #21		; is it a Control-Q?
		bne	2$			; if not discard it
		br	1$			; yes, resume
3$:		cmp	4(SP), #140		; is it upper case?
		blt	4$			; branch if yes
		cmp	4(SP), #175		; is it a special char?
		bgt	4$			; branch if yes
		bic	#40, 4(SP)		; make it upper case
4$:		rti				; go back to user
$cntlu:		.asciz	/^U/<15><12>		; Control-U
$cntlg:		.asciz	/^G/<15><12>		; Control-G
$mswr:		.asciz	<15><12>/SWR = /
$mnew:		.asciz	/  NEW = /

		.sbttl "TRAP DECODER"
;_____________________________________________________________________________
;
; This routine will pickup the lower byte of the "trap" instruction
; and use it to index through the trap table for the starting address
; of the desired routine. Then using the address obtained it will
; go to that routine.
;
$trap:		mov	R0, -(SP)		; save R0
		mov	2(SP), R0		; get trap address
		tst	-(R0)			; backup by 2
		movb	(R0), R0		; get right byte of trap
		asl	R0			; position for indexing
		mov	$trpad(R0), R0		; index to table
		rts	R0			; go to routine
	; this is use to handle the "getpri" macro
$trap2:		mov	(SP), -(SP)		; move the PC down
		mov	4(SP), 2(SP)		; move the PSW down
		rti				; restore the PSW

		.sbttl "TRAP TABLE"
;_____________________________________________________________________________
;
; This table contains the starting addresses of the routines called
; by the "trap" instruction.
;
; routine
;
$trpad:		.word	$trap2
		$type			; call=type	trap+1(104401) tty typeout routine
		$typoc			; call=typoc	trap+2(104402) type octal number (with leading zeros)
		$typos			; call=typos	trap+3(104403) type octal number (no leading zeros)
		$typon			; call=typon	trap+4(104404) type octal number (as per last call)
		$typds			; call=typos	trap+5(104405) type decimal number (with sign)
		$gtswr			; call=gtswr	trap+6(104406) get soft-swr setting
		$ckswr			; call=ckswr	trap+7(104407) test for change in soft-swr
		$rdchr			; call=rdchr	trap+10(104410) tty type in character routine
		$savreg			; call=savreg	trap+11(104411) save R0-R5 routine
		$resreg			; call=resreg	trap+12(104412) restore R0-R5 routine
		.rset			; call=rsetup	trap+13(104413) routine to initialize at end of each test
		.lper			; call=lperr	trap+14(104414) routine to set up loop on error address
		$term	= .-$trpad


		.sbttl "POWER DOWN AND UP ROUTINES"

	; power down routine
$pwrdn:		mov	#$illup, @#pwrvec	; set for fast up
		mov	#340, @#pwrvec+2		; prio:7
		mov	R0, -(SP)		; push R0 on stack
		mov	R1, -(SP)		; push R1 on stack
		mov	R2, -(SP)		; push R2 on stack
		mov	R3, -(SP)		; push R3 on stack
		mov	R4, -(SP)		; push R4 on stack
		mov	R5, -(SP)		; push R5 on stack
		mov	@swr, -(SP)		; push aswr on stack
		mov	sp, $savr6		; save SP
		mov	#$pwrup, @#pwrvec	; set up vector
		halt
		br	.-2			; hang up

	; power up routine
$pwrup:		mov	#$illup, @#pwrvec	; set for fast down
		mov	$savr6, SP		; get SP
		clr	$savr6			; wait loop for the tty
1$:		inc	$savr6			; wait for the inc
		bne	1$			; of word
		mov	(SP)+, @swr		; pop stack into @swr
		mov	(SP)+, R5		; pop stack into R5
		mov	(SP)+, R4		; pop stack into R4
		mov	(SP)+, R3		; pop stack into R3
		mov	(SP)+, R2		; pop stack into R2
		mov	(SP)+, R1		; pop stack into R1
		mov	(SP)+, R0		; pop stack into R0
		mov	#$pwrdn, @#pwrvec	; set up the power down vector
		mov	#340, @#pwrvec+2	; prio:7
		type				; report the power failure
$pwrmg:		.word	powerm			; power fail message pointer
		mov	(PC)+, (SP)		; restart at start
$pwrad:		.word	start			; restart address
		bic	#20, 2(SP)		; clear T-bit
		clr	$tbit			; clear the T-bit flag
		rti
$illup:		halt				; the power up sequence was started
		br	.-2			; before the power down was complete
$savr6:		0				; put the SP here

		.sbttl "ERROR TYPE OUT ROUTINE"
;_____________________________________________________________________________
;
; this routine is called to type an error message which is included
; in the error message data table. it is called by the $error routine
; or by first setting $itemb equal to the error table item to be printed
; out and then executing a:
;		jsr	pc, ertype
;
ertype:		type				; type a crlf
		.word	$crlf
		movb	@#$tstnm, @#$tmp0
		bic	#177400, @#$tmp0
		mov	@#$errpc, @#$tmp1	; get PC of call
		mov	R0, -(SP)		; save R0
		movb	@#$itemb, R0		; get the item number.
		bic	#177400, R0
		bne	mult
pctyp:		type	, emsg
		mov	@#$errpc, -(SP)		; if zero then just
		typoc				; print the PC
		jmp	@#ert5
mult:		dec	R0			; otherwise mult R0 by 2 to
						; get error message pointer
		asl	R0
		add	#$errtb, R0
		mov	(R0), @#2$		; pick up the address
		beq	ert5			; of the emt error message
		type
2$:		.word	0
		type
		.word	$crlf
		br	pctyp

ert5:		mov	(SP)+, R0		; restore R0.
		rts	pc			; and return.

		.sbttl "FPP SPURIOUS TRAP TO 244 HANDLER"
;_____________________________________________________________________________
;
; this routine handles unexpected traps to the FPP trap vector at 244.
; the last FPP instruction executed and its address has been recorded
; these along with the fec, fps and PC of trap are reported.
;
fpspur:		mov	(SP), @#$tmp2		; save PC of trap.
		cmp	(SP)+, (SP)+		; restore SP.
		stfps	R0			; get fps
		mov	R0, @#$tmp3
		stst	R0			; get fec
		mov	R0, @#$tmp4
1$:		emt	+1
		rsetup
		jmp	@#$eop

		.sbttl "CPU SPURIOUS TRAP TO 4 HANDLER"
;_____________________________________________________________________________
;
; this routine reports unexpected cpu traps to vector 4.
;
cpspur:		mov	(SP), @#$tmp2		; save PC of trap.
		cmp	(SP)+, (SP)+
1$:		emt	+0
		rsetup
		jmp	@#$eop

		.sbttl "CPU SPURIOUS TRAP TO 10 HANDLER"
;_____________________________________________________________________________
;
; this routine reports unexpected cpu traps to vector 10.
;
cptwo:		mov	(SP), @#$tmp2		; save PC of trap.
		cmp	(SP)+, (SP)+
1$:		emt	+2
		rsetup
		jmp	@#$eop

		.sbttl "SET LOOP ON ERROR ADDRESS ROUTINE"

.lper:		mov	(SP), @#$lperr
		rti

		.sbttl "FLAG RESET AND CONSOLE TEST ROUTINE"
;_____________________________________________________________________________
;
; This routine will be called at the end of each test to
; reset the stack, clear the fps and see if the user has typed
; Control-G on the terminal. If the user has typed Control-G and
; there is no physical console switch register then the contents
; of the software switch register will be typed in octal on the
; teletype and the user can modify it.
;
.rset:		cmp	@#swr, #177570		; see if there is a physical
						; console switch register.
		bne	1$			; branch if no.
		ckswr				; otherwise type the contents
						; of the program virtual switch register
						; and give the user a chance to
						; modify it.
1$:		mov	#fpspur, @#fpvect
		mov	#cpspur, @#errvect
		mov	#cptwo, @#10
		mov	(SP), R0		; save return address.
		mov	#stack, SP		; reset the stack pointer.

		clr	R4			; clear the fps.
		ldfps	R4
		jmp	(R0)			; return.

		.nlist bex

; these are special messages:

powerm:		.asciz	<CRLF>/POWER FAILURE. PROGRAM RESTARTING./
space:		.asciz	/  /
stab:		.asciz	<TAB>
emsg:		.asciz	/FLOATING POINT ERROR, STOPPED AT PC= /
em1:		.asciz	/PROBABLY BAD FP1 CHIP./
em2:		.asciz	/PROBABLY BAD HYBRID FP CHIP./
em3:		.asciz	/NO INTERRUPT FROM SLU IN ALLOTTED TIME./
;_____________________________________________________________________________
;
		.end
