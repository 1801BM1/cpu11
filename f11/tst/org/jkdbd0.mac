; Originally was compiled by MACY-11, an assembler running on the pdp-10,
; The source is adapted to be translated by regular MACRO-11.
;
;
;			IDENTIFICATION
;			--------------
; Product code:		AC-F141D-MC
; Product name:		CJKDBD0 DCF11-AA CPUOP diag
; Date:			Jan-81
; Maintainer:		Diagnostic Engineering
; Copyright (c) 1979, 1981 Digital Equipment Corp., Maynard, Mass.
;
; This software is furnished to purchaser under a license for use
; on a single computer system and can be copied (with inclusion
; of DEC's Copyright Notice) only for use in such system, except
; as may otherwise be provided in writing by DEC.
;
; The information in this document is subject to change without
; notice and should not be construed as a commitment by Digital
; Equipment Corporation.
;
; DEC assumes no responsib1lity for the use or reliability of
; its software on equipment which is not supplied by DEC.
;_____________________________________________________________________________
;
;			CONTENTS
;			--------
; 1.0	General information.
; 1.1	History.
; 1.2	Program description.
; 1.3	Abstracts of part one, two and three.
; 2.0	Hardware requirement.
; 3.0	Related documents and standards.
; 4.0	Starting procedures.
; 5.0	Trapcatcher abstracts.
; 6.0	Error handling.
; 6.1	Error handling in part one and two.
; 6.2	Error handling in part three.
; 7.0	Switch setting (applicable only to part three).
; 8.0	Execution times.
; 9.0	Routines abstract.
; 9.1	Halt routine.
; 9.2	Power fail routine.
;
; 1.0	General information
;
; 1.1	History:
;
;	This program is a combined version of the three basic
;	11/34 diagnostic programs with modifications and
;	enhancements made to account for the differences
;	between the two processors.
;
; 1.2	Program description:
;
;	This program contains three parts: cpuop, trap and
;	EIS tests. In the first and second parts, the program
;	will halt on error. In part three, EIS test, when
;	an error is detected, the error PC and error number
;	will be typed, then the program will continue execution.
;	Loop on error is provided by manually modifying
;	some appropriate memory locations. See the listing
;	of that test for details and instructions.
;
;	This program assumes some options (for EIS test only).
;	They are:
;		1. Enable error printouts
;		2. Continue execution on error
;
; 1.3	Abstract
;
;	Part one:
;
;	CPUOP test, this is the first part of the main program.
;	This test check out the basic PDP-11 instructions in every
;	addressing modes with various types of data patterns.
;
;	Part two:
;
;	Trap test, this is the second part of the main program.
;	This is a test of all operations and instructions that
;	cause traps. also tested are trap overflow conditions,
;	oddities of register 6, interrupts, the reset and wait
;	instructions. This program checks that on all trap
;	operations register 6 is decremented the correct amount,
;	that the correct PC is saved on the stack, that the old
;	condition codes and priority are placed on the stack and
;	that the new status and condition codes are correct.
;
;	Both the "trap" and "emt" trap instructions are tested
;	to see that all combinations will trap. Checked also
;	is that all reserved instructions will trap. The trace bit
;	is checked to see if it causes a trap. The rti and rtt
;	instructions are checked. Stack overflow is also checked
;	for all the trap instructions.
;
;	Special checks are made to see if bus error traps occur
;	on non-existent memory. All instructions that are reserved
;	should trap to location 10, and the PC that points to the
;	trapping instruction should be placed on the stack.
;
;	Part three:
;
;	This program tests the extended instruction set
;	<ash, ashc, mul and div> using registers 0-5 at least
;	once with each instruction.
;
;	This program tests all the EIS instructions of the 11/34
;	for ash and ashc instructions every even pass is executed
;	with destination mode 0 for all registers and every odd pass
;	with destination mode of 67. The diagnostic does not make a
;	pass with T-bit set.
;
; 2.0	Hardware requirement
;
;	A processor with DCF11-AA chip set, a minimun of 16k of
;	memory and a console terminal. If program is running
;	under APT or ACT, the console terminal is not necessary.
;
; 3.0	Related documents and standards:
;
;	ACT11/XXDP programming specification
;	standard APT system to a PDP11 diagnostic interface
;	PDP11 maindec sysmac package
;	KDF11-A module specification
;
; 4.0	Starting procedures
;
;	The program is started by loading address 200.
;	The restart address is 1024.
;	Program identification will be typed after the first
;	pass of the whole program.
;
; 5.0	Trapcatcher abstracts
;
;	This is a series of instructions designed to detect and
;	isolate unexpected traps and interrupts, that occur in the
;	trap and interrupt vector area of memory.
;
;	The principle of this routine is: the vector entrance
;	address points to the next sequential word which will contain
;	a halt (000000) (this location is also the status
;	word for that vector entrance. But this will have no effect
;	on it also being the next instruction).
;
;	If a halt occurs in the trap or interrupt vector area,
;	register six should be examined to determine its contents,
;	then use register six contents as an address to determine
;	where the program was. When the interrupt or trap occurred
;	memory as specified by R6 contains the PC of the instruction
;	following the instruction where the trap occurred.
;
;	The contents of location "$testn" (304) contains the test
;	number that it was doing before it trapped.
;
; 6.1	Error handling in part one and part two
;
;	In parts one and two, all errors will cause a halt.
;
;	The program checks to see that the PC doesn't jump erratically
;	within the tests by using a sequence count called "$testn".
;
;	Example:
;
;	tsta:	inc	(R2)		; increment the test number
;		cmp	#a, (R2)	; compare for the right test
;		bne	tsta+1-10	; if not correct branch to a halt
;
;		* R2 contains the address of $testn (304).
;		  a is the current test number.
;
;	if an error is detected, the program will halt
;	it could be because of two reasons.
;	a) wrong test number (sequence error)
;	b) error in the present test.
;
;	The test sequence count "testn" should be checked first
;	to see if it matches the present test.
;	If it doesn't match, then the contents of this location
;	tell you which test it was doing before it halted.
;
; 6.2	Error handling in part three
;
;	In part three, any error, includes sequence check error will
;	cause the error message to be typed. the program will
;	continue execution after type out.
;
;	The error reporting format is as follows:
;
;	ERROR. PC and error # are:
;		PC #
;		error #
;
; 7.0	Switch settings
;
;	Since no hardware switch register is available, the program
;	automatically uses the contents of loc.176 as the software
;	switch register. The initial content of loc.176 is 000000,
;	The user may pre-set this location before starting the program.
;	if the program is being run in APT mode (bit 0 of $env set
;	to a one) then the location $swreg is used as the switch
;	register.
;
;	Bit #	Octal Value	Function
;
;	15	100000		Halt on error
;	13	020000		Inhibit error printout
;	2	000004		Program reserved - program will set
;				if cis option is available
;	1	000002		30k system do not check
;				for traps between 28k-30k
;	0	000001		Skip traps test
;
;	Note:	switches "15" and "13" only effect part three of
;		this diagnostic. Parts 1 and 2 always halt on error.
;
;	Also, within the APT table, an 8 bit byte $envm (location 321)
;	has been used to define the operating mode. All typeouts
;	can be suppressed by making bit 5 of byte $envm high.
;	In other words by placing a 20000 in location 320.
;
; 8.0	Execution times
;
;	The run time for a single run (the first pass) is one second
;	after the first pass. The program will iterate every 15 times
;	before the end of pass message is typed again. The run time
;	for each additional end of pass message typed is approximately
;	15 seconds.
;
; 9.0	Routines abstract
;
; 9.1	Halt routine (applicable only to part three).
;
;	This routine is called via a jsr instruction each time
;	an error is seen and an error message is then typed out
;	unless it is supressed by the switches.
;
;	The comments beside the call to the halt subroutine
;	tells what was being tested and what was expected. all
;	printouts will be suppressed when bit 5 of location
;	$envm is high.
;	While running under APT the diagnostic will not
;	support spooling of console outputs.
;
; 9.2	Power fail routine
;
;	If a power fail occurs (followed by a power up), the
;	message "POWER FAIL" is typed out and the program will
;	restart execution at "restrt".
;_____________________________________________________________________________

		HOEP	= 0			; halt on end-of-pass
		MEMLIM	= 000000		; 100000 to cut the loop
		NOILL	= 0			; disable illegal ops test
;_____________________________________________________________________________
;
		.asect				;
		. = 0				; loop on test

		.title CJKDB-D DCF11-AA CPUOP DIAG.
		.nlist cnd, mc, md
		.list me
						;
		R0	= %0			;
		R1	= %1			;
		R2	= %2			;
		R3	= %3			;
		R4	= %4			;
		R5	= %5			;
		SP	= %6			;
		PC	= %7			;
;_____________________________________________________________________________
;
		.macro	jmpR0			; macro-11 generates an error z
		.word	000120			; jmp (R0)+ works differently
		.endm				; on pdp-11 models
						;
		.macro	jsrR0 addr		;
		.ntype	dst, <addr>		;
	.if eq dst-7				;
		.word	004720			; jsr PC, (R0)+
	.endc					;
	.if eq dst-1				;
		.word	004120			; jsr R1, (R0)+
	.endc					;
		.endm				;
						;
		.macro	addR0 addr		;
		.ntype	dst, addr		;
		.word	060000 + dst		;
		.endm				;
						;
		.macro	movpc addr, val		;
		.ntype	dst, addr		;
		.word	010700 + dst		;
	.if eq dst-67				;
		.word	addr-.-2		; mov PC, addr
	.endc					;
	.if eq dst-77				;
		.word	val-.-2			; mov PC, @addr
	.endc					;
	.if eq dst-70				;
		.word	val			; mov PC, @val(R0)
	.endc					;
	.if eq dst-60				;
		.word	val			; mov PC, val(R0)
	.endc					;
		.endm				;
;_____________________________________________________________________________
;
		.macro	vect, offset, adr, val	;
		.	= offset		;
	.if	nb, <adr>			;
		.word	adr			;
	.iff					;
		.word	.+2			;
	.endc					;
	.if	nb, <val>			;
		.word	val			;
	.iff					;
		.word	0			;
	.endc					;
		.endm				;
;_____________________________________________________________________________
;
		.nlist
		vect	0, 2,			;
		vect	4, to4, 0		;
		vect	10, to10, 0		;
		vect	14, to14, 0		;
		vect	20, 22,			;
		vect	24, 200			; for APT start up
		vect	30, to30, 0		;
		vect	34, to34, 0		;
		vect	40, 42,			; hooks required by act11
		vect	44, $apthd, $endad	; set loc.46 to address of $endad in .seop
		vect	50, 52			; set loc.52 to zero
		vect	54, 56			;
		vect	60, 62			;
		vect	64, 66			;
		vect	70, 72			;
		vect	74, 76			;
		vect	100, 102		;
		vect	104, 106		;
		vect	110, 112		;
		vect	114, to114, 0		;
		vect	120, 122		;
		vect	124, 126		;
		vect	130, 132		;
		vect	134, 136		;
		vect	140, 142		;
		vect	144, 146		;
		vect	150, 152		;
		vect	154, 156		;
		vect	160, 162		;
		vect	164, 166		;
		.list				;
						;
		. = 170				;
		.word	172			;
lpadr:		.word	0			; loop address (EIS test)
dispreg:	.word	0			; software display register
swreg:		.word	0			; software switch register
						;
		. = 200				;
		jmp	start			;
		mov	#stbot, SP		; set stack pointer
		mov	#$testn, R2		; set mailbox pointer
		jmp	@(PC)+			; jump to subtest
		.word	0			; addr. of subtest goes here
						;
		.nlist				;
		vect	220, 222		;
		vect	224, 226		;
		vect	230, 232		;
		vect	234, 236		;
		vect	240, 242		;
		vect	244, to244, 0		;
		vect	250, to250, 0		;
		vect	254, 256		;
		vect	260, 262		;
		vect	264, 266		;
		vect	270, 272		;
		vect	274, 276		;
		.list				;
						;
;_____________________________________________________________________________
;
		type	= 104401		; trap+1 tty typeout routine
		typoc	= 104402		; trap+2 type octal number (with leading zeros)
		typos	= 104403		; trap+3 type octal number (no leading zeros)
		typon	= 104404		; trap+4 type octal number (as per last call)
		typds	= 104405		; trap+5 type decimal number (with sign)
						;
		ps	= 177776		;
		tks	= 177560		;
		tkb	= 177562		;
		tps	= 177564		;
		tpb	= 177566		;
		usrm	= 140000		;
		pusrm	= 30000			;
						;
;_____________________________________________________________________________
;
		. = 300				;
		.sbttl	"APT MAILBOX-ETABLE"	;
		.even				;
						;
$mail:						; APT mailbox
$msgty:		.word	0			; amsgty - message type code
$fatal:		.word	0			; afatal - fatal error number
$testn:		.word	0			; atestn - test number
$pass:		.word	0			; apass	 - pass count
$devct:		.word	0			; adevct - device count
$unit:		.word	0			; aunit  - I/O unit number
$msgad:		.word	0			; amsgad - message address
$msglg:		.word	0			; amsglg - message length
$etable:					; 	   APT environment table
$env:		.byte	0			; aenv	 - environment byte
$envm:		.byte	0			; aenvm	 - environment mode bits
$swreg:		.word	0			; aswreg - APT switch register
$uswr:		.word	0			; auswr  - user switches
$cpuop:		.word	0			; acpuop - cpuop type, options
						; bits 15-11=cpuop type
						; 11/04=01, 11/05=02,
						; 11/20=03, 11/40=04,
						; 11/45=05, 11/70=06,
						; pdq=07, q=10
						; bit 10 - real time clock
						; bit 9  - floating point processor
						; bit 8  - memory management
$etend:						;
;_____________________________________________________________________________
;
; Setup APT parameter block as defined in the APT-pdp11 diagnostic interface spec.
;
$apthd:
$hibts:		.word	0			; two high bits of 18 bit mailbox addr.
$mbadr:		.word	$mail			; address of APT mailbox (bits 0-15)
$tstm:		.word	13			; run tim of longest test
$pastm:		.word	20			; run time in secs. of 1st pass on 1 unit (quick verify)
$unitm:		.word	5			; additional run time (secs) of a pass for each additional unit
		.word	$etend-$mail/2		; length mailbox-etable (words)
						;
		.nlist				;
		vect	344, 346		;
		vect	350, 352		;
		vect	354, 356		;
		vect	360, 362		;
		vect	364, 366		;
		.list				;
						;
		. = 370				; data table for use in addressing mode tests
		.word	0, 0, 0, 0, 0, 0, 1, 1, -1
;_____________________________________________________________________________
;
; Set up starting address
;
		$error	= $fatal		;
		$tstnm	= $testn		;
		. = 1000			;
stbot:		.word	0			; stack pointer
						;
;_____________________________________________________________________________
;
		.sbttl	"STARTING OF CPUOP TEST"
						;
start:		mov	#pwrdn, @#24		; set up for power fail
		mov	#0, @#$pass		; clear pass count
		mov	#16, @#passpt		; set print counter
restrt:		mov	#stbot, SP		; initialize stack pointer
		mov	#$testn, R2		; set up pointer to message type
		mov	#0, @#$tstnm		; clear test number
		mov	#0, @#$error		; clear error number
		mov	#0, @#$msgty		; clear message type (for APT)
;_____________________________________________________________________________
;
; TEST 1 - check branches on Z-bit
;
ts1:		inc	(R2)			; update test number
		cmp	#1, (R2)		; sequence error?
		bne	ts2-10			; br to error halt on seq error
		ccc				; clear all condition codes
		beq	bra1			; should branch
		br	bra2			; bad branch of Z-bit
						;
bra1:		mov	#1, -(R2)		; move to mailbox #1
		inc	-(R2)			; set msgtyp to fatal error
		halt				; should have branched: Z=0
						;
bra2:		bne	bra3			;
		mov	#2, -(R2)		; move to mailbox #2
		inc	-(R2)			; set msgtyp to fatal error
		halt				;
						;
bra3:		sez				;
		bne	bra4			;
		br	bra5			;
						;
bra4:		mov	#3, -(R2)		; move to mailbox #3
		inc	-(R2)			; set msgtyp to fatal error
		halt				; should not have branched here on Z=1
						;
bra5:		beq	ts2			;
		mov	#4, -(R2)		; move to mailbox #4
		inc	-(R2)			; set msgtyp to fatal error
		halt				; should have branched on Z=1
						; or sequence error
;_____________________________________________________________________________
;
; The data path tests are used to verify that various data patterns can be
; successfully moved through the data paths move and compare mode 2, 3
; instructions are used to pass and test various data patterns in the data paths.
;
; The test exercises the internal data paths, and the unibus data transcievers,
; If these tests fail, examine the target location (loc.0) to see which bits of
; the data path are failing.
;
; TEST 2 - test of zeroes in the data path
;
		.sbttl	"DATA PATH TESTS"
						;
ts2:		inc	(R2)			; update test number
		cmp	#2, (R2)		; sequence error?
		bne	ts3-10			; br to error halt on seq error
		mov	#0, @#0			; move zeroes thru address lines, data
						; lines and internal paths
		tst	@#0			; successful?
		beq	ts3			;
		mov	#5, -(R2)		; move to mailbox #5
		inc	-(R2)			; set msgtyp to fatal error
		halt				; data incorrect
						; or sequence error
;_____________________________________________________________________________
;
; TEST 3 - test of pattern 125252 in data path
;
ts3:		inc	(R2)			; update test number
		cmp	#3, (R2)		; sequence error?
		bne	ts4-10			; br to error halt on seq error
		mov	#125252, @#0		; move alternating ones and zeroes
						; thru data paths
		cmp	#125252, @#0		; successful
		beq	ts4			;
		mov	#6, -(R2)		; move to mailbox #6
		inc	-(R2)			; set msgtyp to fatal error
		halt				; data incorrect
						; or sequence error
;_____________________________________________________________________________
;
; TEST 4 - test of pattern 052525 in data path
;
ts4:		inc	(R2)			; update test number
		cmp	#4, (R2)		; sequence error?
		bne	ts5-10			; br to error halt on seq error
		mov	#052525, @#0		; move alternating zeroes and ones
						; thru data path
		cmp	#052525, @#0		; successful?
		beq	ts5			;
		mov	#7, -(R2)		; move to mailbox #7
		inc	-(R2)			; set msgtyp to fatal error
		halt				; data incorrect
						; or sequence error
;_____________________________________________________________________________
;
; TEST 5 - test of all ones in data path
;
ts5:		inc	(R2)			; update test number
		cmp	#5, (R2)		; sequence error?
		bne	ts6-10			; br to error halt on seq error
		mov	#177777, @#0		; move ones thru data path
		cmp	#177777, @#0		; successful
		beq	ts6			;
		mov	#10, -(R2)		; move to mailbox #10
		inc	-(R2)			; set msgtyp to fatal error
		halt				; data incorrect
						; or sequence error
;_____________________________________________________________________________
;
; The B-register (location 0) shifting logic tests are used to test that
; the B-register can hold various data patterns and that the associated logic
; supports the shifting functions within the B-register and C-bit.
;
; A one is shifted through every bit in the B-register and C-bit in
; both directions. The B-register itself is tested in its ability as a
; buffer and as a shift register. data is also passed through the data path
; and ALU.
;
; If these tests fail, examine the target location (loc.0) to see which bits
; of the B-register may be failing.
;
; TEST 6 - shift bit 0 to bit 1
;
		.sbttl	"B-REGISTER TEST"
						;
ts6:		inc	(R2)			; update test number
		cmp	#6, (R2)		; sequence error?
		bne	ts7-10			; br to error halt on seq error
		clc				; clear carry bit
		mov	#1, @#0			; load a 1
		rol	@#0			; shift left
		cmp	#2, @#0			; successful
		beq	ts7			;
		mov	#11, -(R2)		; move to mailbox #11
		inc	-(R2)			; set msgtyp to fatal error
		halt				; bit 1 not set
						; or sequence error
;_____________________________________________________________________________
;
; TEST 7 - shift carry into bit 0
;
ts7:		inc	(R2)			; update test number
		cmp	#7, (R2)		; sequence error?
		bne	ts10-10			; br to error halt on seq error
		mov	#0, @#0			; clear location
		sec				; set carry
		rol	@#0			; rotate carry bit to bit 0
		bcc	ts10			;
		mov	#12, -(R2)		; move to mailbox #12
		inc	-(R2)			; set msgtyp to fatal error
		halt				; carry clear
						; or sequence error
		cmp	#1, @#0			; bit 0 set
		beq	ts10			;
		mov	#13, -(R2)		; move to mailbox #15
		inc	-(R2)			; set msgtyp to fatal error
		halt				; bit 0 not set
						; or sequence error
;_____________________________________________________________________________
;
; TEST 10 - left shift from bit 0 to C-bit
;
ts10:		inc	(R2)			; update test number
		cmp	#10, (R2)		; sequence error?
		bne	ts11-10			; br to error halt on seq error
		mov	#1, @#0			; set bit 0
		mov	#-21, R0		; set bit counter
		clc				; clear C-bit
shl:		inc	R0			; increment bit counter
		beq	shle			; br to error halt if bit is lost
		rol	@#0			; shift left one position
		bcc	shl			; branch if C-bit not set
		beq	ts11			;
shle:		mov	#14, -(R2)		; move to mailbox #14
		inc	-(R2)			; set msgtyp to fatal error
		halt				; left shifting logic failed
						; or sequence error
;_____________________________________________________________________________
;
; TEST 11 - shift bit 15 to bit 14
;
ts11:		inc	(R2)			; update test number
		cmp	#11, (R2)		; sequence error?
		bne	ts12-10			; br to error halt on seq error
		mov	#100000, @#0		; set bit 15
		clc				; clear carry
		ror	@#0			; shift bit 15 to bit 14
		cmp	#40000, @#0		; successful
		beq	ts12
		mov	#15, -(R2)		; move 10 mailbox #15
		inc	-(R2)			; set msgtyp to fatal error
		halt				; bit 14 not set
						; or sequence error
;_____________________________________________________________________________
;
; TEST 12 - right shift from bit 15 to C-bit
;
ts12:		inc	(R2)			; update test number
		cmp	#12, (R2)		; sequence error?
		bne	ts13-10			; br to error halt on seq error
		mov	#100000, @#0		; set bit 15
		mov	#-21, R0		; set bit counter
		clc				; clear C-bit
shr:		inc	R0			; increment bit counter
		beq	shre			; br to error halt if bit is lost
		ror	@#0			; rotate right one position
		bcc	shr			; branch if C-bit clear
		beq	ts13			;
shre:		mov	#16, -(R2)		; move to mailbox #16
		inc	-(R2)			; set msgtyp to fatal error
		halt				; right shift logic failed
						; or sequence error
;_____________________________________________________________________________
;
; The scratch pad tests are used to verify that various data patterns can be
; successfully held in the scratch pad circuitry. Move and compare instructions
; are used to test that.
;
; R0 can hold various data patterns. Each data pattern is moved and tested in
; a small loop convenient for scoping. The successful completion of these
; tests should verify the circuitry external to the scratch pad itself.
;
; The remainder of the general registers are tested by moving a bit into bit 0
; of the register and shifting it left one bit at a time into the carry bit.
; The result is then checked to insure that no bits were picked. The procedure
; is then repeated under opposite conditions. The general register and the carry
; bit are set to all ones. And a zero is shifted left from bit 0 into the carry
; bit. The result is then checked to insure that no zeroes were picked. At this
; point all of the general registers have been exercised as well as register 11.
;
; TEST 13 - test if R0 can hold all zeroes
;
		.sbttl	"SCRATCH AD TESTS"
						;
ts13:		inc	(R2)			; update test number
		cmp	#13, (R2)		; sequence error?
		bne	ts14-10			; br to error halt on seq error
		mov	#0, R0			; move zeroes to R0
		tst	R0			; successful?
		beq	ts14			;
		mov	#17, -(R2)		; move to mailbox #17
		inc	-(R2)			; set msgtyp to fatal error
		halt				; R0 not 0
						; or sequence error
;_____________________________________________________________________________
;
; TEST 14 - test if R0 can hold ones and zeroes
;
ts14:		inc	(R2)			; update test number
		cmp	#14, (R2)		; sequence error?
		bne	ts15-10			; br to error halt on seq error
		mov	#125252, R0		; move alternating ones and zeroes to R0
		cmp	R0, #125252		; successful?
		beq	ts15			;
		mov	#20, -(R2)		; move to mailbox #20
		inc	-(R2)			; set msgtyp to fatal error
		halt				; R0 not 125252
						; or sequence error
;_____________________________________________________________________________
;
; TEST 15 - test if R0 can hold zeroes and ones
;
ts15:		inc	(R2)			; update test number
		cmp	#15, (R2)		; sequence error?
		bne	ts16-10			; br to error halt on seq error
		mov	#052525, R0		; move alternating zeroes and ones to R0
		cmp	R0, #052525		; successful?
		beq	ts16			;
		mov	#21, -(R2)		; move to mailbox #21
		inc	-(R2)			; set msgtyp to fatal error
		halt				; R0 not 52525
						; or sequence error
;_____________________________________________________________________________
;
; TEST 16 - test if R0 can hold all ones
;
ts16:		inc	(R2)			; update test number
		cmp	#16, (R2)		; sequence error?
		bne	ts17-10			; br to error halt on seq error
		mov	#177777, R0		; move all ones to R0
		cmp	R0, #177777		; successful?
		beq	ts17			;
		mov	#22, -(R2)		; move to mailbox #22
		inc	-(R2)			; set msgtyp to fatal error
		halt				; R0 not 177777
						; or sequence error
;_____________________________________________________________________________
;
; TEST 17 - test if R1 can hold a one in all bits
;
ts17:		inc	(R2)			; update test number
		cmp	#17, (R2)		; sequence error?
		bne	ts20-10			; br to error halt on seq error
		mov	#1, R1			; set bit 0
		mov	#-21, R0		; set bit counter
		clc				; clear C-bit
reg1:		inc	R0			; increment bit counter
		beq	reg1e			; br to error halt if bit is lost
		rol	R1			; rotate 1 position
		bcc	reg1			; all done
		beq	ts20			;
reg1e:		mov	#23, -(R2)		; move to mailbox #23
		inc	-(R2)			; set msgtyp to fatal error
		halt				; failure with R1
						; or sequence error
;_____________________________________________________________________________
;
; TEST 20 - test if R1 can hold a zero in all bits
;
ts20:		inc	(R2)			; update test number
		cmp	#20, (R2)		; sequence error?
		bne	ts21-10			; br to error halt on seq error
		mov	#-2, R1			; set all ones in R1 except for bit 0
		mov	#-21, R0		; set bit counter
		sec				; set C-bit
reg1a:		inc	R0			; increment counter
		beq	R1err			; br to error halt if counter=0
		rol	R1			; rotate 1 position
		bcs	reg1a			; continue until C-bit is clear
		cmp	#-1, R1			; check data in R1
		beq	ts21			;
R1err:		mov	#24, -(R2)		; move to mailbox #24
		inc	-(R2)			; set msgtyp to fatal error
		halt				; failure with R1
						; or sequence error
;_____________________________________________________________________________
;
; TEST 21 - test if R2 can hold a one in all bits
;
ts21:		inc	(R2)			; update test number
		cmp	#21, (R2)		; sequence error?
		bne	reg2a-14		; br to error halt on seq error
		mov	#1, R2			; set bit 0
		mov	#-21, R0		; set bit counter
		clc				; clear C-bit
reg2:		inc	R0			; increment bit counter
		beq	reg2a-14		; br to error halt if bit is lost
		rol	R2			; rotate 1 position
		bcc	reg2			; all done
		beq	reg2a			;
		mov	#$testn, R2		; restore pointer
		mov	#25, -(R2)		; move to mailbox #25
		inc	-(R2)			; set msgtyp to fatal error
		halt				; failure with R2
reg2a:		mov	#$testn, R2		; restore pointer
;_____________________________________________________________________________
;
; TEST 22 - test if R2 can hold a zero in all bits
;
ts22:		inc	(R2)			; update test number
		cmp	#22, (R2)		; sequence error?
		bne	ts23-10			; br to error halt on seq error
		mov	#-2, R2			; set all ones in R2 except for bit 0
		mov	#-21, R0		; set bit counter
		sec				; set C-bit
reg2b:		inc	R0			; increment bit counter
		beq	R2err			; br to error halt if counter=0
		rol	R2			; rotate 1 position
		bcs	reg2b			; continue until C-bit is clear
		cmp	#-1, R2			; check data in R2
		beq	reg2c			;
		mov	#$testn, R2		; restore pointer
R2err:		mov	#26, -(R2)		; move to mailbox #26
		inc	-(R2)			; set msgtyp to fatal error
		halt				; failure with R2
reg2c:		mov	#$testn, R2		; restore pointer
;_____________________________________________________________________________
;
; TEST 23 - test if R3 can hold a one in all bits
;
ts23:		inc	(R2)			; update test number
		cmp	#23, (R2)		; sequence error?
		bne	ts24-10			; br to error halt on seq error
		mov	#1, R3			; set bit 0
		mov	#-21, R0		; set bit counter
		clc				; clear C-bit
reg3:		inc	R0			; increment bit counter
		beq	reg3e			; br to error halt if bit is lost
		rol	R3			; rotate 1 position
		bcc	reg3			; all done
		beq	ts24			;
reg3e:		mov	#27, -(R2)		; move to mailbox #27
		inc	-(R2)			; se1 msgtyp to fatal error
		halt				; failure with R3
						; or sequence error
;_____________________________________________________________________________
;
; TEST 24 - test if R3 can hold a zero in all bits
;
ts24:		inc	(R2)			; update test number
		cmp	#24, (R2)		; sequence error?
		bne	ts25-10			; br to error halt on seq error
		mov	#-2, R3			; set all ones in R3 except for bit 0
		mov	#-21, R0		; set bit counter
		sec				; set C-bit
reg3a:		inc	R0			; increment bit counter
		beq	R3err			; br to error halt if counter=0
		rol	R3			; rotate 1 position
		bcs	reg3a			; continue until C-bit is clear
		cmp	#-1, R3			; check data
		beq	ts25			;
R3err:		mov	#30, -(R2)		; move to mailbox #30
		inc	-(R2)			; set msgtyp to fatal error
		halt				; failure with R3
						; or sequence error
;_____________________________________________________________________________
;
; TEST 25 - test if R4 can hold a one in all bits
;
ts25:		inc	(R2)			; update test number
		cmp	#25, (R2)		; sequence error?
		bne	ts26-10			; br to error halt on seq error
		mov	#1, R4			; set bit 0
		mov	#-21, R0		; set bit counter
		clc				; clear C-bit
reg4:		inc	R0			; increment bit counter
		beq	reg4e			; br to error halt if bit is lost
		rol	R4			; rotate 1 position
		bcc	reg4			; all done
		beq	ts26			;
reg4e:		mov	#31, -(R2)		; move to mailbox #31
		inc	-(R2)			; set msgtyp to fatal error
		halt				; failure with R4
						; or sequence error
;_____________________________________________________________________________
;
; TEST 26 - test if R4 can hold a zero in all bits
;
ts26:		inc	(R2)			; update test number
		cmp	#26, (R2)		; sequence error?
		bne	ts27-10			; br to error halt on seq error
		mov	#-2, R4			; set all ones in R4 except for bit 0
		mov	#-21, R0		; set bit counter
		sec				; set C-bit
reg4a:		inc	R0			; increment bit counter
		beq	R4err			; br to error halt if counter 0
		rol	R4			; rotate 1 position
		bcs	reg4a			; continue until C-bit is clear
		cmp	#-1, R4			; check data
		beq	ts27			;
R4err:		mov	#32, -(R2)		; move to mailbox #32
		inc	-(R2)			; set msgtyp to fatal error
		halt				; failure with R4
						; or sequence error
;_____________________________________________________________________________
;
; TEST 27 - test if R5 can hold a one in all bits
;
ts27:		inc	(R2)			; update test number
		cmp	#27, (R2)		; sequence error?
		bne	ts30-10			; br to error halt on seq frror
		mov	#1, R5			; set bit 0
		mov	#-21, R0		; set bit counter
		clc				; clear C-bit
reg5:		inc	R0			; increment bit counter
		beq	reg5e			; br to error halt if bit is lost
		rol	R5			; rotate 1 position
		bcc	reg5			; all done
		beq	ts30			;
reg5e:		mov	#33, -(R2)		; move to mailbox #33
		inc	-(R2)			; set msgtyp to fatal error
		halt				; failure with R5
						; or sequence error
;_____________________________________________________________________________
;
; TEST 30 - test if R5 can hold a zero in all bits
;
ts30:		inc	(R2)			; update test number
		cmp	#30, (R2)		; sequence error?
		bne	ts31-10			; br to error halt on seq error
		mov	#-2, R5			; set all ones in R5 except for bit 0
		mov	#-21, R0		; set bit counter
		sec				; set C-bit
reg5a:		inc	R0			; increment bit counter
		beq	R5err			; br to error halt if counter=0
		rol	R5			; rotate 1 position
		bcs	reg5a			; continue until C-bit is clear
		cmp	#-1, R5			; check data
		beq	ts31			;
R5err:		mov	#34, -(R2)		; move to mailbox #34
		inc	-(R2)			; set msgtyp to fatal error
		halt				; failure with R5
						; or sequence error
;_____________________________________________________________________________
;
; TEST 31 - test if SP can hold a one in all bits
;
ts31:		inc	(R2)			; update test number
		cmp	#31, (R2)		; sequence error?
		bne	ts32-10			; br to error halt on sec error
		mov	#340, ps		; lock out interrupts while playing with SP
		mov	#1, SP			; set bit 0
		mov	#-21, R0		; set bit counter
		clc				; clear C-bit
reg6:		inc	R0			; increment bit counter
		beq	reg6e			; br to error halt if bit is lost
		rol	SP			; rotate 1 position
		bcc	reg6			; all done
		beq	ts32			;
reg6e:		mov	#35, -(R2)		; move to mailbox #35
		inc	-(R2)			; set msgtyp to fatal error
		halt				; failure with SP
						; or sequence error
;_____________________________________________________________________________
;
; TEST 32 - test if SP can hold a zero in all bits
;
ts32:		inc	(R2)			; update test number
		cmp	#32, (R2)		; sequence error?
		bne	ts33-10			; br to error halt on seq error
		mov	#-2, SP			; set all ones in SP except for bit 0
		mov	#-21, R0		; set bit counter
		sec				; set C-bit
reg6a:		inc	R0			; increment bit count
		beq	r6err			; br to error halt if counter 0
		rol	SP			; rotate 1 position
		bcs	reg6a			; continue until C-bit is clear
		cmp	#-1, SP			; check data
		beq	ts33			;
r6err:		mov	#36, -(R2)		; move to mailbox #36
		inc	-(R2)			; set msgtyp to fatal error
		halt				; failure with SP
						; or sequence error
;_____________________________________________________________________________
;
; The PSW tests are used to verify that various data patterns can be successfully
; held in the PSW and that the PSW addressing logic is functioning. Move and
; compare instructions are used to test that the PSW can hold various data
; patterns. Each data pattern is moved and tested in a small loop convenient
; for scoping.
;
; The PSW register is tested, the cc inputs are tested later in the microcode
; tests. Setting of the T-bit by the test patterns is purposely avoided.
; Testing of the T-bit trap circuitry is left for the trap test.
;
; TEST 33 - test if PSW will hold zeroes
;
		.sbttl	"PSW TESTS"
						;
ts33:		inc	(R2)			; update test number
		cmp	#33, (R2)		; sequence error?
		bne	ts34-10			; br to error halt on seq error
		mov	#stbot, SP		;
		mov	#0, @#ps		; set PSW to zero
		tst	@#ps			; successful
		beq	ts34			;
		mov	#37, -(R2)		; move to mailbox #37
		inc	-(R2)			; set msgtyp to fatal error
		halt				; PSW not 0
						; or sequence error
;_____________________________________________________________________________
;
; TEST 34 - test if PSW will hold ones and zeroes
;
ts34:		inc	(R2)			; update test number
		cmp	#34, (R2)		; sequence error?
		bne	ts35-10			; br to error halt on seq error
		mov	#252, @#ps		; move alt. ones and zeroes to PSW
		cmp	@#ps, #252		; successful?
		beq	ts35			;
		mov	#40, -(R2)		; move to mailbox #40
		inc	-(R2)			; set msgtyp to fatal error
		halt				; PSW not 252
						; or sequence error
;_____________________________________________________________________________
;
; TEST 35 - test if PSW (except T-bit) will hold zeroes and ones
;
ts35:		inc	(R2)			; update test number
		cmp	#35, (R2)		; sequence error?
		bne	ts36-10			; br to error halt on seq error
		mov	#105, @#ps		; move alt. ones and zeroes to PSW
		cmp	@#ps, #105		; successful?
		beq	ts36			;
		mov	#41, -(R2)		; move to mailbox #41
		inc	-(R2)			; set msgtyp to fatal error
		halt				; PSW not 105
						; or sequence error
;_____________________________________________________________________________
;
; TEST 36 - test if PSW (except T-bit) will hold all ones
;
ts36:		inc	(R2)			; update test number
		cmp	#36, (R2)		; sequence error?
		bne	ts37-10			; br to error halt on seq error
		mov	#357, @#ps		; move ones to PSW
		cmp	@#ps, #357		; successful
		beq	ts37			;
		mov	#42, -(R2)		; move to mailbox #42
		inc	-(R2)			; set msgtyp to fatal error
		halt				; PSW not 357
						; or sequence error
;_____________________________________________________________________________
;
; This test checks the conditional branches involving the Z-bit. The Z-bit is
; set with all other cc bits zero and both conditions beq and bne are tested
; for proper execution. Then the Z-bit is set with all other cc bits clear
; and both conditions are tested again for proper operation,
;
; This test checks the operation of the set and clear condition code instructions
; and checks the circuitry external to the conditional branch ROM. The branch
; microcode for altering the PC and for leaving the PC unaltered is tested.
; Only those ROM addresses specifically used in the test are verified here.
;
; TEST 37 - test branches around Z-bit
;
		.sbttl	"CONDITION CODE TEST"
						;
ts37:		inc	(R2)			; update test number
		cmp	#37, (R2)		; sequence error?
		bne	ts40-10			; br to error halt on seq error
						; first with Z-bit on
		ccc				; cc=0100: just Z-bit
		sez				;
		bne	brz1			; check opposite condition
		beq	brz2			;
brz1:		mov	#43, -(R2)		; move to mailbox #43
		inc	-(R2)			; set msgtyp to fatal error
		halt				; improper br w/ 2-1
						; check with Z-bit off
brz2:		scc				; cc=1011: all but Z-bit
		clz				;
		beq	brz3			;
		bne	ts40			;
brz3:		mov	#44, -(R2)		; move to mailbox #44
		inc	-(R2)			; set msgtyp to fatal error
		halt				; improper br w/ Z=0
						; or sequence error
;_____________________________________________________________________________
;
; This test checks the conditional branches involving the N-bit. The N-bit is
; set with all other cc bits zero and both conditions bmi and bpl are tested
; for proper execution. Then the N-bit is set with all other cc bits clear
; and both conditions are tested again for proper operation.
;
; This test checks the operation of the set and clear condition code instructions
; and checks the circuitry external to the conditional branch ROM. The branch
; microcode for altering the PC and for leaving the PC unaltered is tested.
; Only those rom addresses specifically used in the test are verified here.
;
; TEST 40 - test branches around N-bit
;
ts40:		inc	(R2)			; update test number
		cmp	#40, (R2)		; sequence error?
		bne	ts41-10			; br to error halt on seq error
						; first with N-bit on
		ccc				; cc=1000: just N-bit
		sen				;
		bpl	brn1			; check opposite condition
		bmi	brn2			;
brn1:		mov	#45, -(R2)		; move to mailbox #45
		inc	-(R2)			; set m3gtyp to fatal error
		halt				; improper br w/ N=1
						; check with N-bit off
brn2:		scc				; cc=0111
		cln				;
		bmi	brn3			; check opposite condition
		bpl	ts41			;
brn3:		mov	#46, -(R2)		; move to mailbox #46
		inc	-(R2)			; set msgtyp to fatal error
		halt				; improper br w/ N=0
						; or sequence error
;_____________________________________________________________________________
;
; This test checks the conditional branches involving the V-bit. The V-bit is
; set with all other cc bits zero and both conditions bvs and bvc are tested
; for proper execution. Then the V-bit is set with all other cc bits clear
; and both conditions are tested again for proper operation.
;
; TEST 41 - test branches around V-bit
;
ts41:		inc	(R2)			; update test number
		cmp	#41, (R2)		; sequence error?
		bne	ts42-10			; br to error halt on seq error
						; first with V-bit on
		ccc				; cc=0010: just V-bit
		sev				;
		bvc	brv1			; check opposite condition
		bvs	brv2			;
brv1:		mov	#47, -(R2)		; move to mailbox #47
		inc	-(R2)			; set msgtyp to fatal error
		halt				; improper br w/ V=1
						; check with V-bit off
brv2:		scc				; cc=1101: all bvt V-bit
		clv				;
		bvs	brv3			; check opposite condition
		bvc	ts42			;
brv3:		mov	#50, -(R2)		; move to mailbox #50
		inc	-(R2)			; set msgtyp to fatal error
		halt				; improper br w/ V=0
						; or sequence error
;_____________________________________________________________________________
;
; This test checks the conditional branches involving the C-bit. The C-bit is
; set with all other cc bits zero and both conditions bcs and bcc are tested
; for proper execution. Then the C-bit is set with all other cc bits clear
; and both conditions are tested again for proper operation.
;
; TEST 42 - test branches around C-bit
;
ts42:		inc	(R2)			; update test number
		cmp	#42, (R2)		; sequence error?
		bne	ts43-10			; br to error halt on seq error
						; first with C-bit on
		ccc				; cc=0001: just C-bit
		sec				;
		bcc	brc1			; check opposite condition
		bcs	brc2			;
brc1:		mov	#51, -(R2)		; move to mailbox #51
		inc	-(R2)			; set msgtyp to fatal error
		halt				; improper br w/ C=1
						; check with C-bit off
brc2:		scc				; cc=1110
		clc				;
		bcs	brc3			; check opposite condition
		bmi	ts43			;
brc3:		mov	#52, -(R2)		; move to mailbox #52
		inc	-(R2)			; set msgtyp to fatal error
		halt				; improper br w/ C=0
						; or sequence error
;_____________________________________________________________________________
;
; The test exercises branches in the microcode by testing at least one
; instruction from every class of instruction in all possible modes.
; For example, to test the single operand instructions, at least one single
; operand instruction is verified in all unique addressing modes. Byte modes
; are also tested. As each new mode is introduced the same instruction is
; tried and tested in a small loop convenient for scoping. The test is set
; up using only instructions and addressing modes which have been previously
; verified. If these tests fail, check the results for a clue to the fault.
;
; The clr instruction is used to introduce each addressing mode with
; the single operand instruction. Following the sequence check, the clr
; instruction is executed and a branch test is executed which checks that
; the Z-bit was properly set. This test can check IR decode and microcode
; for sop instructions with mode 0. Following this test several other
; sop instructions are introduced with mode 0. These instructions mainpulate
; data and serve to check the data results of the sop instructions in this
; test. The data in this test is operated on by each instruction without
; reinitializing.
;
; TEST 43 - test mode 0 using sop inst.
;
		.sbttl	"MICROCODE TESTS"
						;
ts43:		inc	(R2)			; update test number
		cmp	#43, (R2)		; sequence error?
		bne	ts44-10			; br to error halt on seq error
		clr	R0			; try the clear inst.
		beq	sopoa			;
		mov	#53, -(R2)		; move to mailbox #53
		inc	-(R2)			; set msgtyp to fatal error
		halt				; clr did not set Z-bit
						;
sopoa:		inc	R0			; try the increment inst.
		com	R0			; try complement
		inc	R0			;
		bmi	sop0b			;
		mov	#54, -(R2)		; move to mailbox #54
		inc	-(R2)			; set msgtyp to fatal error
		halt				; negate did not set N-bit
						;
sop0b:		com	R0			; try complement inst.
		beq	ts44			;
		mov	#55, -(R2)		; move to mailbox #55
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cummulative result of clr.inc,
						; neg and com insts. failed
						; or sequence error
;_____________________________________________________________________________
;
; This test introduces the remaining sop instructons and tests them in mode 0.
; The purpose is to provide a baseline of instructions for use in the subsequent
; tests. Since the microcode for these instructions is identical to that already
; tested, any troubleshooting efforts should be aimed at the actual IR decode
; and ALU functioning.
;
; TEST 44 - test remainder of sop insts in mode 0
;
ts44:		inc	(R2)			; update test number
		cmp	#44, (R2)		; sequence error?
		bne	ts45-10			; br to error halt on seq error
		clr	R0			; initialize
		dec	R0			; try decrement inst.
		bmi	sop0c			;
		mov	#56, -(R2)		; move to mailbox #56
		inc	-(R2)			; set msgtyp to fatal error
		halt				; N-bit not set on dec
						;
sop0c:		sec				; initialize carry
		adc	R0			; try add carry inst
		bne	sop0d			;
		sec				; initialize carry
		sbc	R0			; try subtract-carry inst
		bpl	sop0d			;
		com	R0			;
		inc	R0			;
		dec	R0			;
		beq	ts45			;
sop0d:		mov	#57, -(R2)		; move to mailbox #57
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cummulative result of adc.sbc.com,
						; inc and dec insts.
						; or sequence error
;_____________________________________________________________________________
;
; This test introduces the byte control logic of the processor. The mode 0 byte
; microcode is tested. The method and sequence of testing is the same as that
; used in the sop mode 0 tests.
;
; TEST 45 - test mode 0 even byte using sop inst
;
ts45:		inc	(R2)			; update test number
		cmp	#45, (R2)		; sequence error?
		bne	ts46-10			; br to error halt on seq error
		clrb	R0			; try clearing even byte of register
		beq	sopb0a			;
		mov	#60, -(R2)		; move to mailbox #60
		inc	-(R2)			; set msgtyp to fatal error
		halt				; clrb did not set Z-bit
						;
sopb0a:		comb	R0			; try setting even byte of register
		bpl	sopb0b			;
		incb	R0			; try incrementing even byte of registers
		beq	ts46			;
sopb0b:		mov	#61, -(R2)		; move to mailbox #61
		inc	-(R2)			; set msgtyp to fatal error
		halt				; test cummulative result of above byte inst.
						; or sequence error
;_____________________________________________________________________________
;
; This test uses the clr instruction to introduce and test single operand mode 1
; instructions. again, the clr instruction is used to introduce the microcode and
; to test that the proper condition codes are set. Other sop instructions are used
; to manipulate common data to verify that the correct data is produced.
;
; TEST 46 - test mode 1 using sop inst.
;
ts46:		inc	(R2)			; update test number
		cmp	#46, (R2)		; sequence error?
		bne	ts47-10			; br to error halt on seq error
		clr	R0			; initialize R0
		clr	(R0)			; try clear inst w/ mode 1
		beq	sop1a			;
		mov	#62, -(R2)		; move to mailbox #62
		inc	-(R2)			; set msgtyp to fatal error
		halt				; clr did not set Z-bit
						;
sop1a:		dec	(R0)			; try decrement inst w/ mode 1
		bpl	sop1b			;
		sec				; initialize carry
		adc	(R0)			; try add-carry w/ mode 1
		beq	ts47			;
sop1b:		mov	#63, -(R2)		; move to mailbox #63
		inc	-(R2)			; set msgtyp to fatal error
		halt				; test cummulative result of above inst
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies the byte instruction microcode for mode 1 single operand
; instructions. This is the first place the sign extend logic is exercised
; and verified.
;
; TEST 47 - test mode 1 even byte using sop inst
;
ts47:		inc	(R2)			; update test number
		cmp	#47, (R2)		; sequence error?
		bne	ts50-10			; br to error halt on seq error
		clr	R0			; initialize R0
		clr	(R0)			; initialize loc.0
		com	(R0)			;
		clrb	(R0)			; try to clear byte 0
		beq	sopb1a			;
		mov	#64, -(R2)		; move to mailbox #64
		inc	-(R2)			; set msgtyp to fatal error
		halt				; clrb did not set Z-bit
						;
sopb1a:		inc	(R0)			; increment to test word
		bpl	sopb1b			;
		comb	(R0)			; complement: odd byte 376
		incb	(R0)			; inc: odd byte = 377
		bpl	sopb1b			;
		incb	(R0)			; increment odd byte=0
		beq	ts50			;
sopb1b:		mov	#65, -(R2)		; move to mailbox #65
		inc	-(R2)			; set msgtyp to fatal error
		halt				; check cummulative result of above inst
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies that single operand byte instructions will function
; correctly for odd bytes. This is the first time that address line 0 has
; been exercised. Checks are made that the proper byte is modified and
; the condition codes are lhlcked. it is also verified that the unaddressed
; byte is not altered by the instruction.
;
; TEST 50 - test mode 1 odd byte using sop inst
;
ts50:		inc	(R2)			; update test number
		cmp	#50, (R2)		; sequence error?
		bne	ts51-10			; br to error halt on seq error
		clr	R0			; initialize R0
		clr	(R0)			; initialize loc.0
		com	(R0)			;
		inc	R0			; R0=odd byte
		clrb	(R0)			; try to clear byte 1
		beq	sopb1c			;
		mov	#66, -(R2)		; move to mailbox #66
		inc	-(R2)			; set msgtyp to fatal error
		halt				; clrb did not set Z-bit
						;
sopb1c:		dec	R0			; R0=word addr.
		inc	(R0)			; increment to test word
		inc	R0			; R0=odd byte
		comb	(R0)			; try to complement byte 1
		incb	(R0)			;
		bpl	sopb1d			;
		incb	(R0)			; try to increment byte 1
		beq	ts51			;
sopb1d:		mov	#67, -(R2)		; move to mailbox #67
		inc	-(R2)			; set msgtyp to fatal error
		halt				; test cummulative result of above inst.
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 2 single-operand instructions. Previously tested
; instructions are used to set a pointer in R0 to loc.400. Loc.400 is initialized
; to -1 before a clr mode 2 is executed. Then R0 is decremented by two to again
; point to 400 before each of several mode 2 instructions are user to verify
; the data results of the test. This procedure also verifies the proper incrementing
; of the register.
;
; TEST 51 - test mode 2 using sop inst.
;
ts51:		inc	(R2)			; update test number
		cmp	#51, (R2)		; sequence error?
		bne	ts52-10			; br to error halt on seq error
		clr	R0			; set R0=400
		comb	R0			;
		inc	R0			;
		clr	(R0)			; clear 400
		com	(R0)			; initialize: 400=-1
		clr	(R0)+			; try clearing with mode 2
		beq	sopza			;
		mov	#70, -(R2)		; move to mailbox #70
		inc	-(R2)			; set msgtyp to fatal error
		halt				; clr inst did not set Z-bit
						;
sopza:		dec	R0			; reset R0
		dec	R0			;
		com	(R0)+			; try complementing with mode 2
		bpl	sop2b			;
		dec	R0			; reset R0
		dec	R0			;
		inc	(R0)+			; try incrementing with mode 2
		beq	ts52			;
sop2b:		mov	#71, -(R2)		; move to mailbox #71
		inc	-(R2)			; set msgtyp to fatal error
		halt				; check cummulative result of above inst
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 2 single operand instructions which address even bytes.
; R0 is set to 400 and used to initialize location 400 to -1. clrb instruction is
; then executed on byte 400 with mode 2. R0 is then decremented before each
; of several mode 2 instructions which are used to verify the data results of
; the test. This procedure also verifies the proper incrementing of the register.
;
; TEST 52 - test mode 2 even byte using sop inst.
;
ts52:		inc	(R2)			; update test number
		cmp	#52, (R2)		; sequence error?
		bne	ts53-10			; br to error halt on seq error
		clr	R0			; set R0=400
		comb	R0			;
		inc	R0			;
		clr	(R0)			; clear 400
		com	(R0)			; initialize: 400=-1
		clrb	(R0)+			; try to clear 400 w/ mode 2
		beq	sopb2a			;
		mov	#72, -(R2)		; move to mailbox #72
		inc	-(R2)			; set msgtyp to fatal error
		halt				; clr did not set Z-bit
						;
sopb2a:		dec	R0			; result R0=400
		inc	(R0)			; inc 400 to test word
		comb	(R0)			;
		incb	(R0)+			; try to inc even byte
		bpl	sopb2b			;
		dec	R0			; reset R0=400
		incb	(R0)+			; try increment of even byte
		beq	ts53			;
sopb2b:		mov	#73, -(R2)		; move to mailbox #73
		inc	-(R2)			; set msgtyp to fatal error
		halt				; test cummulative result of above inst.
						; or sequence error
;_____________________________________________________________________________
;
; This test follows the same procedure described in the previous test here,
; The byte instruction is used to address an odd byte.
;
; TEST 53 - test mode 2 odd byte using sop inst.
;
ts53:		inc	(R2)			; update test number
		cmp	#53, (R2)		; sequence error?
		bne	ts54-10			; br to error halt on seq error
		clr	R0			; set R0=400
		comb	R0			;
		inc	R0			;
		clr	(R0)			; clear loc.400
		com	(R0)			; initialize: 400=1
		inc	R0			; R0=odd byte
		clrb	(R0)+			; try to clear odd byte
		beq	sopb2c			;
		mov	#74, -(R2)		; move to mailbox #74
		inc	-(R2)			; set msgtyp to fatal error
		halt				; clrb did not set Z-bit
						;
sopb2c:		dec	R0			; R0=word addr.
		dec	R0			;
		inc	(R0)+			; increment word
		dec	R0			; point to odd byte
		comb	(R0)			; complement odd byte
		incb	(R0)+			; try to increment odd byte
		bpl	sopb2d			;
		dec	R0			; reset R0 to odd byte
		incb	(R0)+			; try to increment odd byte
		beq	ts54			;
sopb2d:		mov	#75, -(R2)		; move to mailbox #75
		inc	-(R2)			; set msgtyp to fatal error
		halt				; test cummulative result of above inst.
						; or sequence error
;_____________________________________________________________________________
;
; These tests check the negate instruction in all modes. Previously
; tested single-operand instructions are used to test the negate instruction.
;
; TEST 54 - test mode 0 using negate instruction
;
ts54:		inc	(R2)			; update test number
		cmp	#54, (R2)		; sequence error?
		bne	ts55-10			; br to error halt on seq error
		clr	R0			; set R0=0
		inc	R0			; R0=1
		neg	R0			; try negate mode 0: R0=1
		bpl	neg00			; cc=1001?
		beq	neg00			;
		bvs	neg00			;
		bcs	neg01			;
neg00:		mov	#76, -(R2)		; move to mailbox #76
		inc	-(R2)			; set msgtyp to fatal error
		halt				; negate did not set cc's correctly
						;
neg01:		inc	R0			; test data result
		beq	neg02			;
		mov	#77, -(R2)		; move to mailbox #77
		inc	-(R2)			; set msgtyp to fatal error
		halt				; data result of negate incorrect
						;
neg02:		comb	R0			; R0=377
		negb	R0			; R0=1
		bmi	neg03			; cc=0001?
		beq	neg03			;
		bvs	neg03			;
		bcs	neg04			;
neg03:		mov	#100, -(R2)		; move to mailbox #100
		inc	-(R2)			; set msgtyp to fatal error
		halt				; negb did not set cc's correctly
						;
neg04:		dec	R0			; test data result
		beq	ts55			;
		mov	#101, -(R2)		; move to mailbox #101
		inc	-(R2)			; set msgtyp to fatal error
		halt				; data result of negb incorrect
						; or sequence error
;_____________________________________________________________________________
;
; TEST 55 - test mode 1 using negate inst.
;
ts55:		inc	(R2)			; update test number
		cmp	#55, (R2)		; sequence error?
		bne	ts56-10			; br to error halt on seq error
		clr	R0			; point to loc.0
		clr	(R0)			; clear loc.0
		inc	(R0)			; loc.0=1
		neg	(R0)			; try neg. loc.0=-1
		bpl	neg10			; cc=1001
		beq	neg10			;
		bvs	neg10			;
		bcs	neg11			;
neg10:		mov	#102, -(R2)		; moveto mailbox #102
		inc	-(R2)			; set msgtyp to fatal error
		halt				; negate did not set cc's correctly
						;
neg11:		inc	@#0			; test data result
		beq	neg12			;
		mov	#103, -(R2)		; move to mailbox #103
		inc	-(R2)			; set msgtyp to fatal error
		halt				; data result of negate incorrect
						;
neg12:		comb	(R0)			; loc.0=377
		negb	(R0)			; try negb loc.0=1
		bmi	neg13			; cc=0001?
		beq	neg13			;
		bvs	neg13			;
		bcs	neg14			;
neg13:		mov	#104, -(R2)		; move to mailbox #104
		inc	-(R2)			; set msgtyp to fatal error
		halt				; negb did not set cc's correctly
						;
neg14:		dec	@#0			; test data result
		beq	ts56			;
		mov	#105, -(R2)		; move to mailbox #105
		inc	-(R2)			; set msgtyp to fatal error
		halt				; data result of negb incorrect
						; or sequence error
;_____________________________________________________________________________
;
; TEST 56 - test mode 2 using negate instruction
;
ts56:		inc	(R2)			; update test number
		cmp	#56, (R2)		; sequence error?
		bne	ts57-10			; br to error halt on seq error
		clr	R0			; point to loc.0
		clr	(R0)			; clear loc.0
		inc	(R0)			; loc.0=1
		neg	(R0)+			; try neg.: loc.0=-1
		bpl	neg20			; cc=1001?
		beq	neg20			;
		bvs	neg20			;
		bcs	neg21			;
neg20:		mov	#106, -(R2)		; move to mailbox #106
		inc	-(R2)			; set msgtyp to fatal error
		halt				; negate did not set cc's correctly
						;
neg21:		decb	R0			; R0=loc.0
		decb	R0			;
		negb	(R0)+			; byte 0=1 R0=1
		negb	(R0)+			; byte 1=1 R0=2
		decb	-(R0)			; R0=1 loc.0=01
		dec	R0			; R0=0
		beq	neg22			;
		mov	#107, -(R2)		; move to mailbox #107
		inc	-(R2)			; set msgtyp to fatal error
		halt				; register not incremented correctly
						;
neg22:		dec	@#0			; loc.0=0
		beq	ts57			;
		mov	#110, -(R2)		; move to mailbox #110
		inc	-(R2)			; set msgtyp to fatal error
		halt				; neg byte instructions failed
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 3 single operand instructions. It uses location 0 as its
; target data, a table located at loc.400 thru 402 is used to supply the address
; of location 0 to the instructions under test.
;
; R0 is set to 400, the start of the address table. and a clr instruction is executed
; with mode 3 to clear loc.0. then R0 is decremented by two and two other mode 3
; instructions operate on loc.0 to verify the data results of the test. The proper
; incrementing of the register is also verified in this manner. If a failure is
; detected be sure to verify that the table (loc.400-402) has the proper values (0).
;
; TEST 57 - test mode 3 using sop inst.
;
ts57:		inc	(R2)			; update test number
		cmp	#57, (R2)		; sequence error?
		bne	ts60-10			; br to error halt on seq error
		clr	R0			; set R0=400
		comb	R0			;
		inc	R0			;
		clr	(R0)			; clear loc.400
		clr	@(R0)+			; try to clear loc.0 using mode 3; R0=402
		beq	sop3a			;
		mov	#111, -(R2)		; move to mailbox #111
		inc	-(R2)			; set msgtyp to fatal error
		halt				; clr did not set Z-bit
						;
sop3a:		dec	R0			; reset R0=400
		dec	R0			;
		com	@(R0)+			; try to complement loc.0 of mode 3; R0=402
		bpl	sop3b			;
		inc	@(R0)+			; try to increment loc.0 w/ mode 3; R0=404
		beq	ts60			;
sop3b:		mov	#112, -(R2)		; move to mailbox #112
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cummulative result of above inst failed
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 3 single operand byte instructions which address even
; bytes. Again, the target location 0 is used and the same table at 400 is employed.
; After pointing R4 to the table (400) and setting location 0 to -1, a clrb instruction
; is used to clear byte 0.
;
; Several other mode 3 instructions are then used with the table to verify the data
; results and the proper incrementing of the register. If a failure is detected,
; be sure that the table (location 400-402) has the proper values (0).
;
; TEST 60 - test mode 3 even byte using sop inst.
;
ts60:		inc	(R2)			; update test number
		cmp	#60, (R2)		; sequence error?
		bne	ts61-10			; br to error halt on seq error
		clr	R4			; set R4=400
		comb	R4			;
		inc	R4			;
		clr	R0			; initialize loc.0=-1
		clr	(R0)			;
		com	(R0)			; loc.0=-1
		clrb	@(R4)+			; try to clear even byte, loc.0-177400 R4=402
		beq	sopb3a			;
		mov	#113, -(R2)		; move to mailbox #113
		inc	-(R2)			; set msgtyp to fatal error
		halt				; clrb did not set Z-bit
						;
sopb3a:		dec	R4			; reset pointer R4=400
		dec	R4			;
		inc	@(R4)+			; try incrementing word, loc.0=177401 R4=402
		bpl	sopb3b			;
		negb	@(R4)+			; try to negate even byte, loc.0=-1 R4=404
		bpl	sopb3b			;
		dec	R4			; R4=402
		dec	R4			;
		incb	@(R4)+			; try to increment even byte, loc.0=17400
		beq	ts61			;
sopb3b:		mov	#114, -(R2)		; move to mailbox #114
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cummulative result of above inst failed
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 3 single operand byte instructions which address odd bytes.
; The target is byte 1. a table at loc.400-406 is used. R0 serves as the table pointer.
; R0 is initialized to 400. loc.0 is set to -1 using the first two table entries. 
;
; A clrb mode 3 is executed on byte 1 using table address at 404. R0 is decremented
; to 402 and several sop mode 3 instructions are used to verify data results and
; proper register incrementing.
;
; The table (400-406) should contain 0, 0, 1, 1 before and after the test is run.
;
; TEST 61 - test mode 3 odd byte using sop inst.
;
ts61:		inc	(R2)			; update test number
		cmp	#61, (R2)		; sequence error?
		bne	ts62-10			; br to error halt on seq error
		clr	R0			; set R0=400
		comb	R0			;
		inc	R0			;
		clr	@(R0)+			; initialize
		com	@(R0)+			; loc.0=-1 R0=404
		clrb	@(R0)+			; try to clear odd byte loc.0=377 R0=406
		beq	sopb3c			;
		mov	#115, -(R2)		; move to mailbox #115
		inc	-(R2)			; set msgtyp to fatal error
		halt				; clrb did not set Z-bit
sopb3c:		dec	R0			; reset R0=402
		dec	R0			;
		dec	R0			; point to even byte addr.
		dec	R0			;
		inc	@(R0)+			; increment word loc.0=400 R0=404
		negb	@(R0)+			; try to negate odd byte loc.0-177400 R0=406
		bpl	sopb3d			;
		incb	@(R0)+			; try to increment odd byte loc.0=0 R0=410
		beq	ts62			;
						;
sopb3d:		mov	#116, -(R2)		; move to mailbox #116
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cummulative result of above insts failed
						; or sequence error
;_____________________________________________________________________________
;
; TEST 62 - test mode 3 using negate instruction
;
ts62:		inc	(R2)			; update test number
		cmp	#62, (R2)		; sequence error?
		bne	ts63-10			; br to error halt on seq error
		clr	R0			; R0=400
		comb	R0			;
		inc	R0			;
		clr	(R0)			; loc.400=0
		clr	R4			; R4=0
		clr	(R4)			; loc.0=0
		inc	(R4)			; loc.0=1
		neg	@(R0)+			; try negate loc.0=-1 R0=402
		bpl	neg30			; cc=1001?
		beq	neg30			;
		bvs	neg30			;
		bcs	neg31			;
						;
neg30:		mov	#117, -(R2)		; move to mailbox #117
		inc	-(R2)			; set msgtyp to fatal error
		halt				; neg did not set cc's correctly
						;
neg31:		inc	(R4)			; loc.0=0
		beq	neg32			;
		mov	#120, -(R2)		; move to mailbox #120
		inc	-(R2)			; set msgtyp to fatal error
		halt				; data result of neg incorrect
						;
neg32:		comb	@#1			; loc.0=177400
		inc	@#0			; loc.0=177401
		negb	@(R0)+			; try negb loc.0=177777 R0=404
		bmi	neg33			;
		mov	#121, -(R2)		; move to mailbox #121
		inc	-(R2)			; set msgtyp to fatal error
		halt				; negb failed with even byte
						;
neg33:		negb	@(R0)+			; try negb loc.0=777 R0=406
		bpl	neg34			;
		mov	#122, -(R2)		; move to mailbox #122
		inc	-(R2)			; set msgtyp to fatal error
		halt				; negb failed with odd byte
neg34:		comb	@#1			; loc.0=177377
		incb	@#1			; loc.0=177777
		inc	(R4)			; loc.0=0
		beq	ts63			;
		mov	#123, -(R2)		; move to mailbox #123
		inc	-(R2)			; set msgtyp to fatal error
		halt				; data result of negb's incorrect
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 4 single operand instructions. R0 is set to 400.
; A clr instruction is executed in mode 4 to clear loc.376. R0 is reset to
; 400 and a com instruction using mode 4 complements loc.376.
;
; Two inc instructions and a mode 4 instruction are executed to complete the test.
;
; TEST 63 - test mode 4 using sop insts
;
ts63:		inc	(R2)			; update test number
		cmp	#63, (R2)		; sequence error?
		bne	ts64-10			; br to error halt on seq error
		clr	R0			; set R0=400
		comb	R0			;
		inc	R0			;
		clr	-(R0)			; try to clear using mode 4
		beq	sop4a			;
		mov	#124, -(R2)		; move to mailbox #124
		inc	-(R2)			; set msgtyp to fatal error
		halt				; clr did not set Z-bit
						;
sop4a:		inc	R0			; re set R0
		inc	R0			;
		com	-(R0)			; try to complement using mode 4
		bpl	sop4b			;
		inc	R0			; move pointer
		inc	R0			;
		inc	-(R0)			;
		beq	ts64			;
						;
sop4b:		mov	#125, -(R2)		; move to mailbox #125
		inc	-(R2)			; set msgtyp to fatal error
		halt				; check cummulative result of above inst.
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 5 single operand instructions. It uses location 0 as
; its target data. A table located at loc.372 thru 374 is used to supply the
; address of location 0 to the instructions under test.
;
; R0 is set to 376, (the start of the address table) +2, and a clr instruction
; is executed with mode 3 to clear loc.0. Then R0 is incremented by two and
; two other mode 3 instructions operate on loc.0 to verify the data results of
; the test. The proper decrementing of the register is also verified in this
; manner.If a failure is detected be sure to verify that the table (loc.372
; thru 374) has the proper values (0).
;
; TEST 64 - test mode 5 using sop insts
;
ts64:		inc	(R2)			; update test number
		cmp	#64, (R2)		; sequence error?
		bne	ts65-10			; br to error halt on seq error
		mov	#370, R0		; clear location 370-376
		clr	(R0)+			; 370
		clr	(R0)+			; 372
		clr	(R0)+			; 374
		clr	(R0)			; 376
		clr	R0			; set R0=376 (low byte)
		clr	(R0)+			;
		negb	R0			;
		clr	@-(R0)			; try to clear loc.0 w/ mode 5
		beq	sop5a			;
		mov	#126, -(R2)		; move to mailbox #126
		inc	-(R2)			; set msgtyp to fatal error
		halt				; clr did not set Z-bit
						;
sop5a:		inc	R0			; reset R0
		inc	R0			;
		com	@-(R0)			; try to complement loc.0 w/ mode 5
		bpl	sop5b			;
		inc	@-(R0)			; try to increment loc.0 w/ mode 5
		beq	ts65			;
						;
sop5b:		mov	#127, -(R2)		; move to mailbox #127
		inc	-(R2)			; set msgtyp to fatal error
		halt				; test cummulative result of above insts
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 6 single operand instructions. It uses location 0 as
; its target data. R0 is set to 400 using previously tested instructions and
; a mode 6 clr instruction is executed on loc.0 using R0 and a -400 offset.
; com and inc instructions are then used to verify the data.
;
; TEST 65 - test mode 6 using sop insts
;
ts65:		inc	(R2)			; update test number
		cmp	#65, (R2)		; sequence error?
		bne	ts66-10			; br to error halt on seq error
		clr	R0			; set R0=400
		comb	R0			;
		inc	R0			;
		clr	-400(R0)		; try to clear location 0 w/ mode 6
		beq	sop6a			;
		mov	#130, -(R2)		; move to mailbox #130
		inc	-(R2)			; set msgtyp to fatal error
		halt				; clr did not set Z-bit
						;
sop6a:		com	-400(R0)		; try to complement location 0 w/ mode 6
		bpl	sop6b			;
		inc	-400(R0)		; try to increment location 0 w/ mode 6
		beq	ts66			;
						;
sop6b:		mov	#131, -(R2)		; move to mailbox #131
		inc	-(R2)			; set msgtyp to fatal error
		halt				; test cummulative result of above insts
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 7 single operand instructions. It uses
; the pointer to loc.0 which is stored at loc.402.
; R0 is set to 400 and a mode 7 clr instruction is
; executed with a +2 offset to clear loc.0.
; Several other mode 7 instructions are then used on the common
; location to verify the data results.
;
; TEST 66 - test mode 7 using sop inst.
;
ts66:		inc	(R2)			; update test number
		cmp	#66, (R2)		; sequence error?
		bne	ts67-10			; br to error halt on seq error
		clr	R0			; set R0=400
		comb	R0			;
		inc	R0			;
		inc	(R0)			; R0=1
		clr	@2(R0)			; try to clear loc.0 w/ mode 7
		beq	sop7a			;
		mov	#132, -(R2)		; move to mailbox #132
		inc	-(R2)			; set msgtyp to fatal error
		halt				; clr did not set Z-bit
sop7a:		com	@2(R0)			; try to complement loc.0 w/ mode 7
		bpl	sop7b			;
		inc	@2(R0)			; try to increment loc.0 w/ mode 7
		beq	ts67			;
sop7b:						;
		mov	#133, -(R2)		; move to mailbox #133
		inc	-(R2)			; set msgtyp to fatal error
		halt				; test cummulative result of above insts.
						; or sequence error
;_____________________________________________________________________________
;
; TEST 67 - test mode 4 with negate instruction
;
ts67:		inc	(R2)			; update test number
		cmp	#67, (R2)		; sequence error?
		bne	ts70-10			; br to error halt on seq error
		clr	R0			;
		clr	(R0)			;
		com	(R0)+			; loc.0=177777, R0=2
		neg	-(R0)			; try negate, loc.0-1
		bmi	neg40			; cc=0001?
		beq	neg40			;
		bvs	neg40			;
		bcs	neg41			;
neg40:						;
		mov	#134, -(R2)		; move to mailbox #134
		inc	-(R2)			; set msgtyp to fatal error
		halt				; neg did not set cc's correctly
neg41:		neg	R0			; tst R0 with a neg.
		beq	neg42			;
		mov	#135, -(R2)		; move to mailbox #135
		inc	-(R2)			; set msgtyp to fatal error
		halt				; R0 not decremented properly
neg42:		dec	(R0)			; test dta result of neg
		beq	ts70			;
		mov	#136, -(R2)		; move to mailbox #136
		inc	-(R2)			; set msgtyp to fatal error
		halt				; data result of neg incorrect
						; or sequence error
;_____________________________________________________________________________
;
; TEST 70 - test mode 5 with negate instruction
;
ts70:		inc	(R2)			; update test number
		cmp	#70, (R2)		; sequence error?
		bne	ts71-10			; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; loc.0=0
		comb	R0			; R0=377
		inc	R0			; R0=400
		clr	(R0)			; set 400=0
		clr	R4			; R4=0
		dec	(R4)			; loc.0=177777
		neg	@-(R0)			; try negate: loc.0=1
		bmi	neg50			; cc=0001?
		beq	neg50			;
		bvs	neg50			;
		bcs	neg51			;
neg50:						;
		mov	#137, -(R2)		; move to mailbox #137
		inc	-(R2)			; set msgtyp to fatal error
		halt				; neg did not set cc's correctly
neg51:		dec	(R4)			;
		beq	neg52			;
		mov	#140, -(R2)		; move to mailbox #140
		inc	-(R2)			; set msgtyp to fatal error
		halt				; data result of neg incorrect
neg52:		comb	R0			;
		dec	R0			;
		beq	ts71			;
		mov	#141, -(R2)		; move to mailbox #141
		inc	-(R2)			; set msgtyp to fatal error
		halt				; register not decremented properly
						; or sequence error
;_____________________________________________________________________________
;
; TEST 71 - test mode 6 with negate
;
ts71:		inc	(R2)			; update test number
		cmp	#71, (R2)		; sequence error?
		bne	ts72-10			; br to error halt on seq error
		clr	R0			; R0=0
		clr	R4			; R4=0
		comb	R0			; R0=377
		clr	(R4)			; loc.0=0
		clrb	(R4)+			; loc.0=177777, R4=1
		comb	(R4)			; loc.0=177400
		neg	-377(R0)		; loc.0=400
		bmi	neg60			; cc=0001
		beq	neg60			;
		bvs	neg60			;
		bcs	neg61			;
neg60:						;
		mov	#142, -(R2)		; move to mailbox #142
		inc	-(R2)			; set msgtyp to fatal error
		halt				; neg did not set cc's correctly
neg61:		decb	(R4)			;
		beq	ts72			;
		mov	#143, -(R2)		; move to mailbox #143
		inc	-(R2)			; set msgtyp to fatal error
		halt				; data result of neg incorrect
						; or sequence error
;_____________________________________________________________________________
;
; TEST 72 - test mode 7 w/ negate
;
ts72:		inc	(R2)			; update test number
		cmp	#72, (R2)		; sequence error?
		bne	ts73-10			; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; loc.0=0
		com	(R0)			; loc.0=177777
		comb	R0			; R0=377
		negb	@5(R0)			; R0+5=404, 404=1, loc.0=777
		bmi	neg70			; cc=0001?
		beq	neg70			;
		bvs	neg70			;
		bcs	neg71			;
neg70:						;
		mov	#144, -(R2)		; move to mailbox #144
		inc	-(R2)			; set msgtyp to fatal error
		halt				; neg did not set cc's correctly
neg71:		comb	R0			; R0=0
		comb	(R0)+			; loc.0=400, R0=1
		decb	(R0)			; loc.0=0
		neg	0			; use neg mode 67 to tst for zero
		beq	ts73			;
		mov	#145, -(R2)		; move to mailbox #145
		inc	-(R2)			; set msgtyp to fatal error
		halt				; data result of neg was incorrect
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies program counter addressing with sop
; instructions. clr mode 77 is used to clear the location following the
; instruction (scpx). Then single operand instructions with modes 37, 67, and
; 77, using indirect pointer sopxad are used to verify the data results
; of these instructions.
;
; TEST 73 - test sop instructions modes 2, 3, 6, 7 with register 7
;
ts73:		inc	(R2)			; update test number
		cmp	#73, (R2)		; sequence error?
		bne	sopb			; br to error halt on seq error
		clr	(PC)+			; clear next location: (sopx)
sopx:		-1				; use mode 27
		beq	sopa			;
		mov	#146, -(R2)		; move to mailbox #146
		inc	-(R2)			; set msgtyp to fatal error
		halt				; clr did not set Z-bit
sopa:		inc	@#sopx			; inc sopx w/ mode 37
		neg	sopx			; negate sopx w/ mode 67
		bpl	sopb			;
		inc	@sopxad			; inc sopx w/ mode 77
		beq	ts74			;
sopb:						;
		mov	#147, -(R2)		; move to mailbox #147
		inc	-(R2)			; set msgtyp to fatal error
		halt				; inc did not set Z-bit
						; or sequence error
sopxad:		sopx				; indirect address of sopx
;_____________________________________________________________________________
;
; This test verifies single operand non-modifying instructions
; using mode 0. R0 is set to zero and the condition codes are set
; to the complement of that expected by the instruction. A tst instruction
; is executed and conditional branches are used to test the condition
; codes.
;
; TEST 74 - test mode 0 sop non-modifying
;
ts74:		inc	(R2)			; update test number
		cmp	#74, (R2)		; sequence error?
		bne	ts75-10			; br to error halt on seq error
		clr	R0			; initialize R0=0
		scc				; set cc=1011
		clz				;
		tst	R0			; try tst w/ mode 0
		bvs	snm0a			; check that cc=0100
		bmi	snm0a			;
		bcs	snm0a			;
		beq	ts75			;
snm0a:						;
		mov	#150, -(R2)		; move to mailbox h150
		inc	-(R2)			; set msgtyp to fatal error
		halt				; condition codes not set properly
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies single operand non-modifying byte instructions with mode 0.
; R0 is set to 377 and complement of the expected condition codes
; is loaded in PSW. A tstb instruction is executed and the results
; are checked with several conditional branch instructions.
; This verifies that the proper byte was tested.
;
; TEST 75 - test mode 0 even byte w/ sop non-modifying
;
ts75:		inc	(R2)			; update test number
		cmp	#75, (R2)		; sequence error?
		bne	ts76-10			; br to error halt on seq error
		clr	R0			; initialize
		comb	R0			; R0=377
		scc				; set cc=0111
		cln				;
		tstb	R0			; try tst even byte
		bvs	snmb0a			; check cc=1000
		blos	snmb0a			;
		bmi	ts76			;
snmb0a:						;
		mov	#151, -(R2)		; move to mailbox #151
		inc	-(R2)			; set msgtyp to fatal error
		halt				; condition codes not set properly
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies single operand instructions with mode 1.
; R0 is used to point to and clear loc.0. the complement of the
; expected condition codes are loaded in the PSW. A tst instruction
; is then executed on loc.0 using R0 and conditional branches test
; the results.
;
; TEST 76 - test mode 1 sop non-modifying
;
ts76:		inc	(R2)			; update test number
		cmp	#76, (R2)		; sequence error?
		bne	ts77-10			; br to error halt on seq error
		clr	R0			; point to loc.0
		clr	(R0)			; clear loc.0
		scc				; initialize
		clz				; cc=1011
		tst	(R0)			; try tst w/ mode 1
		bvs	snm1a			; check cc=0100
		bcs	snm1a			;
		bmi	snm1a			;
		beq	ts77			;
snm1a:						;
		mov	#152, -(R2)		; move to mailbox #152
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cc's not set properly
						; or sequence error
;_____________________________________________________________________________
;
; This test sets location 0 to 377 and then uses R0 to test
; the even byte and the odd byte using sop byte instructions with mode 1.
; Again, conditional branches are used to verify the setting of the
; proper condition code bits.
;
; TEST 77 - test mode 1 byte inst. non-modifying
;
ts77:		inc	(R2)			; update test number
		cmp	#77, (R2)		; sequence error?
		bne	ts100-10		; br to error halt on seq error
		clr	R0			; point to loc.0
		clr	(R0)			; clear loc.0
		comb	(R0)			; complement byte 0
		scc				; set cc=0111
		cln				;
		tstb	(R0)			; try tst on even byte
		bvs	snmb1a			;
		blos	snmb1a			;
		bmi	snmb1b			;
snmb1a:						;
		mov	#153, -(R2)		; move to mailbox #153
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cc's not correct
snmb1b:		clr	R0			;
		inc	R0			;
		scc				; set cc=1011
		clz				;
		tstb	(R0)			; try to tst an odd byte
		bvs	snmb1c			; check cc=0100
		bcs	snmb1c			;
		bmi	snmb1c			;
		beq	ts100			;
snmb1c:						;
		mov	#154, -(R2)		; move to mailbox #154
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cc's not correct
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies the single-operand non-modifying instructions
; using mode 2. It uses the identical procedure employed in the
; mode 1 tests. Additionally, the register is checked to assure that
; it is incremented properly.
;
; TEST 100 - test mode 2 with sop non-modifying
;
ts100:		inc	(R2)			; update test number
		cmp	#100, (R2)		; sequence error?
		bne	ts101-10		; br to error halt on seq error
		clr	R0			; initialize R0=0
		clr	(R0)			; clear loc.0
		scc				; set cc=1011
		clz				;
		tst	(R0)+			; try tst w/ mode 2
		bvs	snm2a			; check cc=0100
		bcs	snm2a			;
		bmi	snm2a			;
		beq	snm2b			;
snm2a:						;
		mov	#155, -(R2)		; move to mailbox #155
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cc's not correct
snm2b:		dec	R0			; reset R0
		dec	R0			;
		beq	ts101			;
		mov	#156, -(R2)		; move to mailbox #156
		inc	-(R2)			; set msgtyp to fatal error
						;
						;
		halt				; mode 2 did not inc req correctly
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 2 single operand non-modifying byte
; instructions it uses R0 to point to loc.0. with location 0
; set to 377, the even and odd byte is tested with tstb instructions
; to verify the correct cc are set. The register is checked for
; proper incrementing.
;
; TEST 101 - test mode 2 - byte w/ sop non-modifying
;
ts101:		inc	(R2)			; update test number
		cmp	#101, (R2)		; sequence error?
		bne	ts102-10		; br to error halt on seq error
		clr	R0			; clear R0
		clr	(R0)			; clear loc.0
		comb	(R0)			; set loc.0=377
		scc				; set cc=0111
		cln				;
		tstb	(R0)+			; try tst of even byte
		bvs	snmb2a			;
		blos	snmb2a			;
		bmi	snmb2b			;
snmb2a:						;
		mov	#157, -(R2)		; move to mailbox #157
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cc's not set correctly
snmb2b:		dec	R0			; decrement R0
		beq	snmb2c			;
		mov	#160, -(R2)		; move to mailbox #160
		inc	-(R2)			; set msgtyp to fatal error
		halt				; mode 2 did not inc reg correctly
snmb2c:		inc	R0			; point to odd byte
		scc				; set cc=1011
		clz				;
		tstb	(R0)+			; try tst of odd byte
		bvs	snmb2d			; check cc's-0100
		bcs	snmb2d			;
		bmi	snmb2d			;
		beq	snmb2e			;
snmb2d:						;
		mov	#161, -(R2)		; move to mailbox #161
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cc's not correct
snmb2e:		dec	R0			;
		dec	R0			;
		beq	ts102			;
		mov	#162, -(R2)		; move to mailbox #162
		inc	-(R2)			; set msgtyp to fatal error
		halt				; R0 did not increment properly
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 3 single operand non-modifying instructions.
; A pointer in a table at loc.376 is used to test location 0.
; The cc's and the register are checked following the
; tst mode 3 instruction.
;
; TEST 102 - test mode 3 w/ sop non-modifying insts
;
ts102:		inc	(R2)			; update test number
		cmp	#102, (R2)		; sequence error?
		bne	ts103-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; clear loc.0
		comb	R0			; R0=376
		dec	R0			;
		scc				; set cc=1011
		clz				;
		tst	@(R0)+			; try tst w/ mode 3
		bvs	snm3a			; check cc=0100
		bcs	snm3a			;
		bmi	snm3a			;
		beq	snm3b			;
snm3a:						;
		mov	#163, -(R2)		; move to mailbox #163
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cc's not correct
snm3b:		dec	R0			; R0=377
		comb	R0			; R0=0
		beq	ts103			;
		mov	#164, -(R2)		; move to mailbox #164
		inc	-(R2)			; set msgtyp to fatal error
		halt				; mode 3 did not inc reg correctly
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies sop non-modifying byte instructions mode 3
; loc.0 is set to 377. Table at loc.402-404 is used to test
; byte 0 and byte 1. The register is checked for proper incrementing and
; the cc's are verified.
; The table at loc.402-404 should contain 0 and 1 before and
; after the test is run.
;
; TEST 103 - test mode 3 - bytes w/ sop non-modifying insts.
;
ts103:		inc	(R2)			; update test number
		cmp	#103, (R2)		; sequence error?
		bne	ts104-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; clear loc.0
		comb	(R0)			; loc.0=377
		comb	R0			;
		inc	R0			;
		tst	(R0)+			; R0=402
		scc				; cc=0111
		cln				;
		tstb	@(R0)+			; try tst of even byte
		bvs	snmb3a			; check cc=1000
		blos	snmb3a			;
		bmi	snmb3b			;
snmb3a:						;
		mov	#165, -(R2)		; move to mailbox #165
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cc's not correct
snmb3b:		scc				; set cc=1011
		clz				;
		tstb	@(R0)+			; try tst of odd byte
		bvs	snmb3c			; check cc=0100
		bcs	snmb3c			;
		bmi	snmb3c			;
		beq	snmb3d			;
snmb3c:						;
		mov	#166, -(R2)		; move to mailbox #166
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cc's not correct
snmb3d:		tst	(R0)+			; R0=410
		tst	(R0)			;
		bmi	ts104			;
		mov	#167, -(R2)		; move to mailbox #167
		inc	-(R2)			; set msgtyp to fatal error
		halt				; tstb did not increment R0 correctly
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 4 sop non-modifying instructions.
; loc.0 is set to -1 and the cc's are set to the complement of the
; expected results. R0 and set to 2 and a tst mode 4 is executed.
; The cc's are checked with conditional branch instructions and the register
; is checked for proper decrementing.
;
; TEST 104 - test mode 4 w/ sop non-modifying insts
;
ts104:		inc	(R2)			; update test number
		cmp	#104, (R2)		; sequence error?
		bne	ts105-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; loc.0=0
		com	(R0)+			; loc.0=-1
		scc				; set cc=1011
		clz				;
		tst	-(R0)			; try tst w/ mode 4
		bvs	snm4a			; check cc=0100
		blos	snm4a			;
		bmi	snm4b			;
snm4a:						;
		mov	#170, -(R2)		; move to mailbox #170
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cc's not correct
snm4b:		tst	R0			;
		beq	ts105			;
		mov	#171, -(R2)		; move to mailbox #171
		inc	-(R2)			; set msgtyp to fatal error
		halt				; tst mode 4 did not dec R0 correctly
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 5 sop non-modifying instructions.
; It uses a pointer at loc.376 to test loc.0. R0 is set
; to 400, a tst mode 5 instruction is executed and the cc's checked.
; R0 is checked to insure proper decrementing.
;
; TEST 105 - test mode 5 w/ sop non-modifying insts
;
ts105:		inc	(R2)			; update test number
		cmp	#105, (R2)		; sequence error?
		bne	ts106-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; loc.0=0
		com	(R0)			; loc.0=-1
		comb	R0			; R0=377
		inc	R0			; R0=400
		scc				; set cc=0111
		cln				;
		tst	@-(R0)			; try tst w/ mode 5
		bvs	snm5a			; check cc=1000
		blos	snm5a			;
		bmi	snm5b			;
snm5a:						;
		mov	#172, -(R2)		; move to mailbox #172
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cc's not set properly
snm5b:		inc	R0			; R0=377
		comb	R0			; R0=0
		beq	ts106			;
		mov	#173, -(R2)		; move to mailbox #173
		inc	-(R2)			; set msgtyp to fatal error
		halt				; mode 5 did not dec R0 correctly
						; or sequence error

;_____________________________________________________________________________
;
; This test verifies mode 6 sop non-modifying instructions.
; R0 is set to 377 and a mode 6 tst instruction is executed
; using R0 and an offset of -377. the cc's are checked as well
; as R0 to insure it was not altered.
;
; TEST 106 - test mode 6 w/ sop non-modifying insts.
;
ts106:		inc	(R2)			; update test number
		cmp	#106, (R2)		; sequence error?
		bne	ts107-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; loc.0=0
		com	(R0)			; loc.0=-1
		comb	R0			; R0=377
		scc				; set cc=0111
		cln				;
		tst	-377(R0)		; try tst w/ mode 6
		bvs	snm6a			; check cc=1000
		blos	snm6a			;
		bmi	snm6b			;
snm6a:						;
		mov	#174, -(R2)		; move to mailbox #174
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cc's incorrect
snm6b:		comb	R0			; R0=0
		beq	ts107			;
		mov	#175, -(R2)		; move to mailbox #175
		inc	-(R2)			; set msgtyp to fatal error
		halt				; tst mode 6 incorrectly changed R0
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 7 sop non-modifying instructions.
; It uses a pointer to loc.0 stored at loc.400 to tst loc.0.
; R0 is set to 377 and loc.0 is tested thru the pointer at 400 using
; R0 and an offset of 1.
;
; TEST 107 - test mode 7 w/ sop non-modifying insts.
;
ts107:		inc	(R2)			; update test number
		cmp	#107, (R2)		; sequence error?
		bne	ts110-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; loc.0=0
		com	(R0)			; loc.0=-1
		comb	R0			; R0=377
		scc				; cc=0111
		cln				;
		tst	@1(R0)			; try tst w/ mode 7
		bvs	snm7a			; check cc=1000
		blos	snm7a			;
		bmi	snm7b			;
snm7a:						;
		mov	#176, -(R2)		; move to mailbox #176
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cc's not correct
snm7b:		comb	R0			; R0=0
		beq	ts110			;
		mov	#177, -(R2)		; move to mailbox #177
		inc	-(R2)			; set msgtyp to fatal error
		halt				; tst mode 7 incorrectly changed R0
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 0 double operand instructions. It sets
; data in R0 and R4 and uses the add instruction to test the dop
; microcode.
;
; TEST 110 - test mode 0 double-operand (dop) insts.
;
ts110:		inc	(R2)			; update test number
		cmp	#110, (R2)		; sequence error?
		bne	ts111-10		; br to error halt on seq error
		clr	R0			; R0=0
		com	R0			; R0=-1
		clr	R4			; R4=0
		add	R0, R4			; try add: R4=-1
		inc	R4			; R4=0
		beq	ts111			;
		mov	#200, -(R2)		; move to mailbox #200
		inc	-(R2)			; set msgtyp to fatal error
		halt				; add inst. failed w/ mode 0
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies the move instruction with mode 0 to mode 0.
;
; TEST 111 - mov mode 0 to mode 0
;
ts111:		inc	(R2)			; update test number
		cmp	#111, (R2)		; sequence error?
		bne	ts112-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	R4			; R4=0
		com	R0			; R0=-1
		mov	R0, R4			; try move -1 to R4
		inc	R4			; inc R4
		beq	ts112			;
		mov	#201, -(R2)		; move to mailbox #201
		inc	-(R2)			; set msgtyp to fatal error
		halt				; move failed mode 0 to mode 0
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies the subtract instruction with mode 0, 0.
;
; TEST 112 - test sub mode 0, 0
;
ts112:		inc	(R2)			; update test number
		cmp	#112, (R2)		; sequence error?
		bne	ts113-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	R4			; R4=0
		inc	R4			; R4=1
		sub	R4, R0			; try sub 0, 0 R0=-1
		bpl	sub0			; cc=1001
		beq	sub0			;
		bvs	sub0			;
		bcs	sub0a			;
sub0:						;
		mov	#202, -(R2)		; move to mailbox #202
		inc	-(R2)			; set msgtyp to fatal error
		halt				; condition code failed on sub
sub0a:		inc	R0			;
		beq	ts113			;
		mov	#203, -(R2)		; move to mailbox #203
		inc	-(R2)			; set msgtyp to fatal error
		halt				; data result of sub failed
						; or sequence error
;_____________________________________________________________________________
;
; This test quickly verifies the remaining dop modifying instructions
; with mode 0, 0 to provide a baseline for subsequent tests.
; Single operand instructions are used to set up data in R0 and R4
; before each of the several dop modifying instructions are used and
; verified.
;
; TEST 113 - test all the dop instructions w/ source mode 0, 0
;
ts113:		inc	(R2)			; update test number
		cmp	#113, (R2)		; sequence error?
		bne	ts114-10		; br to error halt on seq error
		clr	R0			; R0=0
		mov	R0, R4			; try move mode 0, 0
		beq	dop0a			;
		mov	#204, -(R2)		; move to mailbox #204
		inc	-(R2)			; set msgtyp to fatal error
		halt				; Z-bit not set
dop0a:		inc	R0			; R0=1
		com	R0			; R0=177776
		com	R4			; R4=177777
		bic	R0, R4			; try bic: R4=1
		dec	R4			; R4=0
		beq	dop0b			;
		mov	#205, -(R2)		; move to mailbox #205
		inc	-(R2)			; set msgtyp to fatal error
		halt				; bic clear result incorrect
dop0b:		bis	R0, R4			; try bis: R4=177777
		inc	R4			;
		inc	R4			; R4=0
		beq	dop0c			;
		mov	#206, -(R2)		; move to mailbox #206
		inc	-(R2)			; set msgtyp to fatal error
		halt				; result of bis incorrect
dop0c:		clr	R0			; R0=0
		comb	R0			; R0=377
		clr	R4			; R4=0
		com	R4			; R4=177777
		bic	R0, R4			; R4=177400
		add	R0, R4			; try add: R4=177777
		inc	R4			; R4=0
		beq	dop0d			;
		mov	#207, -(R2)		; move to mailbox #207
		inc	-(R2)			; set msgtyp to fatal error
		halt				; result of add incorrect
dop0d:		sub	R0, R4			; 177401=R4
		negb	R4			; R4=177777
		inc	R4			; R4=0
		beq	ts114			;
		mov	#210, -(R2)		; move to mailbox #210
		inc	-(R2)			; set msgtyp to fatal error
		halt				; re sult of sub incorrect
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode o, x double operand instructions. It sets
; data in R0 and location 0 and operates upon it using dop instructions.
;
; TEST 114 - test mode o, x double-operand instructions
;
ts114:		inc	(R2)			; update test number
		cmp	#114, (R2)		; sequence error?
		bne	ts115-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; loc.0=0
		comb	(R0)			; loc.0=377
		inc	(R0)+			; loc.0=400 R0=2
		neg	R0			; R0=-2
		add	R0, @#0			; try add 0, 3; loc.0=376
		bmi	dop03a			; cc=0001?
		beq	dop03a			;
		bvs	dop03a			;
		bcs	dop03b			;
dop03a:						;
		mov	#211, -(R2)		; move to mailbox #211
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cc's not set correctly
dop03b:		comb	@#0			; loc.0=1
		dec	@#0			; loc.0=0
		beq	ts115			;
		mov	#212, -(R2)		; move to mailbox #212
		inc	-(R2)			; set msgtyp to fatal error
		halt				; data result incorrect
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 0, 0 dop non-modifying instructions.
; R0 and R4 are preset to 0 and 1 respectively. Compare instructions are
; then executed and checked. First R4 is compared to R0 then R0 to R4.
;
; TEST 115 - test dop non-modifying inst. w/ source mode 0, 0
;
ts115:		inc	(R2)			; update test number
		cmp	#115, (R2)		; sequence error?
		bne	ts116-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	R4			; R4=0
		inc	R4			; R4=1
		cmp	R4, R0			; try compare R4 to R0
		bgt	dnm1			;
		mov	#213, -(R2)		; move to mailbox #213
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cc's not correct for cmp
dnm1:		cmp	R0, R4			; try compare R0 to R4
		blt	dnm2			;
		mov	#214, -(R2)		; move to mailbox #214
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cc's not correct for cmp
dnm2:		inc	R0			; R0=1
		cmp	R4, R0			; try compare R4=1 to R0=1
		beq	dnm3			;
		mov	#215, -(R2)		; move to mailbox #215
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cc's not correct (Z=1) for cmp
dnm3:		clr	R0			; R0=0
		com	R0			; R0=177777
		clr	R4			; R4=0
		bit	R0, R4			; try bit R0 to R4
		beq	dnm4			;
		mov	#216, -(R2)		; move to mailbox #216
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cc's not correct for bit
dnm4:		dec	R4			; R4=177777
		bit	R0, R4			; try bit again
		bmi	ts116			;
		mov	#217, -(R2)		; move to mailbox #217
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cc's not correct for bit
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 0, x double operand non-modifying instructions.
; It sets data in R0 and location 0 and compares them using dopnm instructions.
;
; TEST 116 - test mode 0, x double-operand non-modifying insts.
;
ts116:		inc	(R2)			; update test number
		cmp	#116, (R2)		; sequence error?
		bne	ts117-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; loc.0=0
		com	(R0)			; loc.0=177777
		inc	R0			; R0=1
		cmp	R0, @#0			; try cmp mode 0, 3
		bmi	dnm03a			; cc=0001
		beq	dnm03a			;
		bvs	dnm03a			;
		bcs	dnm03b			;
dnm03a:						;
		mov	#220, -(R2)		; move to mailbox #220
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cc's not set correctly
dnm03b:		dec	R0			;
		bne	dnm03c			;
		inc	(R0)			;
		beq	ts117			;
dnm03c:						;
		mov	#221, -(R2)		; move to mailbox #221
		inc	-(R2)			; set msgtyp to fatal error
		halt				; data incorrectly modified by cmp
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 1 dop instructions. R0 is set to -1
; and loc.0 to 1. R4 is then cleared and used to point to loc.0.
; in the add mode 1 instruction, loc.0 is added to R0 and the
; results verified.
;
; TEST 117 - test mode 1 w/ dop inst.
;
ts117:		inc	(R2)			; update test number
		cmp	#117, (R2)		; sequence error?
		bne	ts120-10		; br to error halt on seq error
		clr	R0			; R0=0
		com	R0			; R0=177777
		clr	R4			; R4=0
		clr	(R4)			; loc.0=0
		inc	(R4)			; loc.0=1
		add	(R4), R0		; try add source mode 1
		beq	ts120			;
		mov	#222, -(R2)		; move to mailbox #222
		inc	-(R2)			; set msgtyp to fatal error
		halt				; result of add incorrect
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 1 dop byte instructions which address
; even bytes. loc.0 is set to -1 and R4 is cleared. Then R4 is
; set to -1 using a bisb thru R0 with mode 1.
;
; TEST 120 - test mode 1 - even byte w/ dop insts.
;
ts120:		inc	(R2)			; update test number
		cmp	#120, (R2)		; sequence error?
		bne	ts121-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; loc.0=0
		com	(R0)			; loc.0=177777
		clr	R4			; R4=0
		bisb	(R0), R4		; try mode 1 - even byte w/ dop
		comb	R4			; R4=0
		beq	ts121			;
		mov	#223, -(R2)		; move to mailbox #223
		inc	-(R2)			; set msgtyp to fatal error
		halt				; result of bisb is incorrect
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 1 dop non-modifying instructions
; which address even bytes. loc.0 is set to -1 and R0 is cleared
; and used as the addressing register. R4 is set to 377 and a
; mode 1, 0 cmpb instruction is used the results verified.
;
; TEST 121 - test mode 1 - even byte w/ dop non-modifying inst.
;
ts121:		inc	(R2)			; update test number
		cmp	#121, (R2)		; sequence error?
		bne	ts122-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; loc.0=0
		com	(R0)			; loc.0=177777
		clr	R4			; R4=0
		comb	R4			; R4=377
		cmpb	(R0), R4		; try mode 1 - even byte w/ dop non-modifying
		beq	ts122			;
		mov	#224, -(R2)		; move to mailbox #224
		inc	-(R2)			; set msgtyp to fatal error
		halt				; result of cmpb incorrect
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 1, 0 movb instructions
; which address even bytes. loc.0 is set to 177400, R0 is cleared and
; R4 is set to -1. movb are used to move byte 0 to R4. This
; verifies that the proper byte was selected and that the sign x-tend
; function with mode 0.
; Then loc.0 is complemented and the same procedure exercises
; the logic for complementary data.
; This test exercises unique microcode.
;
; TEST 122 - test mov instruction mode 1, 0 even byte
;
ts122:		inc	(R2)			; update test number
		cmp	#122, (R2)		; sequence error?
		bne	ts123-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; loc.0=0
		comb	(R0)			; loc.0=177400
		com	(R0)			;
		clr	R4			; R4=0
		com	R4			; R4-177777
		movb	(R0), R4		; R4=0
		tst	R4			; check sign of word
		beq	dop1			;
		mov	#225, -(R2)		; move to mailbox #225
		inc	-(R2)			; set msgtyp to fatal error
		halt				; movb should sign x-tend
dop1:		com	(R0)			; loc.0=177777
		movb	(R0), R4		; do movb w/ even byte
		bmi	ts123			;
		mov	#226, -(R2)		; move to mailbox #226
		inc	-(R2)			; set msgtyp to fatal error
		halt				; movb should sign x-tend
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 1 dop instructions which reference
; odd bytes. loc.0 is set to 177400. R0 is set to 0 and R4 is
; set to 1. The bisb instruction uses the data in byte 1 to set byte 0.
; The result is checked by incrementing the word (loc.0) to zero.
;
; TEST 123 - test mode 1-odd byte w/ dop insts.
;
ts123:		inc	(R2)			; update test number
		cmp	#123, (R2)		; sequence error?
		bne	ts124-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; loc.0=0
		clr	R4			; R4=0
		inc	R4			; R4=1
		comb	(R4)			; loc.0=177400
		bisb	(R4), (R0)		; try to bis low order bits w/ mode 1
		inc	(R0)			; check result
		beq	ts124			;
		mov	#227, -(R2)		; move to mailbox #227
		inc	-(R2)			; set msgtyp to fatal error
		halt				; result of bisb incorrect
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 2 dop instructions. loc.0 is set to -1.
; R0 is cleared and used as the mode 2 addressing register to move loc.0
; to PC. The data results are verified and the incrementing of the register
; is checked.
;
; TEST 124 - test mode 2 w/ dop insts.
;
ts124:		inc	(R2)			; update test number
		cmp	#124, (R2)		; sequence error?
		bne	ts125-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; loc.0=0
		com	(R0)			; loc.0=177777
		mov	(R0)+, R4		; try move mode 2, 0
		inc	R4			; check R4
		beq	dop2			;
		mov	#230, -(R2)		; move to mailbox #230
		inc	-(R2)			; set msgtyp to fatal error
		halt				; result of mov inst incorrect
dop2:		dec	R0			; test R0 after mode 2
		dec	R0			;
		beq	ts125			;
		mov	#231, -(R2)		; move to mailbox #231
		inc	-(R2)			; set msgtyp to fatal error
		halt				; register not incremented in mode 2
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 2 dop byte instructions which address
; even bytes. loc.0 is set to -1. R0 is cleared and used as the
; addressing register in a test which tries to clear byte 1 using
; byte 0 data and a bicb. Unique in this test is use of the
; same addressing register for both source and destination. The source and
; destination is checked to insure proper functioning.
;
; TEST 125 - test mode 2 - even byte w/ dop inst.
;
ts125:		inc	(R2)			; update test number
		cmp	#125, (R2)		; sequence error?
		bne	ts126-10		; br to error halt on seq error
		clr	R0			; R0=0
		mov	R0, (R0)		; loc.0=0
		com	(R0)			; loc.0=177777
		bicb	(R0)+, (R0)		; try to clear byte 1 from byte 0 w/ bicb
		tstb	@#1			; check result
		beq	dopb2a			;
		mov	#232, -(R2)		; move to mailbox #232
		inc	-(R2)			; set msgtyp to fatal error
		halt				; bicb destination incorrect
dopb2a:		comb	@#0			; check bicb source
		beq	ts126			;
		mov	#233, -(R2)		; move to mailbox #233
		inc	-(R2)			; set msgtyp to fatal error
		halt				; bicb source incorrectly changed
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 2 dop byte instructions which reference
; odd bytes. R0 is set to 1, loc.0 is set to 177400, and R4 is cleared.
; A mode 2 movb uses R0 to move byte 1 to R4. An increment
; is used to check that the proper byte was moved and sign x-tended.
;
; TEST 126 - test mode 2 - odd byte w/ dop inst.
;
ts126:		inc	(R2)			; update test number
		cmp	#126, (R2)		; sequence error?
		bne	ts127-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	R4			; R4=0
		clr	(R0)			; loc.0=0
		com	(R0)			; loc.0=177777
		comb	(R0)+			; loc.0=177400; R0=1
		movb	(R0)+, R4		; try dop mode 2 w/ odd byte
		inc	R4			; check result of movb
		beq	dopb2b			;
		mov	#234, -(R2)		; move to mailbox #234
		inc	-(R2)			; set msgtyp to fatal error
		halt				; result of movb incorrect
dopb2b:		tst	-(R0)			; bump R0 down by 2
		tst	R0			; check R0
		beq	ts127			;
		mov	#235, -(R2)		; move to mailbox #235
		inc	-(R2)			; set msgtyp to fatal error
		halt				; mode 2 byte did not increment reg. correctly
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 3 double-operand instructions.
; loc.0 is loaded with alternating zeroes and ones; and R0 is loaded
; with alternating ones and zeroes. A mode 3 bis is used to set R0
; to -1 by using loc.0 as the source to bis the zeroes in R0. The
; result is tested by incrementing R0 and checking for zero.
;
; TEST 127 - test mode 3 w/ dop insts.
;
ts127:		inc	(R2)			; update test number
		cmp	#127, (R2)		; sequence error?
		bne	ts130-10		; br to error halt on seq error
		mov	#052525, @#0		; move 52525 to loc.0
		mov	#125252, R0		; set alt. one and zero in R0
		bis	@#0, R0			; try to set all other bits w/ mode 3
		inc	R0			; test result
		beq	ts130			;
		mov	#236, -(R2)		; move to mailbox #236
		inc	-(R2)			; set msgtyp to fatal error
		halt				; bis w/ mode 3 incorrect result
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 3 double operand byte instructions which
; address even bytes. Byte 0 is set to alternating 1's and 0's; byte 1,
; alternating 0's and 1's. R0 is cleared and a bisb is used to
; set the low byte of R0 to 252.
;
; TEST 130 - test mode 3 - even byte w/ dop insts.
;
ts130:		inc	(R2)			; update test number
		cmp	#130, (R2)		; sequence error?
		bne	ts131-10		; br to error halt on seq error
		mov	#52652, @#0		; move 1's and 0's pattern to loc.0
		clr	R0			; R0=0
		bisb	@#0, R0			; try R0=252 w/ mode 3 - even byte
		cmp	#252, R0		; bisb w/ even byte successful?
		beq	ts131			;
		mov	#237, -(R2)		; move to mailbox #237
		inc	-(R2)			; set msgtyp to fatal error
		halt				; bisb w/ mode 3 - even byte failed
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 3 double operand byte instructions
; which address odd bytes. The same procedure used in previous
; TEST is used here. This time byte 1 is used as the source byte.
; The expected result is: R0 = 125.
;
; TEST 131 - test mode 3 - odd byte w/ dop insts.
;
ts131:		inc	(R2)			; update test number
		cmp	#131, (R2)		; sequence error?
		bne	ts132-10		; br to error halt on seq error
		mov	#52652, @#0		; move 1's and 0's pattern to loc.0
		clr	R0			; R0=0
		bisb	@#1, R0			; try R0=152 w/ mode 3 - odd byte
		cmp	#125, R0		; R0=125?
		beq	ts132			;
		mov	#240, -(R2)		; move to mailbox #240
		inc	-(R2)			; set msgtyp to fatal error
		halt				; bisb w/ mode 3 - odd byte failed
						; or sequence error
;_____________________________________________________________________________
;
; TEST 132 - test dest. mode o-byte w/ dop non-modifying mst
;
ts132:		inc	(R2)			; update test number
		cmp	#132, (R2)		; sequence error?
		bne	ts133-10		; br to error halt on seq error
		clr	R0			; R0=0
		comb	R0			; R0=377
		+sec!sev			; set C and V bits
		bitb	#200, R0		; try dopnm dest. mode 0-byte
		beq	dnmb0a			; br to error if Z-bit set
		bvs	dnmb0a			; br to error if V-bit set
		bcc	dnmb0a			; br to error if C-bit clear
		bmi	dnmb0b			;
dnmb0a:						;
		mov	#241, -(R2)		; move to mailbox #241
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cc's incorrect
dnmb0b:		comb	R0			; check destination data
		beq	ts133			;
		mov	#242, -(R2)		; move to mailbox #242
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. data modified
						; or sequence error
;_____________________________________________________________________________
;
; TEST 133 - test dest. mode 1 w/ dop non-modifying inst.
;
ts133:		inc	(R2)			; update test number
		cmp	#133, (R2)		; sequence error?
		bne	ts134-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; loc.0=0
		clc				; clear C-bit
		bit	#177777, (R0)		; try dopnm dest. mode 1
		bmi	dnm1a			; br to error if N-bit set
		bvs	dnm1a			; br to error if V-bit set
		bcs	dnm1a			; br to error if C-bit set
		beq	dnm1b			;
dnm1a:						;
		mov	#243, -(R2)		; move to mailbox #243
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cond. codes incorrect
dnm1b:		tst	(R0)			; check test data
		beq	ts134			;
		mov	#244, -(R2)		; move to mailbox #244
		inc	-(R2)			; set msgtyp to fatal error
		halt				; destination data modified
						; or sequence error
;_____________________________________________________________________________
;
; TEST 134 - test dest. mode 2 w/ dop non-modifying inst.
;
ts134:		inc	(R2)			; update test number
		cmp	#134, (R2)		; sequence error?
		bne	ts135-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; loc.0=0
		bis	#125252, (R0)		; loc.0=125252
		bit	#77777, (R0)+		; try dopnm inst w/ mode 2
		bvs	dnm2a			; br to error if V-bit set
		beq	dnm2a			; br to error if Z-bit set
		bpl	dnm2b			;
dnm2a:						;
		mov	#245, -(R2)		; move to mailbox #245
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cond. codes incorrect
dnm2b:		dec	R0			; decrement R0 to check it.
		dec	R0			;
		beq	dnm2d			;
dnm2c:						;
		mov	#246, -(R2)		; move to mailbox #246
		inc	-(R2)			; set msgtyp to fatal error
		halt				; mode 2 register not incremented by 2
dnm2d:		cmp	#125252, (R0)		; check dest. data
		beq	ts135			;
		mov	#247, -(R2)		; move to mailbox #247
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. data modified
						; or sequence error
;_____________________________________________________________________________
;
; TEST 135 - test dest. mode 2-byte, w/ dop non-modifying inst.
;
ts135:		inc	(R2)			; update test number
		cmp	#135, (R2)		; sequence error?
		bne	ts136-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; loc.0=0
		bis	#52652, (R0)		; loc.0=52652
		+sec!sev			; set C and V bits
		bitb	#201, (R0)+		; try dopnm inst. w/ mode 2 even byte
		beq	dnmb2a			; br to error if Z-bit set
		bcc	dnmb2a			; br to error if C-bit clear
		bvs	dnmb2a			; br to error if V-bit set
		bmi	dnmb2b			;
dnmb2a:						;
		mov	#250, -(R2)		; move to mailbox #250
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cond. codes incorrect
dnmb2b:		dec	R0			; check dest. register.
		beq	dnmb2c			;
		mov	#251, -(R2)		; move to mailbox #251
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. register not incremented by 1
dnmb2c:		inc	R0			; R0=1
		bitb	#201, (R0)+		; try dopnm inst. w/ mode 2-odd byte
		beq	dnmb2d			; br to error if Z-bit set
		bvs	dnmb2d			; br to error if V-bit set
		bpl	dnmb2e			;
dnmb2d:						;
		mov	#252, -(R2)		; move to mailbox #252
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cond. codes incorrect
dnmb2e:		dec	R0			; dec R0 to check it.
		dec	R0			;
		beq	dnmb2f			;
		mov	#253, -(R2)		; move to mailbox #253
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. register not incremented by 1
dnmb2f:		cmp	#52652, (R0)		; check dest. data is urwodified
		beq	ts136			;
		mov	#254, -(R2)		; move to mailbox #254
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. data was modified
						; or sequence error
;_____________________________________________________________________________
;
; TEST 136 - test dest. mode 3-bytes w/ dop non-modifying inst.
;
ts136:		inc	(R2)			; update test number
		cmp	#136, (R2)		; sequence error?
		bne	ts137-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; loc.0=0
		bis	#125125, (R0)		; loc.0=125125
		comb	R0			; R0=377
		inc	R0			; R0=400
		clr	(R0)			; loc.400=0
		+sec!sev			; C-bit=V-bit=1
		bitb	#201, @(R0)+		; try dopnm w/ mode 3-even byte
		beq	dnmb3a			; br to error if Z-bit set
		bvs	dnmb3a			; br to error if V-bit set
		bcc	dnmb3a			; br to error if C-bit clear
		bpl	dnmb3b			;
dnmb3a:						;
		mov	#255, -(R2)		; move to mailbox #255
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cond. codes incorrect
dnmb3b:		cmp	#402, R0		; check dest. register inc. by 2 and inc by 2 again
		beq	dnmb3c			;
		mov	#256, -(R2)		; move to mailbox #256
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. register not incremented by 2
dnmb3c:		inc	R0			; R0=404
		inc	R0			;
		bitb	#201, @(R0)+		; try dopnm dest mode 3-byte(odd)
		beq	dnmb3d			; br to error if Z-bit set
		bvs	dnmb3d			; br to error if V-bit set
		bmi	dnmb3e			;
dnmb3d:						;
		mov	#257, -(R2)		; move to mailbox #257
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cond. codes incorrect
dnmb3e:		clr	R4			; R4=0
		cmp	#125125, (R4)		; check dest. data
		beq	ts137			;
		mov	#260, -(R2)		; move to mailbox #260
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. data modified
						; or sequence error
;_____________________________________________________________________________
;
; TEST 137 - test dest. mode 4 w/ dop non-modifying inst.
;
ts137:		inc	(R2)			; update test number
		cmp	#137, (R2)		; sequence error?
		bne	ts140-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; loc.0=0
		bis	#125252, (R0)		; loc.0=125125 ???? really?
		bis	#2, R0			; R0=2
		scc				; set all cond. code bits
		bit	#20000, -(R0)		; try dopnm w/ mode 4
		bmi	dnm4a			; br to error if N-bit set
		bvs	dnm4a			; br to error if V-bit set
		bcc	dnm4a			; br to error if C-bit char
		bne	dnm4b			;
dnm4a:						;
		mov	#261, -(R2)		; move to mailbox #261
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cond. codes incorrect
dnm4b:		tst	R0			; check dest. register
		beq	dnm4c			;
		mov	#262, -(R2)		; move to mailbox #262
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. register not decremented by 2
dnm4c:		cmp	#125252, @#0		; check dest. data
		beq	ts140			;
		mov	#263, -(R2)		; move to mailbox #263
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. data modified
						; or sequence error
;_____________________________________________________________________________
;
; TEST 140 - test dest. mode 4-byte w/ dop non-modifying inst.
;
ts140:		inc	(R2)			; update test number
		cmp	#140, (R2)		; sequence error?
		bne	ts141-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; loc.0=0
		bis	#52652, (R0)		; loc.0=52652
		bis	#2, R0			; R0=2
		ccc				; cond. codes=0
		bitb	#201, -(R0)		; try dopnm inst w/ mode 4 odd byte
		bvs	dnmb4a			; br to error if V-bit set
		beq	dnmb4a			; br to error if Z-bit set
		bcs	dnmb4a			; br to error if C-bit set
		bne	dnmb4b			;
dnmb4a:						;
		mov	#264, -(R2)		; move to mailbox #264
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cond. codes incorrect
dnmb4b:		cmp	#1, R0			; check dest. register
		beq	dnmb4c			;
		mov	#265, -(R2)		; move to mailbox #265
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest reg, not decremented by 1
dnmb4c:		bitb	#201, -(R0)		; try dopnm inst, w/ mode 4 even byte
		beq	dnmb4d			; br to error if Z-bit set
		bmi	dnmb4e			;
dnmb4d:						;
		mov	#266, -(R2)		; move to mailbox #266
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cond. codes incorrect
dnmb4e:		tst	R0			; check dest. register
		beq	dnmb4f			;
		mov	#267, -(R2)		; move to mailbox #267
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. reg. not decremented by 1
dnmb4f:		cmp	#52652, (R0)		; check destination data
		beq	ts141			;
		mov	#270, -(R2)		; move to mailbox #270
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. data modified
						; or sequence error
;_____________________________________________________________________________
;
; TEST 141 - test dest mode 5 w/ dop non-modifying inst.
;
ts141:		inc	(R2)			; update test number
		cmp	#141, (R2)		; sequence error?
		bne	ts142-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; loc.0=0
		bis	#100000, (R0)		; loc.0=100000
		bis	#402, R0		; R0=2
		scc				; set all cond. code bits
		bit	#100000, @-(R0)		; try dopnm w/ mode 5
		bvs	dnm5a			; br to error if V-bit set
		bcc	dnm5a			; br to error if C-bit clear
		beq	dnm5a			; br to error if Z-bit set
		bmi	dnm5b			;
dnm5a:						;
		mov	#271, -(R2)		; move to mailbox #271
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cond. codes incorrect
dnm5b:		cmp	#400, R0		;	; check dest. register
		beq	dnm5c			;
		mov	#272, -(R2)		; move to mailbox #272
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. register not decremented by 2
dnm5c:		cmp	#100000, @#0		; check destination data
		beq	ts142			;
		mov	#273, -(R2)		; move to mailbox #273
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. data incorrectly modified
						; or sequence error
;_____________________________________________________________________________
;
; TEST 142 - test dest. mode 6 w/ dop non-modifying inst.
;
ts142:		inc	(R2)			; update test number
		cmp	#142, (R2)		; sequence error?
		bne	ts143-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; loc.0=0
		bis	#1, (R0)		; loc.0=1
		com	R0			; R0=-1 C-bit=1
		bit	#1, 1(R0)		; try dopnm w/ mode 6
		beq	dnm6a			; br to error if Z-bit set
		bvs	dnm6a			; br to error if V-bit set
		bcc	dnm6a			; br to error if C-bit clear
		bpl	dnm6b			;
dnm6a:						;
		mov	#274, -(R2)		; move to mailbox #274
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cond codes incorrect
dnm6b:		cmp	#-1, R0			; check dest. register
		beq	dnm6c			;
		mov	#275, -(R2)		; move to mailbox #275
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. register modified
						;
dnm6c:		cmp	#1, @#0			; check dest. data
		beq	ts143			;
		mov	#276, -(R2)		; move to mailbox #276
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. data modified
						; or sequence error
;_____________________________________________________________________________
;
; TEST 143 - test dest mode 7 w/ dop non-modifying inst.
;
ts143:		inc	(R2)			; update test number
		cmp	#143, (R2)		; sequence error?
		bne	ts144-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; loc.0=0 C-bit=0
		bis	#125125, (R0)		; loc.0=125125
		bis	#1, R0			; R0=1
		bitb	#125, @403(R0)		; try dopnm w/ mode 7
		bvs	dnm7a			; br to error if V-bit set
		bmi	dnm7a			; br to error if N-bit set
		bcs	dnm7a			; br to error if C-bit set
		beq	dnm7b			;
dnm7a:						;
		mov	#277, -(R2)		; move to mailbox #277
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cond. codes incorrect
dnm7b:		cmp	#1, R0			; check dest. register
		beq	dnm7c			;
		mov	#300, -(R2)		; move to mailb0x #300
		inc	-(R2)			; set msgtyp to fatal error
		halt				; destination register modified
dnm7c:		cmp	#125125, @#0		; check dest. data
		beq	ts144			;
		mov	#301, -(R2)		; move to mailbox #301
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. data incorrect
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies the mov destination mode 1 instruction.
; Data is set in R0 using sop instructions and then moved to loc.0
; using mov src mode 0. dest. mode 1.
;
; TEST 144 - test mov destination mode 1
;
ts144:		inc	(R2)			; update test number
		cmp	#144, (R2)		; sequence error?
		bne	ts145-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; loc.0=0
		com	R0			; R0=-1
		clr	R4			; R4 points to loc.0
		mov	R0, (R4)		; try move mode 0, 1
		bvs	mdm1a			; br to error if V-bit set
		beq	mdm1a			; br to error if Z-bit set
		bmi	mdm1b			;
mdm1a:						;
		mov	#302, -(R2)		; move to mailbox #302
		inc	-(R2)			; set msgtyp to fatal error
		halt				; condition code not correct
mdm1b:		tst	R4			;
		beq	ts145			;
		mov	#303, -(R2)		; move to mailbox #303
		inc	-(R2)			; set msgtyp to fatal error
		halt				; destination register incorrectly altered
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies the mov destination mode 2 instruction.
; Data is set in R0 using sop instructions and then moved
; to location 0 using mov src mode 0. dest. mode 1.
;
; TEST 145 - test mov destination mode 2
;
ts145:		inc	(R2)			; update test number
		cmp	#145, (R2)		; sequence error?
		bne	ts146-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	R1			; R1=0
		clr	(R0)			; loc.0=0
		com	(R0)			; loc.0=1
		mov	R1, (R0)+		; try move mode 0, 2
		bmi	mdm2a			; br to error if N-bit set
		bvs	mdm2a			; br to error if V-bit set
		beq	mdm2b			;
mdm2a:						;
		mov	#304, -(R2)		; move to mailbox #304
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cc's incorrect
mdm2b:		dec	R0			;
		dec	R0			;
		beq	mdm2d			;
mdm2c:						;
		mov	#305, -(R2)		; move to mailbox #305
		inc	-(R2)			; set msgtyp to fatal error
		halt				; destination register not incremented properly
mdm2d:		tst	@#0			;
		beq	ts146			;
		mov	#306, -(R2)		; move to mailbox #306
		inc	-(R2)			; set msgtyp to fatal error
		halt				; destination data incorrect
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies destination mode 2 w/ movb insts. Two different movb
; instructions are used to move a test pattern first to byte 0 then to byte 1.
;
; TEST 146 - test mov-byte destination mode 2
;
ts146:		inc	(R2)			; update test number
		cmp	#146, (R2)		; sequence error?
		bne	ts147-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; loc.0=0
		movb	#125, (R0)+		; try destination mode 2 w/ even byte
		bvs	mbdm2a			; br to error if V-bit set
		beq	mbdm2a			; br to error if Z-bit set
		bpl	mbdm2b			;
mbdm2a:						;
		mov	#307, -(R2)		; move to mailbox #307
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cc's incorrect
						;
mbdm2b:		cmp	#1, R0			;
		beq	mbdm2c			;
		mov	#310, -(R2)		; move to mailbox #310
		inc	-(R2)			; set msgtyp to fatal error
		halt				; register not incremented by one
mbdm2c:		movb	#252, (R0)+		; try destination mode 2 w/ odd byte
		bvs	mbdm2d			;
		beq	mbdm2d			;
		bmi	mbdm2e			;
mbdm2d:						;
		mov	#311, -(R2)		; move to mailbox #311
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cc's not set correct
mbdm2e:		cmp	#2, R0			;
		beq	mbdm2f			;
		mov	#312, -(R2)		; move to mailbox #312
		inc	-(R2)			; set msgtyp to fatal error
		halt				; register not incremented by one
mbdm2f:		cmp	#125125, @#0		; check data
		beq	ts147			;
		mov	#313, -(R2)		; move to mailbox #313
		inc	-(R2)			; set msgtyp to fatal error
		halt				; destination data incorrect
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mov destination mode 3. R0 is used to pick up
; an address at loc.400. loc.400 points to loc.0 the effective dest. addr.. Also, movb
; inst. are used w/ even and odd bytes to check mov bytes inst and mode 37 destinations.
;
; TEST 147 - test mov(b) destination mode 3
;
ts147:		inc	(R2)			; update test number
		cmp	#147, (R2)		; sequence error?
		bne	ts150-10		; br to error halt on seq error
		mov	#400, R0		; R0=400
		clr	(R0)			; loc.400 points to loc.0
		clr	@#0			; loc.0=0
		mov	#125252, @(R0)+		; try mov destination mode 2
		bvs	mdm3a			; br to error it V-bit set
		beq	mdm3a			; br to error if Z-bit set
		bmi	mdm3b			;
mdm3a:						;
		mov	#314, -(R2)		; move to mailbox #314
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cc's incorrect
mdm3b:		cmp	#402, R0		; check dest. mode register
		beq	mdm3c			;
		mov	#315, -(R2)		; move to mailbox #315
		inc	-(R2)			; set msgtyp to fatal error
		halt				; register not incremented by 2
mdm3c:		cmp	#125252, @#0		; check destination data
		beq	mdm3d			;
		mov	#316, -(R2)		; move to mailbox #316
		inc	-(R2)			; set msgtyp to fatal error
		halt				; destination data incorrect
mdm3d:		movb	#125, @#0		; try movb destination mode z even byte
		cmp	#125125, @#0		; check data
		beq	mdm3e			;
		mov	#317, -(R2)		; move to mailbox #317
		inc	-(R2)			; set msgtyp to fatal error
		halt				; destination data incorrect
mdm3e:		movb	#525, @#1		; try movb destination mode 2 odd byte
		cmp	#52525, @#0		; check data
		beq	ts150			;
		mov	#320, -(R2)		; move to mailbox #320
		inc	-(R2)			; set msgtyp to fatal error
		halt				;
;_____________________________________________________________________________
;
; This test verifies the mov destination mode 4 instruction.
; sop instructions on R0 are used to clear target location 0.
; R4 is used as the mode 4 addressing register. And
; conditional branches are used to verify the data.
;
; TEST 150 - test mov destination mode 4
;
ts150:		inc	(R2)			; update test number
		cmp	#150, (R2)		; sequence error?
		bne	ts151-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; loc.0=0
		mov	#2, R4			; R4=2
		mov	#12345, -(R4)		; try mov dest. mode 4
		bvs	mdm4a			; br to error if V-bit set
		beq	mdm4a			; br to error if Z-bit set
		bpl	mdm4b			;
mdm4a:						;
		mov	#321, -(R2)		; move to mailbox #321
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cc's not correct
mdm4b:		tst	R4			; check decrementing of mode 4 reg.
		beq	mdm4c			;
		mov	#322, -(R2)		; move to mailbox #322
		inc	-(R2)			; set msgtyp to fatal error
		halt				; destination mode register not decremented by 2
mdm4c:		cmp	#12345, (R0)		; check destination data
		beq	ts151			;
		mov	#323, -(R2)		; move to mailbox #323
		inc	-(R2)			; set msgtyp to fatal error
		halt				; destination data incorrect
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies the movb destination mode 4 instruction
; on both odd and even bytes. sop instructions on R4 are
; used to clear target location 0. R0 is used as the mode 4
; addressing register, and cmp and conditional branch
; instructions are used to verify the data.
;
; TEST 151 - test movb destination mode 4
;
ts151:		inc	(R2)			; update test number
		cmp	#151, (R2)		; sequence error?
		bne	ts152-10		; br to error halt on seq error
		clr	R4			; R4=0
		clr	(R4)			; loc.0=0
		mov	#2, R0			; R0=2
		movb	#125125, -(R0)		; try movb dest. mode 4-odd byte
		cmp	R0, #1			; check that dest. reg. was decremented
		beq	mbdm4a			;
		mov	#324, -(R2)		; move to mailbox #324
		inc	-(R2)			; set msgtyp to fatal error
		halt				; destination reg. not decremented by 1
mbdm4a:		cmp	(R4), #52400		; check dest. data
		beq	mbdm4b			;
		mov	#325, -(R2)		; move to mailbox #325
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. data not correct
mbdm4b:		movb	#125125, -(R0)		; try movb dest. mode 4-even byte
		bvs	mbdm4c			; br. to error if V-bit set
		beq	mbdm4c			; br to error if Z-bit set
		bpl	mbdm4d			;
mbdm4c:						;
		mov	#326, -(R2)		; move to mailbox #326
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cond. codes incorrect
mbdm4d:		tst	R0			; check mode 4 dest. register
		beq	mbdm4e			;
		mov	#327, -(R2)		; move to mailbox #327
		inc	-(R2)			; set msgtyp to fatal error
		halt				; destination reg not decremented by 1
mbdm4e:		cmp	(R4), #52525		; check dest. data
		beq	ts152			;
		mov	#330, -(R2)		; move to mailbox #330
		inc	-(R2)			; set msgtyp to fatal error
		halt				; destination data incorrect
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies the mov destination mode 5 and the movb
; destination mode 5 - even byte instructions. R4 is a
; pointer to target location 0 and R0 is setup to
; point to location 376 for the mov, and location 404 for
; the movb instructions. cmp instructions are used to verify
; proper addressing and data.
;
; TEST 152 - test mov destination mode 5
;
ts152:		inc	(R2)			; update test number
		cmp	#152, (R2)		; sequence error?
		bne	ts153-10		; br to error halt on seq error
		clr	R4			; R4=0
		clr	(R4)			; loc.0=0
		mov	#400, R0		; R0=400
		mov	#4321, @-(R0)		; try mov dest. mode 5
		bvs	mdm5a			; br to error if V-bit set
		beq	mdm5a			; br to error if Z-bit set
		bpl	mdm5b			;
mdm5a:						;
		mov	#331, -(R2)		; move to mailbox #331
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cond. codes incorrect
mdm5b:		cmp	#376, R0		; check mode 5 reg. was decremented
		beq	mdm5c			;
		mov	#332, -(R2)		; move to mailbox #332
		inc	-(R2)			; set msgtyp to fatal error
		halt				; mode 5 register not decremented by 2
mdm5c:		cmp	#4321, (R4)		; check dest. data
		beq	mdm5d			;
		mov	#333, -(R2)		; move to mailbox #333
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. data incorrect
mdm5d:		mov	#406, R0		; R0=406
		movb	#377, @-(R0)		; try mov dest. mode 5-even byte
		cmp	#404, R0		; check mode 5 reg.
		beq	mdm5e			;
		mov	#334, -(R2)		; move to mailbox #334
		inc	-(R2)			; set msgtyp to fatal error
		halt				; mode 5 register not decremented by 2
mdm5e:		cmp	#177721, (R4)		; check dest. data
		beq	ts153			;
		mov	#335, -(R2)		; move to mailbox #335
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. data incorrect
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies the mov destination mode 6 and movb - even byte
; destination mode 6 indtructions. R0 is used to setup target loc.0
; for both tests. Patterns of ones and zeroes are moved into loc.0
; by mode 6 instructions, and cmp instructions are used to verify
; proper addressing and data.
;
; TEST 153 - test mov destination mode 6
;
ts153:		inc	(R2)			; update test number
		cmp	#153, (R2)		; sequence error?
		bne	ts154-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; loc.0=0
		inc	R0			; R0=1
		mov	#052525, -1(R0)		; try mov dest. mode 6
		bvs	mdm6a			; br to error if V-bit set
		beq	mdm6a			; br to error if Z-bit set
		bpl	mdm6b			;
mdm6a:						;
		mov	#336, -(R2)		; move to mailbox #336
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cond. codes incorrect
mdm6b:		cmp	#1, R0			; check dest. register unaltered
		beq	mdm6c			;
		mov	#337, -(R2)		; move to mailbox #337
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. register incorrectly altered
mdm6c:		cmp	#52525, @#0		; check dest. data
		beq	mdm6d			;
		mov	#340, -(R2)		; move to mailbox #340
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. data incorrect
mdm6d:		mov	#2, R0			; R0=2
		movb	#377, -1(R0)		; try movb dest. mode 6
		cmp	#2, R0			; check dest. register unaltered
		beq	mdm6e			;
		mov	#341, -(R2)		; move to mailbox #341
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. register incorrectly altered
mdm6e:		cmp	#177525, @#0		; check dest. data
		beq	ts154			;
		mov	#342, -(R2)		; move to mailbox #342
		inc	-(R2)			; set msgiyp to fatal error
		halt				; dest. data incorrect
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies the mov destination mode 7 and movb - odd byte
; destination mode 7 instructions. R4 points to target loc.o and R0
; is used as the mode 7 addressing register. cmp instructions are
; used to verify proper addressing and data.
;
; TEST 154 - test mov destination mode 7
;
ts154:		inc	(R2)			; update test number
		cmp	#154, (R2)		; sequence error?
		bne	ts155-10		; br to error halt on seq error
		clr	R4			; R4=0
		clr	(R4)			; loc.0=0
		mov	#403, R0		; R0=403
		mov	#70707, @-1(R0)		; try mov w/ dest mode 7
		bvs	mdm7a			; br. to error if V-bit set
		beq	mdm7a			; br to error if Z-bit set
		bpl	mdm7b			;
mdm7a:						;
		mov	#343, -(R2)		; move to maiibox #343
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cond. codes incorrect
mdm7b:		cmp	#403, R0		; check dest. register
		beq	mdm7c			;
		mov	#344, -(R2)		; move to mailbox #344
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. register incorrectly altered
mdm7c:		cmp	#70707, @#0		; check dest. data
		beq	mdm7d			;
		mov	#345, -(R2)		; move to mailbox #345
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. data incorrect
mdm7d:		movb	#107070, @1(R0)		; try movb w/ dest mode 7-odd byte
		cmp	#403, R0		; check mode 7 dest. reg.
		beq	mdm7e			;
		mov	#346, -(R2)		; move to mailbox #346
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. data incorrect
mdm7e:		cmp	#34307, @#0		; check dest. data
		beq	ts155			;
		mov	#347, -(R2)		; move to mailbox #347
		inc	-(R2)			; set msgtyp to fatal error
		halt				; destination data incorrect
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 4 double operand instructions.
; The test uses mode 4 addressing with register 0 to move thru a
; table of operands. The table of operands and the work location is
; stored following the test code. A series of 5 dop instructions utilizes
; the data in the table to cycle the work location thru a set of
; value. The data has been chosen to insure that no single error will
; go undetected. Word and byte instruction accessing both even and
; odd addresses are used in the test. The listing shows the
; expected intermediate result as each instruction is executed.
;
; TEST 155 - test mode 4 w/ dop insts.
;
ts155:		inc	(R2)			; update test number
		cmp	#155, (R2)		; sequence error?
		bne	dop4			; br to error halt on seq error
		mov	#tbl1, R0		; initialize R0
		mov	-(R0), @#tbl1		; tbl1=125252
		add	-(R0), @#tbl1		; tbl1=000377
		bicb	-(R0), @#tbl1		; tbl1=000252
		bisb	-(R0), @#tbl1+1		; tbl1=125252
		cmp	-(R0), @#tbl1		; check result
		beq	ts156			;
dop4:						;
		mov	#350, -(R2)		; move to mailbox #350
		inc	-(R2)			; set msgtyp to fatal error
		halt				; result of mode 4 insts. incorrect
						; or sequence error
		125252
		52652
		53125
		125252
tbl1:		0
;_____________________________________________________________________________
;
; This test verifies mode 5 double operand instructions.
; The test uses an address table stored following the test code.
; This table is simply a table of address pointers which address
; the data table used in the previous test. The test is identical to
; the previous test except the data is referenced using this address
; table and mode 5 addressing. (see previous test).
;
; TEST 156 test mode 5 w/ dop insts.
;
ts156:		inc	(R2)			; update test number
		cmp	#156, (R2)		; sequence error?
		bne	dop5			; br to error halt on seq error
		mov	#tbl2+2, R0		; initialize R0
		mov	@-(R0), @#tbl1		; tbl1=125252
		add	@-(R0), @#tbl1		; tbl1=000377
		bicb	@-(R0), @#tbl1		; tbl1=000252
		bisb	@-(R0), @#tbl1+1	; tbl1=125252
		cmp	@-(R0), @#tbl1		; check result
		beq	ts157			;
dop5:						;
		mov	#351, -(R2)		; move to mailbox #351
		inc	-(R2)			; set msgtyp to fatal error
		halt				; result of mode 5 insts. inccrrect
						; or sequence error
		tbl1-10
		tbl1-6
		tbl1-5
		tbl1-4
tbl2:		tbl1-2
;_____________________________________________________________________________
;
; This test verifies mode 6 double operand instructions,
; It uses the same data as that used in the mode 4 tests,
; this time the data is accessed using mode 6, R0 is set
; to point to the middle of the table. The table is accessed from
; bottom to top by varying the offset in the mode 6 instructions.
; The data results are identical to those expected in the mode 4
; tests.
;
; TEST 157 - test mode 6 w/ dop insts.
;
ts157:		inc	(R2)			; update test number
		cmp	#157, (R2)		; sequence error?
		bne	ts160-10		; br to error halt on seq error
		mov	#tbl1-4, R0		; initialize R0
		mov	2(R0), @#tbl1		; tbl1=125252
		add	0(R0), @#tbl1		; tbl1=000377
		bicb	-1(R0), @#tbl1		; tbl1=000252
		bisb	-2(R0), @#tbl1+1	; tbl1=125252
		cmp	-4(R0), @#tbl1		; check result
		beq	ts160			;
		mov	#352, -(R2)		; move to mailbox #352
		inc	-(R2)			; set msgtyp to fatal error
		halt				; result of mode 6 insts. incorrect
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 7 double operand instructions.
; This test uses the same address table and data table used by
; the mode 5 tests. This time the data is accessed using mode 7.
; R0 is set to point to the middle of the address table in the mode 5
; test. The table is accessed from bottom to top by varying the offset
; in the mode 7 instructions. The data results are identical to
; those expected in the mode 5 tests.
;
; TEST 160 - test mode 7 w/ dop insts.
;
ts160:		inc	(R2)			; update test number
		cmp	#160, (R2)		; sequence error?
		bne	ts161-10		; br to error halt on seq error
		mov	#tbl2-4, R0		; initialize R0
		mov	@4(R0), @#tbl1		; tbl1=125252
		add	@2(R0), @#tbl1		; tbl1=000377
		bicb	@0(R0), @#tbl1		; tbl1=000252
		bisb	@-2(R0), @#tbl1+1	; tbl1=125252
		cmp	@-4(R0), @#tbl1		; check result
		beq	ts161			;
		mov	#353, -(R2)		; move to mailbox #353
		inc	-(R2)			; set msgtyp to fatal error
		halt				; result of mode 7 insts incorrect
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies the rotate mode 0 instructions.
; R0 is loaded with a data pattern, the C-bit is loaded, and
; an rol instruction is executed with mode 0. The operation is checked
; by testing the resulting data and the state of the C and V bits.
; Next, the same procedure is executed to test mode 0 byte instructions.
;
; TEST 161 - test rotate instructions of mode 0
;
ts161:		inc	(R2)			; update test number
		cmp	#161, (R2)		; sequence error?
		bne	ts162-10		; br to error halt on seq error
		mov	#125252, R0		; initialize data
		sec				; set C-bit
		rol	R0			; try rol w/ mode 0
		bvc	rot0a			; cc=0011
		bcc	rot0a			;
		cmp	#052525, R0		; check data
		beq	rot0b			;
rot0a:						;
		mov	#354, -(R2)		; move to mailbox #354
		inc	-(R2)			; set msgtyp to fatal error
		halt				; rol mode 0 failed
rot0b:		mov	#125252, R0		; initialize data
		sec				; set C-bit
		rolb	R0			; try rol w/ mode 0 even byte
		bvc	rot0c			; cc=0011
		bcc	rot0c			;
		cmp	#125125, R0		; check data
		beq	ts162			;
rot0c:						;
		mov	#355, -(R2)		; move to mailbox #355
		inc	-(R2)			; set msgtyp to fatal error
		halt				; rolb mode 0 failed
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies the rotate mode 1 instructions.
; The data to be rotated is in loc.0. R0 is used as the
; addressing register. The C-bit is loaded and an rol is executed.
; The results are checked by comparing the data results and testing
; the C and V bits. This procedure is then repeated twice more
; to test the byte rotates. First on byte 0, then on byte 1.
;
; TEST 162 - test rotate instructions w/ mode 1
;
ts162:		inc	(R2)			; update test number
		cmp	#162, (R2)		; sequence error?
		bne	ts163-10		; br to error halt on seq error
		clr	R0			; point to loc.0
		mov	#52525, (R0)		; initialize data
		clc				; clear C-bit
		rol	(R0)			; try rol w/ mode 1
		bvc	rot1a			; cc=1010
		bcs	rot1a			;
		cmp	@#0, #125252		; check result
		beq	rot1b			;
rot1a:						;
		mov	#356, -(R2)		; move to mailbox #356
		inc	-(R2)			; set msgtyp to fatal error
		halt				; rol mode 1 failed
rot1b:		sec				;
		mov	#125252, (R0)		; initialize data
		rolb	(R0)			; try rolb w/ mode 1 even byte
		bvc	rot1c			; cc=1011
		bcc	rot1c			;
		cmp	#125125, @#0		; test result
		beq	rot1d			;
rot1c:						;
		mov	#357, -(R2)		; move to mailbox #357
		inc	-(R2)			; set msgtyp to fatal error
		halt				; rolb w/ mode 1 even byte failed
rot1d:		mov	#125252, (R0)		;
		clr	R0			; point to odd byte
		inc	R0			;
		sec				; set C-bit
		rolb	(R0)			; try rolb w/ mode 1 odd byte
		bvc	rot1e			; cc=0011
		bcc	rot1e			;
		cmp	#052652, @#0		; check data
		beq	ts163			;
rot1e:						;
		mov	#360, -(R2)		; move to mailbox #360
		inc	-(R2)			; set msgtyp to fatal error
		halt				; rolb w/ mode 1 odd byte failed
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 2 rotate instructions.
; The same procedure as in the other rotate tests are used. R0
; is used as the addressing register and is checked for proper
; incrementing. Byte instructions are also checked.
;
; TEST 163 - test rotate instructions w/ mode 2
;
ts163:		inc	(R2)			; update test number
		cmp	#163, (R2)		; sequence error?
		bne	ts164-10		; br to error halt on seq error
		clr	R0			; point to loc.0
		mov	#173737, (R0)		; initialize data
		clc				; clear C-bit
		rol	(R0)+			; try rol w/ mode 2
		bcc	rot2a			; check C-bit
		cmp	#167676, @#0		; check data
		bne	rot2a			; branch if result incorrect
		dec	R0			; test R0
		dec	R0			;
		beq	rot2b			;
rot2a:						;
		mov	#361, -(R2)		; move to mailbox #361
		inc	-(R2)			; set msgtyp to fatal error
		halt				; rol w/ mode 2 failed
rot2b:		clr	R0			; point to loc.0
		mov	#4040, (R0)		; initialize data
		clc				; clear C-bit
		rolb	(R0)+			; try rolb w/ mode 2 even byte
		bcs	rot2c			; check C-bit
		cmp	#4100, @#0		; check data
		bne	rot2c			; branch if data incorrect
		dec	R0			; check R0
		beq	rot2d			;
rot2c:						;
		mov	#362, -(R2)		; move to marbox #362
		inc	-(R2)			; set msgtyp to fatal error
		halt				; rolb w/ mode 2 even byte failed
rot2d:		clr	R0			; point to loc.0
		mov	#4040, (R0)		; initialize data
		inc	R0			; point to odd byte of data
		sec				; set C-bit
		rolb	(R0)+			; try rol w/ mode 2 odd byte
		bcs	rot2e			; check C-bit
		cmp	#10440, @#0		; check data
		bne	rot2e			; branch if data incorrect
		dec	R0			; check R0
		dec	R0			;
		beq	ts164			;
rot2e:						;
		mov	#363, -(R2)		; move to mailbox #363
		inc	-(R2)			; set msgtyp to fatal error
		halt				; rolb w/ mode 2 odd byte failed
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 3 rotate instructions.
; This test uses the same procedures as in the other rotate
; tests. The data is stored in loc.0 and is addressed using
; mode 37. Byte addressing is also checked for even and odd bytes.
;
; TEST 164 - test rotate instructions w/ mode 3
;
ts164:		inc	(R2)			; update test number
		cmp	#164, (R2)		; sequence error?
		bne	ts165-10		; br to error halt on seq error
		mov	#52525, @#0		; initialize data in loc.0
		sec				; set C-bit
		rol	@#0			; R0 rol w/ mode 3
		bcs	rot3a			; check C-bit
		cmp	#125253, @#0		; check data
		beq	rot3b			;
rot3a:						;
		mov	#364, -(R2)		; move to mailbox #364
		inc	-(R2)			; set msgtyp to fatal error
		halt				; rol w/ mode 3 failed
rot3b:		mov	#125252, @#0		; initialize data
		clc				; clear C-bit
		rolb	@#0			; try rol w/ mode 3 even byte
		bcc	rot3c			; check C-bit
4$:		cmp	@#0, #125124		; check data
		beq	rot3d			;
rot3c:						;
		mov	#365, -(R2)		; move to mailbox #365
		inc	-(R2)			; set msgtyp to fatal error
		halt				; rol w/ mode 3 even byte failed
rot3d:		mov	#125252, @#0		; initialize data in loc.0
		sec				; set C-bit
		rolb	@#1			; try rol w/ mode 3 odd byte
		bcc	rot3e			; check C-bit
		cmp	#052652, @#0		; check data
		beq	ts165			;
rot3e:						;
		mov	#366, -(R2)		; move to mailbox #366
		inc	-(R2)			; set msgtyp to fatal error
		halt				; rol w/ mode 3 odd byte failed
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 4 rotate instructions. The data is
; stored in loc.0. R0 is set to 2 and the carry is set. an rol mode 4
; is used to rotate location 0 using R0. The data is checked
; and the C and V bits are tested. The proper decrementing of
; R0 is verified.
;
; TEST 165 - test mode 4 w/ rotate instructions
;
ts165:		inc	(R2)			; update test number
		cmp	#165, (R2)		; sequence error?
		bne	ts166-10		; br to error halt on seq error
		mov	#070707, @#0		; initialize data in loc.0
		mov	#2, R0			; initialize R0 as pointer
		sec				; set C-bit
		rol	-(R0)			; try rol w/ mode 4
		bcs	rot4			; check C-bit
		cmp	#161617, @#0		; check data
		bne	rot4			; branch if data incorrect
		tst	R0			; check mode 4 register
		beq	ts166			;
rot4:						;
		mov	#367, -(R2)		; move to mailbox #367
		inc	-(R2)			; set msgtyp to fatal error
		halt				; rol mode 4 failed
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 5 rotate instructions.
; The data is stored in a work location (rotx) at the end of the
; test code. loc.0 is loaded with the address of the data (rotx).
; R0 is set to 2. The carry is cleared and a mode 5 rol
; is executed using R0 as an addressing register. The data is
; checked, the C and V bits tested, and R0 checked for proper
; decrementing.
;
; TEST 166 - test mode 5 w/ rotate instructions
;
ts166:		inc	(R2)			; update test number
		cmp	#166, (R2)		; sequence error?
		bne	rot5			; br to error halt on seq error
		mov	#rotx, @#0		; move pointer to loc.0
		mov	#2, R0			; set mode 5 reg. to loc.0
		mov	#107070, rotx		; initialize data
		clc				; clear C-bit
		rol	@-(R0)			; try rol w/ mode 5
		bcc	rot5			; check C-bit
		cmp	#016160, @#rotx		; check data
		bne	rot5			; branch if data incorrect
		tst	R0			; check mode 5 register
		beq	ts167			;
rot5:						;
		mov	#370, -(R2)		; move to mailbox #370
		inc	-(R2)			; set msgtyp to fatal error
		halt				; rol mode 5 failed
						; or sequence error
rotx:		0
;_____________________________________________________________________________
;
; This test verifies mode 6 rotate instructions.
; It uses the same procedure as the above test except the
; rotate instruction uses mode 6 addressing with register 7.
; The data is still operated on in loc.rotx (see previous test).
;
; TEST 167 - test mode 6 w/ rotate instructions
;
ts167:		inc	(R2)			; update test number
		cmp	#167, (R2)		; sequence error?
		bne	ts170-10		; br to error halt on seq error
		mov	#125252, @#rotx		; initialize data
		sec				; set C-bit
		rol	rotx			; try rol w/ mode 6
		bcc	rot6			; check C-bit
		cmp	#52525, @#rotx		; check data
		beq	ts170			;
rot6:						;
		mov	#371, -(R2)		; move to mailbox #371
		inc	-(R2)			; set msgtyp to fatal error
		halt				; rol w/ mode 6 failed
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 7 rotate instructions.
; The data is set in loc.rotx, (see previous test). The rol instruction
; addresses it indirectly using mode 7 and indirect address location
; (rotxad) following the test code.
;
; TEST 170 - test mode 7 w/ rotate instructions
;
ts170:		inc	(R2)			; update test number
		cmp	#170, (R2)		; sequence error?
		bne	rot7			; br to error halt on seq error
		mov	#52525, @#rotx		; initialize data
		mov	#rotx, @#rotxad		; initialize address pointer
		clc				; clear C-bit
		rol	@rotxad			; try rol w/ mode 7
		bcs	rot7			; check C-bit
		cmp	@#rotx, #125252		; check data
		beq	ts171			;
rot7:						;
		mov	#372, -(R2)		; move to mailbox #372
		inc	-(R2)			; set msgtyp to fatal error
		halt				; rol w/ mode 7 failed
						; or sequence error
rotxad:		0
;_____________________________________________________________________________
;
; This test verifies mode 0 swab instruction. R0 is set to
; 177400. A swab mode 0 is executed and the conditional branch
; is used to check the sign of the result. Also, a comparison
; is made to check the data results.
;
; TEST 171 - test mode 0 w/ swab inst.
;
ts171:		inc	(R2)			; update test number
		cmp	#171, (R2)		; sequence error?
		bne	ts172-10		; br to error halt on seq error
		mov	#177400, R0		; move test pattern to R0
		swab	R0			; try swab mode 0
		bmi	sb0			;
		mov	#373, -(R2)		; move to mailbox #373
		inc	-(R2)			; set msgtyp to fatal error
		halt				; swab did not set cc's correct
sb0:		cmp	#377, R0		; check result
		beq	ts172			;
		mov	#374, -(R2)		; move to mailbox #374
		inc	-(R2)			; set msgtyp to fatal error
		halt				; result of swab mode 0 failed
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 1 swab instruction. The test
; pattern is moved to loc.0. R0 is cleared and used as the addressing
; register in the mode 1 swab. The data results are checked with
; a compare.
;
; TEST 172 - test mode 1 w/ swab inst
;
ts172:		inc	(R2)			; update test number
		cmp	#172, (R2)		; sequence error?
		bne	ts173-10		; br to error halt on seq error
		mov	#125652, @#0		; move test pattern to loc.0
		clr	R0			; R0=0
		swab	(R0)			; try swab mode 1
		cmp	#125253, @#0		; check result
		beq	ts173			;
		mov	#375, -(R2)		; move to mailbox #375
		inc	-(R2)			; set msgtyp to fatal error
		halt				; result of swab mode 1 failed
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 2 swab instruction. The test
; pattern is moved to loc.0. R0 is cleared and used as the mode
; 2 addressing register. The results are checked with a compare.
; R0 is checked for proper decrementing.
;
; TEST 173 - test mode 2 w/ swab inst.
;
ts173:		inc	(R2)			; update test number
		cmp	#173, (R2)		; sequence error?
		bne	ts174-10		; br to error halt on seq error
		mov	#125152, @#0		; move test pattern to loc.0
		clr	R0			; R0=0
		swab	(R0)+			; try swab mode 2
		cmp	#65252, @#0		; check result
		beq	sb2			;
		mov	#376, -(R2)		; move to mailbox #376
		inc	-(R2)			; set msgtyp to fatal error
		halt				; result of swab mode 0 failed
sb2:		sub	#2, R0			; check effect of reg.
		beq	ts174			;
		mov	#377, -(R2)		; move to mailbox #377
		inc	-(R2)			; set msgtyp to fatal error
		halt				; register value incorrect
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 3 swab instruction. The test
; pattern is moved to loc.0. a mode 3 swab instruction is executed
; using PC as the addressing register. A compare verifies the
; data results.
;
; TEST 174 - test mode 3 w/ swab inst.
;
ts174:		inc	(R2)			; update test number
		cmp	#174, (R2)		; sequence error?
		bne	ts175-10		; br to error halt on seq error
		mov	#377, @#0		; move test pattern to loc.0
		swab	@#0			; try swab w/ mode 3
		cmp	#177400, @#0		; check result
		beq	ts175			;
		mov	#400, -(R2)		; move to mailbox #400
		inc	-(R2)			; set msgtyp to fatal error
		halt				; result of swab incorrect
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 4 swab instructions. The data
; is moved to loc.0. R0 is set to 2 and used as the mode 4 addressing
; register. The data is checked with a compare and R0 is checked
; for proper decrementing.
;
; TEST 175 - test mode 4 w/ swab inst.
;
ts175:		inc	(R2)			; update test number
		cmp	#175, (R2)		; sequence error?
		bne	ts176-10		; br to error halt on seq error
		mov	#125652, @#0		; move test pattern to loc.0
		mov	#2, R0			; set up register pointer
		swab	-(R0)			; try swab mode 4
		cmp	#125253, @#0		; check result
		beq	sb4			;
		mov	#401, -(R2)		; move to mailbox #401
		inc	-(R2)			; set msgtyp to fatal error
		halt				; result of swab incorrect
sb4:		tst	R0			; check effect on reg.
		beq	ts176			;
		mov	#402, -(R2)		; move to mailbox #402
		inc	-(R2)			; set msgtyp to fatal error
		halt				; register value incorrect
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies mode 5 swab instruction. The test uses
; two locations following the test code. sb5x holds the data;
; sb5xad is a pointer to the data location. The data is moved to
; sb5x and R0 is set to two plus the address of sb5xad. Following
; the mode 5 swab sb5x is checked for the proper data. R0 is
; checked to see that it was decremented properly.
;
; TEST 176 - test mode 5 w/ swab inst.
;
ts176:		inc	(R2)			; update test number
		cmp	#176, (R2)		; sequence error?
		bne	sb5			; br to error halt on seq error
		mov	#sb5xad+2, R0		; set up pointer to work location
		mov	#125125, sb5x		; move pattern to work location
		swab	@-(R0)			; try swab mode 5
		cmp	#52652, sb5x		; check result
		beq	sb5a			;
		mov	#403, -(R2)		; move to mailbox #403
		inc	-(R2)			; set msgtyp to fatal error
		halt				; result of swab incorrect
sb5a:		cmp	R0, #sb5xad		; check result of reg.
		beq	ts177			;
sb5:						;
		mov	#404, -(R2)		; move to mailbox #404
		inc	-(R2)			; set msgtyp to fatal error
		halt				; register value incorrect
						; or sequence error
sb5x:		0				; work location
sb5xad:		sb5x				;
;_____________________________________________________________________________
;
; This test verifies mode 6 swab instruction. This test
; uses a work location (sb6x) following the test code. Test data
; is loaded into the work location. R0, the addressing register
; is loaded with 6 less then the address of the work location.
; The mode 6 swab is executed with a +6 offset. The data is
; verified with a compare.
;
; TEST 177 - test mode 6 w/ swab inst.
;
ts177:		inc	(R2)			; update test number
		cmp	#177, (R2)		; sequence error?
		bne	sb6			; br to error halt on seq error
		mov	#125125, sb6x		; move pattern to work location
		mov	#sb6x-6, R0		; move offset pointer to R0
		swab	6(R0)			; try swab w/ mode 6
		cmp	#52652, 6(R0)		; check result
		beq	ts200
sb6:
		mov	#405, -(R2)		; move to mailbox #405
		inc	-(R2)			; set msgtyp to fatal error
		halt				; result of swab incorrect
						; or sequence error
sb6x:		0				; work location
;_____________________________________________________________________________
;
; This test verifies mode 7 swab instruction. This test
; uses two locations following the test code: a work location
; (sb7x) and a pointer to the work location (sb7xad). Data is moved
; to the work location. R0 is loaded with 72 less than the address
; of the address pointer. The data is swab'ed using a mode 7
; instruction with an offset of +72. The data is verified with a
; compare.
;
; TEST 200 - test mode 7 w/ swab inst.
;
ts200:		inc	(R2)			; update test number
		cmp	#200, (R2)		; sequence error?
		bne	sb7			; br to error halt on seq error
		mov	#177400, sb7x		; move pattern to work location
		mov	#sb7xad-72, R0		; move offset pointer to R0
		swab	@72(R0)			; try swab mode 7
		cmp	@72(R0), #377		; check results
		beq	ts201			;
sb7:						;
		mov	#406, -(R2)		; move to mailbox #406
		inc	-(R2)			; set msgtyp to fatal error
		halt				; result of swab incorrect
						; or sequence error
sb7x:		0				; work location
sb7xad:		sb7x				; pointer to work location
;_____________________________________________________________________________
;
; This test verifies all legal modes of the jmp instruction.
; Because of the nature of the instruction under test, this test
; utilizes several different techniques. The code is not executed
; in a linear fashion. The different modes are executed in order
; from 1-7; however. The code is arranged so that control leap
; frogs thru the test code. The order of appearance of the code
; is:
;		jmp	mode 1
;		jmp	mode 3
;		jmp	mode 2
;		jmp	mode 4
;		jmp	mode 6
;		jmp	mode 5
;		jmp	mode 7
; An internal sequence test (jmpseq) is used to insure that the
; jumps are occurring in the programmed sequence.
; The test is made up of several blocks of code. Each code
; begins with a label which indicates the mode being executed in
; that block. A simple procedure is followed in each block. For
; example the code beginning at jmp3 will first compare the results
; of the previous mode 2 jump. (any register changes are verified
; and the sequence check is made). Then the registers are setup
; for a mode 3 jump to the next test block (here, jmp4), the sequence
; checker is updated and the jmp is executed.
; If a failure occurs, the sequence checker will assist in
; determining just which mode failed. If the sequence is correct
; then the error detected was a mode failure (e.g. failure of the
; register to be incremented in mode 2 jump.)
;
; TEST 201 - test the jmp instruction in all modes
;
ts201:		inc	(R2)			; update test number
		cmp	#201, (R2)		; sequence error?
		bne	jmpck+6			; br to error halt on seq error
		clr	jmpseq			; establish a sequence checker
		mov	#jmp2, R0		; set R0=jump target
		jmp	(R0)			; try jmp mode 1
jmp3:		cmp	#.+2, R0		; check result of mode 2 jump
		beq	jmp3a			;
		mov	#407, -(R2)		; move to mailbox #407
		inc	-(R2)			; set msgtyp to fatal error
		halt				; register value after jmp mode 2 incorrect
jmp3a:		cmp	jmpseq, #1		; make sure jmps are in sequence: jmpseq=1?
		beq	jmp3b			;
		mov	#410, -(R2)		; move to mailbox #410
		inc	-(R2)			; set msgtyp to fatal error
		halt				; should be here from jmp mode 2 only
jmp3b:		mov	#ijmp4, R0		; point R0 to indirect jmp addr.
		inc	jmpseq			; update sequence checker
		jmp	@(R0)+			; try jmp mode 3
ijmp4:		jmp4				; address indirect jump
						;
jmp2:		tst	jmpseq			; check that jmps are in sequence: jmpseq=0?
		beq	jmp2a			;
		mov	#411, -(R2)		; move to mailbox #411
		inc	-(R2)			; set msgtyp to fatal error
		halt				; should be here from imp mode 1 only
jmp2a:		inc	jmpseq			; update sequence checker
		mov	#jmp3, R0		; set R0=jump target
		jmpR0				; try a jump mode 2 to "jmp3"
jmp4:		cmp	#ijmp4+2, R0		; check result of register in mode 3 jump
		beq	jmp4a			;
		mov	#412, -(R2)		; move to mailbox #412
		inc	-(R2)			; set msgtyp to fatal error
		halt				; register value after mode 3 jump incorrect
jmp4a:		cmp	#2, jmpseq		; check jump sequence: jmpseq=2?
		beq	jmp4b			;
		mov	#413, -(R2)		; move to mailbox #413
		inc	-(R2)			; set msgtyp to fatal error
		halt				; should be only from mode 3 jump
jmp4b:		mov	#jmp5+2, R0		; set up pointer to jump target
		inc	jmpseq			; update sequence checker
		jmp	-(R0)			; try jump mode 4 to "jmp4"
						;
jmp6:		cmp	#4, jmpseq		; check that jumps are in sequence: jmpseq=4?
		beq	jmp6a			;
		mov	#414, -(R2)		; move to mailbox #414
		inc	-(R2)			; set msgtyp to fatal error
		halt				; should be here only from mode 5 jump
jmp6a:		mov	#jmp7+376, R0		; set up offset pointer to jump target
		inc	jmpseq			; update jump sequence
		jmp	-376(R0)		; try mode 6 jump
						;
jmp5:		cmp	#3, jmpseq		; check that jumps are in sequence: jmpseq=3?
		beq	jmp5a			;
		mov	#415, -(R2)		; move to mailbox #415
		inc	-(R2)			; set msgtyp to fatal error
		halt				; should only be here from mode 4 jump
jmp5a:		mov	#ijmp5+2, R0		; set up pointer to indirect jump addr.
		inc	jmpseq			; update jump sequence
		jmp	@-(R0)			; try jump mode 5 to "jmp6"
ijmp5:		jmp6				; indirect address pointer
jmp7:		cmp	#5, jmpseq		; check jumps in sequence: jmpseq=5?
		beq	jmp7a			;
		mov	#416, -(R2)		; move to mailbox #416
		inc	-(R2)			; set msgtyp to fatal error
		halt				; should only be here from mode 6 jump
jmp7a:		mov	#ijmp+10, R0		; set up offset pointer to indirect addr.
		inc	jmpseq			; update jump sequence
		jmp	@-10(R0)		; try mode 7 jump
ijmp:		jmpck				; indirect address
jmpck:		cmp	jmpseq, #6		; check jumps in sequence: jmpseq
		beq	ts202			;
		mov	#417, -(R2)		; move to mailbox #417
		inc	-(R2)			; set msgtyp to fatal error
		halt				; should only be here crom mode 6 jump
						; or sequence error
jmpseq:		0
;_____________________________________________________________________________
;
; This test verifies all legal modes of the jsr instruction.
; The concept of leap frogging and sequence checking (jsrseq) is
; identical to that used in jmp test (see previous test). Each
; block of code verifies the previous jsr by checking the sequence,
; checking that the PC was saved in the specified register, checking
; that the SP was decremented, checking that the register was
; saved on the stack, and finally checking that any mode address
; register alterations (e.g. increment register in mode 2) were
; successful. R1 is used as the register in all jsr instructions.
; If a failure occurs, the sequence checker will assist in
; determining just which mode failed. If the sequence is correct
; then the error detected was a functional failure (e.g., incorrect
; register saved).
;
; TEST 202 - test jsr instruction w/ all modes
;
ts202:		inc	(R2)			; update test number
		cmp	#202, (R2)		; sequence error?
		bne	jsR0			; br to error halt on seq error
		br	jsR1			;
jsR0:		jmp	@#jsrck1		;
						;
jsR1:		mov	#stbot, SP		; set stack pointer
		mov	#jsR2, R0		; set target address
		clr	@#jsrseq		; initialize sequence checker
		clr	R1			; initialize R1
		com	R1			;
		jsr	R1, (R0)		; try jsr mode 1
jsR1a:						;
		mov	#420, -(R2)		; move to mailbox #420
		inc	-(R2)			; set msgtyp to fatal error
		halt				; jsr mode 1 failed
						;
jsR3:		cmp	#1, @#jsrseq		; check sequence: jsrseq=1?
		bne	jsR3a			; branch if out of sequence
		cmp	R1, #jsR4		; proper PC saved?
		bne	jsR3a			; branch if PC wrong
		cmp	#stbot-2, SP		; stack pointer decremented?
		bne	jsR3a			; branch if SP wrong
		cmp	#125252, (SP)		; reg saved on stack?
		bne	jsR3a			; branch if reg. not saved
		cmp	#jsR3+2, R0		; mode 2 increment correct?
		beq	jsR3b			;
jsR3a:						;
		mov	#421, -(R2)		; move to mailbox #421
		inc	-(R2)			; set msgtyp fatal error
		halt				; jsr mode 3 malfunctioned
jsR3b:		inc	@#jsrseq		; update sequence checker
		jsr	R1, @#jsR4		; try jsr mode 4
						;
jsR2:		tst	@#jsrseq		; check sequence: jsrseq=0?
		bne	jsR2a			; branch if out of sequence
		cmp	R1, #jsR1a		; proper PC saved?
		bne	jsR2a			; branch if PC wrong
		cmp	#stbot-2, SP		; SP decrement?
		bne	jsR2a			; branch if SP is incorrect
		cmp	(SP), #-1		; register saved?
		beq	jsR2b			;
jsR2a:						;
		mov	#422, -(R2)		; move to mailbox #422
		inc	-(R2)			; set msgtyp to fatal error
		halt				; jsr mode 1 malfunctioned
jsR2b:		mov	#stbot, SP		; initialize SP
		mov	#125252, R1		; initialize R1
		inc	@#jsrseq		; update sequence checker
		mov	#jsR3, R0		; set target address
		jsrR0	R1			; try jsr mode 2
						;
jsR4:		cmp	#2, @#jsrseq		; check sequence: jsrseq=2?
		bne	jsR4a			; branch if out of sequence
		cmp	#jsR2, R1		; proper PC saved?
		beq	jsR4b			;
jsR4a:						;
		mov	#423, -(R2)		; move to mailbox #423
		inc	-(R2)			; set msgtyp to fatal error
		halt				; jsr mode 3 malfunctioned
jsR4b:		inc	@#jsrseq		; update sequence checker
		mov	#jsR5+2, R0		; set target address
		jsr	R1, -(R0)		; try jsr mode 4
jsr6:		cmp	#4, jsrseq		; check sequence: jsrseq=4?
		bne	jsr6a			; branch if out of sequence
		cmp	#jsr7, R1		; proper PC saved?
		bne	jsr6a			; branch if PC wrong
		cmp	#jsr6ad, R0		; mode 5 register correct?
		beq	jsr6b			;
jsr6a:						;
		mov	#424, -(R2)		; move to mailbox #424
		inc	-(R2)			; set msgtyp to fatal error
		halt				; jsr mode 5 failed
jsr6b:		inc	@#jsrseq		; update sequence checker
		jsr	R1, jsr7		; try jsr mode 6
jsR5:		cmp	#3, jsrseq		; check sequence: jsrseq=3?
		bne	jsR5a			; branch if out of sequence
		cmp	#jsr6, R1		; proper PC saved?
		bne	jsR5a			; branch if PC wrong
		cmp	#jsR5, R0		; check mode 4 register
		beq	jsR5b			;
jsR5a:						;
		mov	#425, -(R2)		; move to mailbox #425
		inc	-(R2)			; set msgtyp to fatal error
		halt				; jsr mode 4 malfunctioned
jsR5b:		inc	@#jsrseq		; update sequence checker
		mov	#jsr6ad+2, R0		; point R0 to target address
		jsr	R1, @-(R0)		; try jsr mode 5
						;
jsr7:		cmp	#5, @#jsrseq		; check sequence: jsrseq=5?
		bne	jsr7a			; branch if out of sequence
		cmp	#jsR5, R1		; proper PC saved?
		beq	jsr7b			;
jsr7a:						;
		mov	#426, -(R2)		; move to mailbox #426
		inc	-(R2)			; set msgtyp to fatal error
		halt				; jsr mode 6 failed
jsr7b:		inc	@#jsrseq		; update sequence checker
		jsr	R1, @jsrckad		; try jsr mode 7
jsr6ad:		jsr6				; mode 5 target address
jsrckad:	jsrck				; mode 7 target address
jsrseq:		0				; sequence checker
jsrck:		cmp	#6, jsrseq		; check sequence: jsrseq=6?
		bne	jsrck1			; branch if out of sequence
		cmp	#jsr6ad, R1		; proper PC saved?
		beq	ts203			;
jsrck1:						;
		mov	#427, -(R2)		; move to mailbox #4?7
		inc	-(R2)			; set msgtyp to fatal error
		halt				; jsr mode 7 malfunctioned
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies the rts instruction. The stack pointer
; is initialized and a test pattern stored on stack. R0 is loaded
; with return address. An rts is executed, and, at the target
; address, a check is made that R0 was properly restored from the
; stack.
;
; TEST 203 - test rts instruction
;
ts203:		inc	(R2)			; update test number
		cmp	#203, (R2)		; sequence error?
		bne	ts204-10		; br to error halt on seq error
		mov	#stbot, SP		; initialize stack pointer
		mov	#52525, -(SP)		; initialize top of stack
		mov	#rts1, R0		; initialize return register
		rts	R0			; try rts through R0
		mov	#430, -(R2)		; move to mailbox #430
		inc	-(R2)			; set msgtyp to fatal error
		halt				; rts failed
rts1:		cmp	#52525, R0		; check that R0 restored from stack
		beq	ts204			;
		mov	#431, -(R2)		; move to mailbox #431
		inc	-(R2)			; set msgtyp to fatal error
		halt				; rts malfunctioned
						; or sequence error
;_____________________________________________________________________________
;
; These next four tests verify the functioning of a group
; of four instructions. The group consists of the instructions:
; mov, bic, bit and bis. These instructions are similar in the
; way they effect the C and V bits. They all leave the V-bit
; clear and the C-bit unaffected.
; The test procedure is as follows: the N, Z and V bits
; are loaded with the complement of the expected results, the C-bit
; is loaded with the desired result. The instruction is executed
; with different data patterns and the results are verified with
; a series of conditional branch instructions. The data is chosen
; to product all possible combinations of the C and V bits.
;
; TEST 204 - test mov instruction
;
ts204:		inc	(R2)			; update test number
		cmp	#204, (R2)		; sequence error?
		bne	ts205-10		; br to error halt on seq error
		scc				; cc=0110
		+cln!clc			;
		mov	#100000, R0		; cc=1000
		blos	mov1			;
		bvs	mov1			;
		bmi	mov2			;
mov1:						;
		mov	#432, -(R2)		; move to mailbox #432
		inc	-(R2)			; set msgtyp to fatal error
		halt				; mov did not set cc's correctly
mov2:		scc				; cc=1011
		clz				;
		mov	#0, R0			; cc=0101
		bhi	mov3			; C or Z = 0?
		bvs	mov3			; v=1?
		bpl	ts205			;
mov3:						;
		mov	#433, -(R2)		; move to mailbox #433
		inc	-(R2)			; set msgtyp to fatal error
		halt				; mov did not set cc's correctly
						; or sequence error
;_____________________________________________________________________________
;
; TEST 205 - test bit instruction
;
ts205:		inc	(R2)			; update test number
		cmp	#205, (R2)		; sequence error?
		bne	ts206-10		; br to error halt on seq error
		mov	#100001, R0		;
		scc				; cc=0110
		+cln!clc			;
		bit	#100000, R0		; cc=1000
		blos	bit1			;
		bvs	bit1			;
		bmi	bit2			;
bit1:						;
		mov	#434, -(R2)		; move to mailbox #434
		inc	-(R2)			; set msgtyp to fatal error
		halt				; bit did not set cc's correctly
bit2:		scc				; cc=1011
		clz				;
		bit	#77776, R0		; cc=0101
		bhi	bit3			;
		bvs	bit3			;
		bpl	ts206			;
bit3:						;
		mov	#435, -(R2)		; move to mailbox #435
		inc	-(R2)			; set msgtyp to fatal error
		halt				; bit did not set cc's correctly
						; or sequence error
;_____________________________________________________________________________
;
; TEST 206 - test bic instruction
;
ts206:		inc	(R2)			; update test number
		cmp	#206, (R2)		; sequence error?
		bne	ts207-10		; br to error halt on seq error
		mov	#177777, R0		;
		scc				; cc=0110
		+cln!clc			;
		bic	#77777, R0		; cc=1000
		blos	bic1			;
		bvs	bic1			;
		bmi	bic2			;
bic1:						;
		mov	#436, -(R2)		; move to mailbox #436
		inc	-(R2)			; set msgtyp to fatal error
		halt				; bic did not set cc's correctly
bic2:		scc				; cc=1011
		clz				;
		bic	#100000, R0		; cc=0101
		bhi	bic3			;
		bvs	bic3			;
		bpl	ts207			;
bic3:						;
		mov	#437, -(R2)		; move to mailbox #437
		inc	-(R2)			; set msgtyp to fatal error
		halt				; bic did not set cc's correctly
						; or sequence error
;_____________________________________________________________________________
;
; TEST 207 - test bis instruction
;
ts207:		inc	(R2)			; update test number
		cmp	#207, (R2)		; sequence error?
		bne	ts210-10		; br to error halt on seq error
		clr	R0			; R0=0
		scc				; cc=1010
		+cln!clc			;
		bis	#0, R0			; cc=0100 R0=0
		bcs	bis1			;
		bvs	bis1			;
		bmi	bis1			;
		beq	bis2			;
bis1:						;
		mov	#440, -(R2)		; move to mailbox #440
		inc	-(R2)			; set msgtyp to fatal error
		halt				; bis did not set cc's correctly
						;
bis2:		scc				; cc=0111
		cln				;
		bis	#177777, R0		; cc=1001
		bcc	bis3			;
		bvs	bis3			;
		beq	bis3			;
		bmi	ts210			;
bis3:		mov	#441, -(R2)		; move to mailbox #441
		inc	-(R2)			; set msgtyp to fatal error
		halt				; bis did not set cc's correctly
						; or sequence error
;_____________________________________________________________________________
;
; These next two tests verify the functioning of the inc and
; dec instructions. These instructions both effect the C and V
; bits the same; the C-bit is left unchanged and the V-bit is dependent
; upon the data results. The same procedure is used. the condition
; code bits are initialized, the instruction is executed and the
; results are verified with a series of conditional branch instructions.
; This procedure is repeated with several data patterns to produce
; different combinations of the C and V bits.
;
; TEST 210 - test inc instruction
;
ts210:		inc	(R2)			; update test number
		cmp	#210, (R2)		; sequence error?
		bne	ts211-10		; br to error halt on seq error
		mov	#077777, R0		; R0=077777
		ccc				; cc=0100
		sez				;
		inc	R0			; cc=1010 R0=10000
		blos	inc1			;
		bpl	inc1			;
		bvs	inc2			;
inc1:		mov	#442, -(R2)		; move to mailbox #442
		inc	-(R2)			; set msgtyp to fatal error
		halt				; inc did not set cc's correctly
						;
inc2:		bis	#77777, R0		; R0=177777
		sec				; cc=1011
		clz				;
		inc	R0			; cc=0101 R0=0
		bmi	inc3			;
		bvs	inc3			;
		bcc	inc3			;
		beq	inc4			;
inc3:		mov	#443, -(R2)		; move to mailbox #443
		inc	-(R2)			; set msgtyp to fatal error
		halt				; inc did not set cc's correctly
						;
inc4:		scc				; cc=1110
		clc				;
		inc	R0			; cc=0000 R0=1
		blos	inc5			;
		bmi	inc5			;
		bpl	ts211			;
inc5:						;
		mov	#444, -(R2)		; move to mailbox #444
		inc	-(R2)			; set msgtyp to fatal error
		halt				; inc did not set cc's correctly
						; or sequence error
;_____________________________________________________________________________
;
; TEST 211 - test dec instruction
;
ts211:		inc	(R2)			; update test number
		cmp	#211, (R2)		; sequence error?
		bne	ts212-10		; br to error halt on seq error
		mov	#2, R0			; R0=2
		scc				; cc=1111
		dec	R0			; cc=0001 R0=1
		bmi	dec1			;
		beq	dec1			;
		bvs	dec1			;
		bcs	dec2			;
dec1:						;
		mov	#445, -(R2)		; move to mailbox #445
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dec did not set cc's correctly
dec2:		sec				; cc=1011
		clz				;
		dec	R0			; cc=0101 R0=0
		bhi	dec3			;
		bmi	dec3			;
		bvc	dec4			;
dec3:						;
		mov	#446, -(R2)		; move to mailbox #446
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dec did not set cc's correctly
dec4:		scc				; cc=0110
		+cln!clc			;
		dec	R0			; cc=1000 R0=177777
		blos	dec5			;
		bvs	dec5			;
		bmi	dec6			;
dec5:						;
		mov	#447, -(R2)		; move to mailbox #44
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dec did not set cc's correctly
dec6:		bic	#77777, R0		; R0=100000
		scc				; cc=0101
		+cln!clv			;
		dec	R0			; cc=1011 R0=77777
		bmi	dec7			; cc=0011
		beq	dec7			;
		bvc	dec7			;
		bcs	ts212			;
dec7:		mov	#450, -(R2)		; move to mailbox #450
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dec did not set cc's correctly
						; or sequence error
;_____________________________________________________________________________
;
; These next three tests verify the functioning of the clr,
; tst and swab instructions. These three instructions all leave
; the C and V bits cleared. again, the condition codes are preset,
; the instruction executed and the results checked with conditional
; branch instructions. The procedure is repeated to produce other
; combinations of condition codes.
;
; TEST 212 - test clr instruction
;
ts212:		inc	(R2)			; update test number
		cmp	#212, (R2)		; sequence error?
		bne	ts213-10		; br to error halt on seq error
		scc				; cc=1011
		clz				;
		clr	R0			; cc=0100 R0=0
		bmi	clr1			;
		bvs	clr1			;
		bcs	clr1			;
		beq	ts213			;
clr1:						;
		mov	#451, -(R2)		; move to mailbox #451
		inc	-(R2)			; set msgtyp to fatal error
		halt				; clr did not set cc's correctly
						; or sequence error
;_____________________________________________________________________________
;
; TEST 213 - test tst instruction
;
ts213:		inc	(R2)			; update test number
		cmp	#213, (R2)		; sequence error?
		bne	ts214-10		; br to error halt on seq error
		scc				; cc=1011
		clz				;
		tst	R0			; cc=0100
		bmi	test1			;
		bvs	test1			;
		bcs	test1			;
		beq	test2			;
test1:						;
		mov	#452, -(R2)		; move to mailbox #452
		inc	-(R2)			; set msgtyp to fatal error
		halt				; test did not set cc's correctly
test2:		dec	R0			; make R0 negative
		scc				; cc=0111
		cln				;
		tst	R0			; cc=1000
		blos	test3			;
		bvs	test3			;
		bmi	ts214			;
test3:						;
		mov	#453, -(R2)		; move to mailbox #453
		inc	-(R2)			; set msgtyp to fatal error
		halt				; test did not set cc's correctly
						; or sequence error
;_____________________________________________________________________________
;
; TEST 214 - test swab instruction
;
ts214:		inc	(R2)			; update test number
		cmp	#214, (R2)		; sequence error?
		bne	ts215-10		; br to error halt on seq error
		mov	#170000, R0		; R0=170000
		scc				; cc=0111
		cln				;
		swab	R0			; cc=1000 R0=360
		blos	swb1			;
		bvs	swb1			;
		bmi	swb2			;
swb1:						;
		mov	#454, -(R2)		; move to mailbox #454
		inc	-(R2)			; set msgtyp to fatal error
		halt				; swab did not set cc's correctly
swb2:		scc				; cc=1011
		clz				;
		swab	R0			; cc=0100 R0=170000
		bvs	swb3			;
		bcs	swb3			;
		bmi	swb3			;
		beq	ts215			;
swb3:						;
		mov	#455, -(R2)		; move to mailbox #455
		inc	-(R2)			; set msgtyp to fatal error
		halt				;
;_____________________________________________________________________________
;
; These next two tests verify the functioning of the add and
; adc instructions. Both of these instructions handle the C and
; V bits identically. The procedure is to preset the condition
; codes, execute the instruction with a particular set of data, and
; then check the results by executing a series of conditional
; branches. Thes procedure is repeated several times with different
; data to produce every combination of C and V bits.
;
; TEST 215 - test add instruction
;
ts215:		inc	(R2)			; update test number
		cmp	#215, (R2)		; sequence error?
		bne	ts216-10		; br to error halt on seq error
		mov	#40000, R0		; R0=40000
		scc				; cc=1111
		add	#30000, R0		; cc=0000 R0=70000
		blos	add1			;
		bvs	add1			;
		bpl	add2			;
add1:						;
		mov	#456, -(R2)		; move to mailbox #456
		inc	-(R2)			; set msgtyp to fatal error
		halt				; add did not set cc's correctly
add2:		sez				; cc=0100
		add	#10000, R0		; cc=1010 R0=100000
		blos	add3			;
		bvc	add3			;
		bmi	add4			;
add3:						;
		mov	#457, -(R2)		; move to mailbox #457
		inc	-(R2)			; set msgtyp to fatal error
		halt				; add did not set cc's correctly
add4:		ccc				; cc=1000
		sen				;
		add	#100000, R0		; cc=0111 R0=0
		bhi	add5			;
		bvc	add5			;
		bpl	add6			;
add5:						;
		mov	#460, -(R2)		; move to mailbox #460
		inc	-(R2)			; set msgtyp to fatal error
		halt				; add did not set cc's correctly
add6:		add	#177777, R0		; cc=1000 R0=177777
		blos	add7			;
		bvs	add7			;
		bmi	add8			;
add7:						;
		mov	#461, -(R2)		; move to mailbox #461
		inc	-(R2)			; set msgtyp to fatal error
		halt				; add did not set cc's correctly
add8:		scc				; cc=1010
		+clc!clz			;
		add	#1, R0			; cc=0101 R0=0
		bvs	add9			;
		bcc	add9			;
		bmi	add9			;
		beq	ts216			;
add9:						;
		mov	#462, -(R2)		; move to mailbox #462
		inc	-(R2)			; set msgtyp to fatal error
		halt				; add did not set cc's correctly
						; or sequence error
;_____________________________________________________________________________
;
; TEST 216 - test adc instruction
;
ts216:		inc	(R2)			; update test number
		cmp	#216, (R2)		; sequence error?
		bne	ts217-10		; br to error halt on seq error
		mov	#077777, R0		;
		scc				; cc=0101
		+cln!clv			;
		adc	R0			; cc=1010
		blos	adc1			;
		bvc	adc1			;
		bmi	adc2			;
adc1:						;
		mov	#463, -(R2)		; move to mailbox #463
		inc	-(R2)			; set msgtyp to fatal error
		halt				; adc did not set cc's correctly
adc2:		bis	#77777, R0		;
		scc				; cc=1011
		clz				;
		adc	R0			; cc=0101 R0=0
		bhi	adc3			;
		bvs	adc3			;
		bpl	adc4			;
adc3:						;
		mov	#464, -(R2)		; move to mailbox #464
		inc	-(R2)			; set msgtyp to fatal error
		halt				; adc did not set cc's correctly
adc4:		scc				;
		+clz!clc			; cc=1010
		adc	R0			; cc=0100
		bvs	adc5			;
		bcs	adc5			;
		bmi	adc5			;
		beq	ts217			;
adc5:						;
		mov	#465, -(R2)		; move to mailbox #465
		inc	-(R2)			; set msgtyp to fatal error
		halt				; adc did not set cc's correctly
						; or sequence error
;_____________________________________________________________________________
;
; These next three tests verify the functioning of the neg,
; cmp. and com instructions. Each of these instructions generate
; the C and V bits identically. The condition codes ape preset.
; the instructions executed, and the results checked with a series
; of conditional branch instructions. This procedure is repeated
; several times with different data in order to generate different
; combinations of the C and V bits.
;
; TEST 217 - test neg instruction
;
ts217:		inc	(R2)			; update test number
		cmp	#217, (R2)		; sequence error?
		bne	ts220-10		; br to error halt on seq error
		mov	#1, R0			;
		scc				; cc=0110
		+cln!clc			;
		neg	R0			; cc=1001 R0=177777
		bcc	neg1			;
		bvs	neg1			;
		beq	neg1			;
		bmi	neg2			;
neg1:						;
		mov	#466, -(R2)		; move to mailbox #466
		inc	-(R2)			; set msgtyp to fatal error
		halt				; neg did not set cc's correctly
neg2:		bic	#77777, R0		;
		ccc				; cc=0100
		sez				;
		neg	R0			; cc=1011 R0=100000
		bvc	neg3			;
		bcc	neg3			;
		beq	neg3			;
		bmi	neg4			;
neg3:						;
		mov	#467, -(R2)		; move to mailbox #467
		inc	-(R2)			; set msgtyp to fatal error
		halt				; neg did not set cc's correctly
neg4:		clr	R0			;
		scc				; cc=1011
		clz				;
		neg	R0			; cc=0100 R0=0
		bvs	neg5			;
		bcs	neg5			;
		bne	neg5			;
		bpl	ts220			;
neg5:						;
		mov	#470, -(R2)		; move to mailbox #470
		inc	-(R2)			; set msgtyp to fatal error
		halt				; neg did not set cc's correctly
						; or sequence error
;_____________________________________________________________________________
;
; TEST 220 - test cmp instruction
;
ts220:		inc	(R2)			; update test number
		cmp	#220, (R2)		; sequence error?
		bne	ts221-10		; br to error halt on seq error
		mov	#5, R0			;
		ccc				; cc=1010
		+sen!sec			;
		cmp	#5, R0			; cc=0101
		bhi	cmp1			;
		bvs	cmp1			;
		bpl	cmp2			;
cmp1:						;
		mov	#471, -(R2)		; move to mailbox #471
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cmp did not set cc's correctly
cmp2:		mov	#100000, R0		;
		scc				; cc=1101
		clv				;
		cmp	R0, #77777		; cc=0010
		blos	cmp3			;
		bvc	cmp3			;
		bpl	cmp4			;
cmp3:						;
		mov	#472, -(R2)		; move to mailbox #472
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cmp did not set cc's correctly
cmp4:		bis	#40000, R0		; R0=140000
		ccc				; cc=0100
		sez				;
		cmp	#40000, R0		; cc=1011
		bvc	cmp5			;
		bcc	cmp5			;
		beq	cmp5			;
		bmi	cmp6			;
cmp5:						;
		mov	#473, -(R2)		; move to mailbox #473
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cmp did not set cc's correctly
cmp6:		bic	#40000, R0		;
		scc				; cc=1111
		cmp	#-1, R0			; cc=0000
		blos	cmp7			;
		bvs	cmp7			;
		bpl	ts221			;
cmp7:						;
		mov	#474, -(R2)		; move to mailbox #474
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cmp did not set cc's correctly
						; or sequence error
;_____________________________________________________________________________
;
; TEST 221 - test com instruction
;
ts221:		inc	(R2)			; update test number
		cmp	#221, (R2)		; sequence error?
		bne	ts222-10		; br to error halt on seq error
		mov	#-1, R0			;
		ccc				; cc=1010
		+sec!sez			;
		com	R0			; cc=0101
		bhi	com1			;
		bvs	com1			;
		bpl	ts222			;
com1:						;
		mov	#475, -(R2)		; move to mailbox #475
		inc	-(R2)			; set msgtyp to fatal error
		halt				; com did not set cc's correctly
						; or sequence error
;_____________________________________________________________________________
;
; These next two tests verify the iunctioning of the sub
; and sbc instructions. Both of these instructions handle the
; C and V bits identically. The procedure is to preset the condition
; codes, execute the instruction with a particular set of data, and
; then check the results by executing a series of conditional
; branches, this procedure is repeated several times with different
; data patterns to provide every combination of the C and V bits.
;
; TEST 222 - test sub instruction
;
ts222:		inc	(R2)			; update test number
		cmp	#222, (R2)		; sequence error?
		bne	ts223-10		; br to error halt on seq error
		mov	#125252, R0		;
		ccc				; cc=1010
		+sen!sec			;
		sub	#125252, R0		; cc=0101 R0=0
		bhi	sub1			;
		bvs	sub1			;
		bpl	sub2			;
sub1:						;
		mov	#476, -(R2)		; move to mailbox #476
		inc	-(R2)			; set msgtyp to fatal error
		halt				; sub did not set cc's correctly
sub2:		bis	#100000, R0		;
		scc				; cc=1101
		clv				;
		sub	#77777, R0		; cc=0010 R0=1
		blos	sub3			;
		bvc	sub3			;
		bpl	sub4			;
sub3:						;
		mov	#477, -(R2)		; move to mailbox #477
		inc	-(R2)			; set msgtyp to fatal error
		halt				;
sub4:		com	R0			; R0=177777
		scc				; cc=11111
		sub	#100000, R0		; cc=0000 R0=77777
		blos	sub5			;
		bvs	sub5			;
		bpl	sub6			;
sub5:						;
		mov	#500, -(R2)		; move to mailbox #500
		inc	-(R2)			; set msgtyp to fatal error
		halt				; sub did not set cc's correctly
sub6:		ccc				; cc=0100
		sez				;
		sub	#140000, R0		; cc=1011
		bvc	sub7			;
		bcc	sub7			;
		beq	sub7			;
		bmi	ts223			;
sub7:						;
		mov	#501, -(R2)		; move to mailbox #501
		inc	-(R2)			; set msgtyp to fatal error
		halt				;
;_____________________________________________________________________________
;
; TEST 223 - test sbc instruction
;
ts223:		inc	(R2)			; update test number
		cmp	#223, (R2)		; sequence error?
		bne	ts224-10		; br to error halt on seq error
		mov	#1, R0			;
		scc				; cc=1011
		clz				;
		sbc	R0			; cc=0100 r=0
		bcs	sbc1			;
		bvs	sbc1			;
		bmi	sbc1			;
		beq	sbc2			;
sbc1:						;
		mov	#502, -(R2)		; mov2 to mailbox #502
		inc	-(R2)			; set msgtyp to fatal error
		halt				; sbc did not set cc's correctly
sbc2:		scc				; cc=1010
		+clz!clc			;
		sbc	R0			; cc=0100 r=0
		bcs	sbc3			;
		bvs	sbc3			;
		bmi	sbc3			;
		beq	sbc4			;
sbc3:						;
		mov	#503, -(R2)		; move to mailbox #503
		inc	-(R2)			; set msgtyp to fatal error
		halt				; 5bc did not set cc's correctly
sbc4:		scc				; cc=0111
		cln				;
		sbc	R0			; cc=1001 R0=177777
		bcc	sbc5			;
		bvs	sbc5			;
		beq	sbc5			;
		bmi	sbc6			;
sbc5:						;
		mov	#504, -(R2)		; move to mailbox #504
		inc	-(R2)			; set msgtyp to fatal error
		halt				; sbc did not set cc's correctly
sbc6:		bic	#77777, R0		; R0=100000
		scc				; cc=1101
		clv				;
		sbc	R0			; cc=0010
		blos	sbc7			;
		bvc	sbc7			;
		bpl	ts224			;
sbc7:						;
		mov	#505, -(R2)		; move to mailbox #505
		inc	-(R2)			; set msgtyp to fatal error
		halt				; sbc did not set cc's correctly
						; or sequence error
;_____________________________________________________________________________
;
; These next four tests verify the functioning of the rol,
; ror, asl and asr instructions, special data patterns are loaded
; and rotated several times for each test, the condition codes
; are preset before each rotation and the condition codes are
; checked after each rotation, the final check in each test is
; to verify the cummulative data result, the data patterns have
; been selected to produce all combinations of the C and V bits.
;
; TEST 224 - test rol instruction
;
ts224:		inc	(R2)			; update test number
		cmp	#224, (R2)		; sequence error?
		bne	ts225-10		; br to error halt on seq error
		mov	#144000, R0		; R0=144000
		ccc				; cc=0110
		+sez!sev			;
		rol	R0			; cc=1001 R0=110000
		bcc	rol1			;
		bvs	rol1			;
		beq	rol1			;
		bmi	rol2			;
rol1:						;
		mov	#506, -(R2)		; move to mailbox #506
		inc	-(R2)			; set msgtyp to fatal error
		halt				;
rol2:		scc				; cc=1100
		+clv!clc			;
		rol	R0			; cc=0011 R0=020000
		bcc	rol3			;
		bvc	rol3			;
		beq	rol3			;
		bpl	rol4			;
rol3:						;
		mov	#507, -(R2)		; move to mailbox #507
		inc	-(R2)			; set msgtyp to fatal error
		halt				; rol did not set cc's correctly
rol4:		scc				; cc=0111
		cln				;
		rol	R0			; cc=0000 R0=040001
		blos	rol5			;
		bvs	rol5			;
		bpl	rol6			;
rol5:						;
		mov	#510, -(R2)		; move to mailbox #510
		inc	-(R2)			; set msgtyp to fatal error
		halt				; rol did not set cc's correctly
rol6:		ccc				; cc=0101
		+sez!sec			;
		rol	R0			; cc=1010 R0=100003
		blos	rol7			;
		bvc	rol7			;
		bpl	rol7			;
		cmp	#100003, R0		;
		beq	ts225			;
rol7:						;
		mov	#511, -(R2)		; move to mailbox #511
		inc	-(R2)			; set msgtyp to fatal error
		halt				; rol malfunctioned
						; or sequence error
;_____________________________________________________________________________
;
; TEST 225 - test ror instruction
;
ts225:		inc	(R2)			; update test number
		cmp	#225, (R2)		; sequence error?
		bne	ts226-10		; br to error halt on seq error
		mov	#23, R0			; R0=23
		scc				; cc=0111
		cln				;
		ror	R0			; cc=1001 R0=100011
		bvs	roR1			;
		bcc	roR1			;
		beq	roR1			;
		bmi	roR2			;
roR1:						;
		mov	#512, -(R2)		; move to mailbox #512
		inc	-(R2)			; set msgtyp to fatal error
		halt				; ror did not set cc's correctly
roR2:		ccc				; cc=1100
		+sen!sez			;
		ror	R0			; cc=0011 R0=040004
		bvc	roR3			;
		bcc	roR3			;
		beq	roR3			;
		bpl	roR4			;
roR3:						;
		mov	#513, -(R2)		; move to mailbox #513
		inc	-(R2)			; set msgtyp to fatal error
		halt				; ror did not set cc's correctly
roR4:		scc				; cc=1110
		clc				;
		ror	R0			; cc=0000 R0=020002
		blos	roR5			;
		bvs	roR5			;
		beq	roR5			;
		bpl	ror6			;
roR5:						;
		mov	#514, -(R2)		; move to mailbox #514
		inc	-(R2)			; set msgtyp to fatal error
		halt				; ror did not set cc's correctly
ror6:		ccc				; cc=0101
		+sec!sez			;
		ror	R0			; cc=1010 R0=110001
		blos	ror7			;
		bvc	ror7			;
		bmi	ts226			;
ror7:						;
		mov	#515, -(R2)		; move to mailbox #515
		inc	-(R2)			; set msgtyp to fatal error
		halt				; ror did not produce correct results
						; or sequence error
;_____________________________________________________________________________
;
; TEST 226 - test asl instruction
;
ts226:		inc	(R2)			; update test number
		cmp	#226, (R2)		; sequence error?
		bne	ts227-10		; br to error halt on seq error
		mov	#144000, R0		; R0=14000
		ccc				; cc=0110
		+sen!sec			;
		asl	R0			; cc=1001 R0=110000
		bcc	asl1			;
		bvs	asl1			;
		beq	asl1			;
		bmi	asl2			;
asl1:						;
		mov	#516, -(R2)		; move to mailbox #516
		inc	-(R2)			; set msgtyp to fatal error
		halt				;
asl2:		scc				; cc=1100
		+clv!clc			;
		asl	R0			; cc=0011 R0=020000
		bcc	asl3			;
		bvc	asl3			;
		beq	asl3			;
		bpl	asl4			;
asl3:						;
		mov	#517, -(R2)		; move to mailbox #517
		inc	-(R2)			; set msgtyp to fatal error
		halt				; asl did not set cc's correctly
asl4:		scc				; cc=0111
		cln				;
		asl	R0			; cc=0000 R0=040000
		blos	asl5			;
		bvs	asl5			;
		bpl	asl6			;
asl5:						;
		mov	#520, -(R2)		; move to mailbox #520
		inc	-(R2)			; set msgtyp to fatal error
		halt				; asl did not set cc's correctly
asl6:		ccc				; cc=0101
		+sez!sec			;
		asl	R0			; cc=1010 R0=100000
		bcs	asl7			;
		beq	asl7			;
		bvc	asl7			;
		bpl	asl7			;
		cmp	#100000, R0		;
		beq	ts227			;
asl7:						;
		mov	#521, -(R2)		; move to mailbox #521
		inc	-(R2)			; set msgtyp to fatal error
		halt				; asl malfunctioned
						; or sequence error
;_____________________________________________________________________________
;
; TEST 227 - test asr instruction
;
ts227:		inc	(R2)			; update test number
		cmp	#227, (R2)		; sequence error?
		bne	ts230-10		; br to error halt on seq error
		mov	#100023, R0		; R0=100023
		scc				; cc=0110
		cln				;
		asr	R0			; cc=1001 R0=140011
		bvs	asR1			;
		bcc	asR1			;
		beq	asR1			;
		bmi	asR2			;
asR1:						;
		mov	#522, -(R2)		; move to mailbox #522
		inc	-(R2)			; set msgtyp to fatal error
		halt				; asr did not set cc's correctly
asR2:		bic	#100000, R0		; R0=40011
		scc				; cc=1100
		+clv!clc			;
		asr	R0			; cc=0011 R0=020004
		bvc	asR3			;
		bcc	asR3			;
		beq	asR3			;
		bpl	asR4			;
asR3:						;
		mov	#523, -(R2)		; move to mailbox #523
		inc	-(R2)			; set msgtyp to fatal error
		halt				; asr did not set cc's correctly
asR4:		scc				; cc=1111
		asr	R0			; cc=0000 R0=010002
		blos	asR5			;
		bvs	asR5			;
		beq	asR5			;
		bpl	asr6			;
asR5:						;
		mov	#524, -(R2)		; move to mailbox #524
		inc	-(R2)			; set msgtyp to fatal error
		halt				; asr did not set cc's correctly
asr6:		bis	#100000, R0		; R0=110002
		ccc				; cc=0101
		+sez!sec			;
		asr	R0			; c=1010 R0=144001
		blos	asr7			;
		bvc	asr7			;
		bpl	asr7			;
		beq	asr7			;
		cmp	#144001, R0		; check result of asr's
		beq	ts230			;
 asr7:						;
		mov	#525, -(R2)		; move to mailbox #525
		inc	-(R2)			; set msgtyp to fatal error
		halt				; asr did not function correctly
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies the sxt instruction. condition codes
; are preset in each of the two possible cases. with the N-bit set,
; the test checks for all ones in the destination. with the N-bit
; clear. The destination should contain all zeroes. The data
; is verified by conditional branches.
;
; TEST 230 - test the sxt instruction
;
ts230:		inc	(R2)			; update test number
		cmp	#230, (R2)		; sequence error?
		bne	ts231-10		; br to error halt on seq error
		clr	R0			;
		scc				; set cc=1011
		clz				;
		sxt	R0			; try sxt
		bpl	sxt0			; test cc=1001
		beq	sxt0			;
		bvs	sxt0			;
		bcc	sxt0			;
		cmp	#-1, R0			; check data result
		beq	sxt1			;
sxt0:						;
		mov	#526, -(R2)		; move to mailbox #526
		inc	-(R2)			; set msgtyp to fatal error
		halt				; results of sxt incorrect
sxt1:		clr	R0			; R0=0
		clr	(R0)			; loc.0=0
		com	(R0)			; loc.0=177777
		ccc				; set cc=0110
		+sez!sev			;
		sxt	(R0)			;
		bne	sxt2			; test cc=0100
		bcs	sxt2			;
		bvs	sxt2			;
		bmi	sxt2			;
		tst	(R0)			;
		beq	ts231			;
sxt2:						;
		mov	#527, -(R2)		; move to mailbox #527
		inc	-(R2)			; set msgtyp to fatal error
		halt				; results of sxt incorrect
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies the xor instruction. Unique patterns
; of ones and zeroes are moved to data registers R0 and R1.
; After the first xor instruction R0=36146. An xor is then
; executed with this new value and the contents of R1 to
; reproduce the original value if R0=31525.
;
; TEST 231 - test the xor instruction
;
ts231:		inc	(R2)			; update test number
		cmp	#231, (R2)		; sequence error?
		bne	ts232-10		; br to error halt on seq error
		mov	#7463, R0		; set up R0
		mov	#31525, R1		; set up R1
		scc				; set cc=1110
		clc				;
		xor	R1, R0			; try xor
		blos	xor1			; cc=0000?
		bvs	xor1			;
		beq	xor1			;
		bmi	xor1			;
		cmp	#36146, R0		; data result correct?
		beq	xor2			;
xor1:						;
		mov	#530, -(R2)		; move to mailbox #530
		inc	-(R2)			; set msgtyp to fatal error
		halt				;
xor2:		mov	R1, R4			;
		sec				; cc=1110
		clc				;
		xor	R4, R0			; try xor mode 0, 0
		blos	xor3			; cc=0000?
		bvs	xor3			;
		beq	xor3			;
		bmi	xor3			;
		cmp	#7463, R0		;
		beq	ts232			;
xor3:						;
		mov	#531, -(R2)		; move to mailbox #531
		inc	-(R2)			; set msgtyp to fatal error
		halt				; result of xor incorrect
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies the sob instruction. R4 is used as a
; counter while R0 is the address register. Conditional
; branches are used to verify proper transfer of control
; while R4 is checked to insure proper decrementing of R0.
;
; TEST 232 - test sob instruction
;
ts232:		inc	(R2)			; update test number
		cmp	#232, (R2)		; sequence error?
		bne	ts233-10		; br to error halt on seq error
		mov	#525, R0		;
		mov	R0, R4			;
		scc				; set cc=1111
sob1:		bhi	sob2			; cc=1111?
		bpl	sob2			;
		bvs	sob3			;
sob2:						;
		mov	#532, -(R2)		; move to mailbox #532
		inc	-(R2)			; set msgtyp to fatal error
		halt				;
sob3:		dec	R4			; count iterations
		scc				; cc=1111
		sob	R0, sob1		;	; do sob w/ R0
		bhi	sob4			; check cc=1111
		bpl	sob4			;
		bvc	sob4			;
		tst	R4			; iteration count ok?
		beq	ts233			;
sob4:						;
		mov	#533, -(R2)		; move to mailbox #533
		inc	-(R2)			; set msgtyp to fatal error
		halt				; incorrect # of branches or cc's changed
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies the mark instruction. the effects
; of the mark instruction are simulated by the program instructions.
; The contents of R5 and the stack pointer are checked after each
; of the two routines in the test.
;
; TEST 233 - test mark instruction
;
ts233:		inc	(R2)			; update test number
		cmp	#233, (R2)		; sequence error?
		bne	ts234-10		; br to error halt on seq error
		mov	#stbot, SP		;
		mov	#125252, -(SP)		; put R5 value on stack
		sub	#74, SP			; effectively put 36 arguments on stack
		mov	#mrk1, R5		; set new PC in R5
		mov	#6436, -(SP)		; put mark 36 inst. on stack
		scc				; set cc=1111
		jmp	(SP)			; xfer contl to mark 36 inst. on stack
		mov	#534, -(R2)		; move to mailbox #534
		inc	-(R2)			; set msgtyp to fatal error
		halt				; mark inst. should have jumped to mrk1
mrk1:		bhi	mrk2			; test cc unaffected
		bpl	mrk2			; iest cc=1111
		bvc	mrk2			;
		cmp	R5, #125252		; check R5 restored from stack
		bne	mrk2			;
		cmp	#stbot, SP		; check stack pointer readjusted correctly.
		beq	mrk3			;
mrk2:						;
		mov	#535, -(R2)		; move to mailbox #535
		inc	-(R2)			; set msgtyp to fatal error
		halt				; results of mark incorrect
mrk3:		mov	#52525, -(SP)		;
		mov	#6400, -(SP)		; put mark 0 inst. on stack
		mov	SP, R5			; set addr. of mark inst. in R5
		jsr	PC, @#mrk4		; do jsr
		jmp	@#mrk5			;
mrk4:		rts	R5			; do rts with R5 to mark inst. on stack
		mov	#536, -(R2)		; move to mailbox #536
		inc	-(R2)			; set msgtyp to fatal error
		halt				; rts mark sequence failed
mrk5:		cmp	#stbot, SP		; stack adjusted correctly
		bne	mrk6			; if not: br
		cmp	#52525, R5		; check if R5 restored from stack
		beq	ts234			;
mrk6:						;
		mov	#537, -(R2)		; move to mailbox #537
		inc	-(R2)			; set msgtyp to fatal error
		halt				; results of mark incorrect
						; or sequence error
		ps	= 177776		;
;_____________________________________________________________________________
;
; These next seven tests verify the mtps instruction in all
; modes. The PSW is defined by an equate statement before tme
; first mtps test. In each test a pattern of ones and
; zeroes is set in a data register and moved to the PSW.
; The data in the PSW, and the data register address
; are checked to verify proper execution of the instruction.
;
; TEST 234 - test mtps instruction
;
ts234:		inc	(R2)			; update test number
		cmp	#234, (R2)		; sequence error?
		bne	ts235-10		; br to error halt on seq error
		mov	#377, R0		;
		ccc				;
		mtps	R0			;
		cmp	#357, ps		;
		beq	mtps1			;
		mov	#540, -(R2)		; move to mailbox #540
		inc	-(R2)			; set msgtyp to fatal error
		halt				; mtps failed
mtps1:		clr	R0			;
		clr	(R0)			;
		scc				; cc=1111
		mtps	(R0)			; try mtps mode 1
		bmi	mtps1a			; check ps
		bvs	mtps1a			;
		bcs	mtps1a			;
		bne	ts235			;
mtps1a:						;
		mov	#541, -(R2)		; move to mailbox #541
		inc	-(R2)			; set msgtyp to fatal error
		halt				; mtps failed
						; or sequence error
;_____________________________________________________________________________
;
; TEST 235 - test mtps mode 2
;
ts235:		inc	(R2)			; update test number
		cmp	#235, (R2)		; sequence error?
		bne	ts236-10		; br to error halt on seq error
		clr	R0			; R0=0
		mov	#-1, (R0)		; loc.0=-1
		clr	@#ps			; ps=0
		mtps	(R0)+			; try mtps w/ mode 2
		cmp	#357, @#ps		; check data
		beq	mtps2			;
		mov	#542, -(R2)		; move to mailbox #542
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. data incorrect
mtps2:		cmp	#1, R0			; chfck dest. register.
		beq	ts236			;
		mov	#543, -(R2)		; move to mailbox #543
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest register not incremented by 1
						; or sequence error
;_____________________________________________________________________________
;
; TEST 236 - test mtps mode 3
;
ts236:		inc	(R2)			; update test number
		cmp	#236, (R2)		; sequence error?
		bne	ts237-10		; br to error halt on seq error
		mov	#402, R0		; R0=402
		clr	(R0)			; loc.402=0
		mov	#52652, @#0		; loc.0=52652
		clr	@#ps			; ps=0
		mtps	@(R0)+			; try mtps w/ mode 3
		cmp	#252, @#ps		; check dest. data
		beq	mtps3			;
		mov	#544, -(R2)		; move to mailbox #544
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. data incorrect
mtps3:		cmp	#404, R0		; check mode 3 register.
		beq	ts237			;
		mov	#545, -(R2)		; move to mailbox #545
		inc	-(R2)			; set msgtyp to fatal error
		halt				; mode 3 register incorrect
						; or sequence error
;_____________________________________________________________________________
;
; TEST 237 - test mtps mode 4
;
ts237:		inc	(R2)			; update test number
		cmp	#237, (R2)		; sequence error?
		bne	ts240-10		; br to error halt on seq error
		mov	#1, R0			; R0=1
		mov	#125125, @#0		; loc.0=125125
		clr	@#ps			; ps=0
		mtps	-(R0)			; try mtps w/ mode 4
		cmp	#105, @#ps		; check dest. data
		beq	mtps4			;
		mov	#546, -(R2)		; move to mailbox #546
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. data incorrect
mtps4:		tst	R0			; check mode 4 register
		beq	ts240			;
		mov	#547, -(R2)		; move to mailbox #547
		inc	-(R2)			; set msgtyp to fatal error
		halt				; mode 4 register not decremented by 1
						; or sequence error
;_____________________________________________________________________________
;
; TEST 240 - test mtps mode 5
;
ts240:		inc	(R2)			; update test number
		cmp	#240, (R2)		; sequence error?
		bne	ts241-10		; br to error halt on seq error
		mov	#404, R0		; R0=404
		mov	#177400, @#0		; loc.0=177400
		scc				; set all cond. codes
		mtps	@-(R0)			; try mtps w/ mode 5
		tst	@#ps			; check dest. data.
		beq	mtps5			;
		mov	#550, -(R2)		; move to mailbox #550
		inc	-(R2)			; set msgtyp to fatal error
		halt				; destination data incorrect
mtps5:		cmp	#402, R0		; check mode 5 register
		beq	ts241			;
		mov	#551, -(R2)		; move to mailbox #551
		inc	-(R2)			; set msgtyp to fatal error
		halt				; mode 5 register not decremented by 2
						; or sequence error
;_____________________________________________________________________________
;
; TEST 241 - test mtps	mode 6
;
ts241:		inc	(R2)			; update tes< number
		cmp	#241, (R2)		; sequence error?
		bne	ts242-10		; br to error halt on seq error
		mov	#52652, @#0		; loc.0=52652
		mov	#406, R0		; R0=406
		clr	@#ps			; ps=0
		mtps	-406(R0)		; try mtps w/ mode 6
		cmp	#252, @#ps		; check dest. data
		beq	mtps6			;
		mov	#552, -(R2)		; move to mailbox #552
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. data incorrect
mtps6:		cmp	#406, R0		; check mode 6 register
		beq	ts242			;
		mov	#553, -(R2)		; move to mailbox #553
		inc	-(R2)			; set msgtyp to fatal error
		halt				; mode 6 register modified
						; or sequence error
;_____________________________________________________________________________
;
; TEST 242		test mtps mode 7
;
ts242:		inc	(R2)			; update test number
		cmp	#242, (R2)		; sequence error?
		bne	ts243-10		; br to error halt on seq error
		mov	#52652, @#0		; loc.0=52652
		mov	#410, R0		; R0=410
		clr	@#ps			; ps=0
		mtps	@-2(R0)			; try mtps w/ mode 7
		cmp	#105, @#ps		; check dest. data
		beq	mtps7			;
		mov	#554, -(R2)		; move to mailbox #554
		inc	-(R2)			; set msgtyp to fatal error
		halt				; destination data incorrect
mtps7:		cmp	#410, R0		; check mode 7 register
		beq	ts243			;
		mov	#555, -(R2)		; move to mailbox #555
		inc	-(R2)			; set msgtyp to fatal error
		halt				; mode 7 register modified
						; or sequence error
;_____________________________________________________________________________
;
; These next seven tests verify the mtps instruction in ah
; modes. In each test, a pattern of ones and zeroes is moved to the
; PSW, and an mfps instruction moves the data to a location setup
; by R0, either directly or indirectly. Conditional branches are
; used to check proper addressing and data.
;
; TEST 243 - test mfps instruction
;
ts243:		inc	(R2)			; update test number
		cmp	#243, (R2)		; sequence error?
		bne	ts244-10		; br to error halt on seq error
		mov	#377, @#ps		;
		mfps	R0			;
		cmp	#177757, R0		;
		beq	mfps1			;
		mov	#556, -(R2)		; move to mailbox #556
		inc	-(R2)			; set msgtyp to fatal error
		halt				; mfps failed
mfps1:		clr	R0			;
		mov	#-1, @#0		;
		clr	@#ps			;
		mfps	(R0)			;
		tstb	@#0			;
		beq	ts244			;
		mov	#557, -(R2)		; move to mailbox #557
		inc	-(R2)			; set msgtyp to fatal error
		halt				; mfps failed
						; or sequence error
;_____________________________________________________________________________
;
; TEST 244 - test mfps mode 2
;
ts244:		inc	(R2)			; update test number
		cmp	#244, (R2)		; sequence error?
		bne	ts245-10		; br to error halt on seq error
		clr	R0			; R0=0
		clr	(R0)			; loc.0=0
		mov	#377, @#ps		; set ps=357
		mfps	(R0)+			; try mfps w/ mode 2
		bcc	mfps2a			; br to error if C-bit clear
		bvs	mfps2a			; br to error if V-bit set
		beq	mfps2a			; br to error if Z-bit set
		bmi	mfps2b			;
mfps2a:						;
		mov	#560, -(R2)		; move to mailbox #560
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cond. codes incorrect
mfps2b:		cmp	#357, @#0		; check dest. data
		beq	mfps2c			;
		mov	#561, -(R2)		; move to mailbox #561
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. data incorrect
mfps2c:		cmp	#1, R0			; check mode 2 register
		beq	ts245			;
		mov	#562, -(R2)		; move to mailbox #562
		inc	-(R2)			; set msgtyp to fatal error
		halt				; mode 2 register not incremented 1
						; or sequence error
;_____________________________________________________________________________
;
; TEST 245 - test mfps mode 3
;
ts245:		inc	(R2)			; update test number
		cmp	#245, (R2)		; sequence error?
		bne	ts246-10		; br to error halt on seq error
		mov	#406, R0		; R0=406
		clr	@#0			; loc.0=0
		mov	#252, @#ps		; ps=252
		mfps	@(R0)+			; try mfps with mode 3
		bcs	mfps3a			; br to error if C-bit set
		bvs	mfps3a			; br to error if V-bit set
		beq	mfps3a			; br to error if Z-bit set
		bmi	mfps3b			;
mfps3a:						;
		mov	#563, -(R2)		; move to mailbox #563
		inc	-(R2)			; set msgtyp to fatal error
		halt				; condition codes incorrect
mfps3b:		cmp	#125000, @#0		; check dest. data
		beq	mfps3c			;
		mov	#564, -(R2)		; move to mailbox #564
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest data incorrect
mfps3c:		cmp	R0, #410		; check mode 3 register.
		beq	ts246			;
		mov	#565, -(R2)		; move to mailbox #565
		inc	-(R2)			; set msgtyp to fatal error
		halt				; mode 3 register not incremented by 2
						; or sequence error
;_____________________________________________________________________________
;
; TEST 246 - test wps mode 4
;
ts246:		inc	(R2)			; update test number
		cmp	#246, (R2)		; sequence error?
		bne	ts247-10		; br to error halt on seq error
		mov	#2, R0			; R0=2
		clr	@#0			; loc.0=0
		mov	#125, @#ps		; ps=125
		mfps	-(R0)			; try mfps w/ mode 4
		bcc	mfps4a			; br to error if C-bit clear
		bvs	mfps4a			; br to error if V-bit set
		beq	mfps4a			; br to error if Z-bit set
		bpl	mfps4b			;
mfps4a:						;
		mov	#566, -(R2)		; move to mailbox #566
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cond. codes incorrect
mfps4b:		cmp	#42400, @#0		; check dest. data
		beq	mfps4c			;
		mov	#567, -(R2)		; move to mailbox #567
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. data incorrect
mfps4c:		cmp	R0, #1			; check mode 4 register
		beq	ts247			;
		mov	#570, -(R2)		; move to mailbox #570
		inc	-(R2)			; set msgtyp to fatal error
		halt				; mode 4 register not decremented by t
						; or sequence error
;_____________________________________________________________________________
;
; TEST 247 - test mfps	mode 5
;
ts247:		inc	(R2)			; update test number
		cmp	#247, (R2)		; sequence error?
		bne	ts250-10		; br to error halt on seq error
		mov	#410, R0		; R0=410
		mov	#-1, @#0		; loc.0=-1
		clr	@#ps			; ps=0
		mfps	@-(R0)			; try mfps w/ mode 5
		bcs	mfps5a			; br to error if C-bit set
		bvs	mfps5a			; br to error if V-bit set
		bmi	mfps5a			; br to error if N-bit set
		beq	mfps5b			;
mfps5a:						;
		mov	#571, -(R2)		; move to mailbox #571
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cond. codes incorrect
mfps5b:		cmp	#377, @#0		; check dest. data
		beq	mfps5c			;
		mov	#572, -(R2)		; move to mailbox #572
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest data incorrect
mfps5c:		cmp	R0, #406		;	; check mode 5 register
		beq	ts250			;
		mov	#573, -(R2)		; move to mailbox #573
		inc	-(R2)			; set msgtyp to fatal error
		halt				; mode 5 register not decremented by 2
						; or sequence error
;_____________________________________________________________________________
;
; TEST 250 - test mfps mode 6
;
ts250:		inc	(R2)			; update test number
		cmp	#250, (R2)		; sequence error?
		bne	ts251-10		; br to error halt on seq error
		mov	#401, R0		; R0=410
		clr	@#0			; loc.0=0
		mov	#252, @#ps		; ps=252
		mfps	-401(R0)		; try mfps w/ mode 6
		bvs	mfps6a			; br to error if V-bit set
		bcs	mfps6a			; br to error if C-bit set
		beq	mfps6a			; br to error if Z-bit set
		bmi	mfps6b			;
mfps6a:						;
		mov	#574, -(R2)		; move to mailbox #574
		inc	-(R2)			; set msgtyp to fatal error
		halt				; cond. codes incorrect
mfps6b:		cmp	#252, @#0		; check dest. data
		beq	mfps6c			;
		mov	#575, -(R2)		; move to mailbox #575
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. data incorrect
mfps6c:		cmp	#401, R0		; check dest. register
		beq	ts251			;
		mov	#576, -(R2)		; move to mailbox #576
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest. data incorrect
						; or sequence error
;_____________________________________________________________________________
;
; TEST 251 - test mfps mode 7
;
ts251:		inc	(R2)			; update test number
		cmp	#251, (R2)		; sequence error?
		bne	ts252-10		; br to error halt on seq error
		mov	#777, R0		; R0=777
		clr	@#0			; loc.0=0
		mov	#125, @#ps		; ps=125
		mfps	@-371(R0)		; try. mfps w/ mode 7
		bvs	mfps7a			; br to error if V-bit set
		bcc	mfps7a			; br to error if C-bit set
		beq	mfps7a			; br to.error if Z-bit set
		bpl	mfps7b			;
mfps7a:						;
		mov	#577, -(R2)		; move to mailbox #577
		inc	-(R2)			; set msgtyp to fatal error
		halt				; condition code incorrect
mfps7b:		cmp	#42400, @#0		; check destination data
		beq	mfps7c			;
		mov	#600, -(R2)		; move to mailbox #600
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dest, data incorrect
mfps7c:		cmp	#777, R0		; check mode 7 register
		beq	ts252			;
		mov	#601, -(R2)		; move to mailbox #601
		inc	-(R2)			; set msgtyp to fatal error
		halt				; mode 7 register modified
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies that reset does not clear the PSW.
; The PSW is loaded with ones, a reset is issued. And the
; contents of the PSW are checked to verify that they have not
; changed. This test is executed only once every 240 (decimal)
; iterations of program.
;
; TEST 252 - test that reset does not clear PSW
;
ts252:		inc	(R2)			; update test number
		cmp	#252, (R2)		; sequence error?
		bne	ts253-10		; br to error halt on seq frror
		mov	#357, @#ps		; mov ones to PSW
		reset				;
		cmp	#357, @#ps		; PSW correct?
		beq	ts253			;
		mov	#602, -(R2)		; move to mailbox #602
		inc	-(R2)			; set msgtyp to fatal error
		halt				; reset altered PSW
						; or sequence error
rest:						;
;_____________________________________________________________________________
;
; The following test checks the independent functioning of basic
; data path components with user mode set.
;
; TEST 253 test user mode SP can hold a one in every position
;
ts253:		inc	(R2)			; update test number
		cmp	#253, (R2)		; sequence error?
		bne	ts254-10		; br to error halt on seq error
		mov	#340, ps		; lock out interrupts while playing with SP
		bis	#usrm, ps		; set user mode
		mov	#1, SP			; set bit 0
		clc				; clear C-bit
usp1:		rol	SP			; rotate 1 position
		bcc	usp1			; br if not all done
		beq	usp1a			; br if no bits picked
		bic	#usrm, ps		; clear user mode
		mov	#603, -(R2)		; move to mailbox #603
		inc	-(R2)			; set msgtyp to fatal error
		halt				; user mode SP picked a bit
usp1a:		bic	#usrm, ps		; clear user mode
;_____________________________________________________________________________
;
; This test checks the independent functioning of the user
; and kernel mode SP's. SP is setup and addressed in each
; of the two modes to verify that the two SP's are independent
; of each other.
;
; TEST 254 - test independence of user and kernel mode SP's
;
ts254:		inc	(R2)			; update test number
		cmp	#254, (R2)		; sequence error?
		bne	usp4-10			; br to error halt on seq error
		mov	#340, ps		; lock out interrupts while playing with SP
		bis	#usrm, ps		; set user mode
		mov	#-1, SP			; set user SP to all ones
		cmp	#-1, SP			; read and check user SP
		beq	usp2			; br if no error
		bic	#usrm, ps		; clear user mode
		mov	#604, -(R2)		; move to mailbox #604
		inc	-(R2)			; set msgtyp to fatal error
		halt				; user SP will not hold all ones
usp2:		bic	#usrm, ps		; set kernel mode
		cmp	#-1, SP			; kernel mode SP addr. from user mode
		bne	usp3			;
		mov	#605, -(R2)		; move to mailbox #605
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dual addressing error user/kernel SP
usp3:		clr	SP			; clear kernel mode SP
		bis	#usrm, ps		; set user mode
		cmp	#-1, SP			; check user SP not addr. from kernel mode
		bic	#usrm, ps		; clear user mode
		beq	usp4			; br if no error
		mov	#606, -(R2)		; move to mailbox #606
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dual addressing error or sequence error
usp4:		mov	#stbot, SP		; restore SP user
		bic	#usrm, ps		; set kernel mode
		mov	#stbot, SP		; restore SP kernel
;_____________________________________________________________________________
;
; These next two tests verify mfpi and mtpi instructions
; with SP in mode 0.
;
; TEST 255 - test mfpi with SP in mode 0
;
ts255:		inc	(R2)			; update test number
		cmp	#255, (R2)		; sequence error?
		bne	ts256-10		; br to error halt on seq error
		mov	#stbot, SP		; initialize kernel stack pointer
		mov	#usrm, ps		; set user mode.previous kernel
		mov	#ustbot, SP		; initialize user stack pointer
		mfpi	SP			; try mfpi with mode 0
		cmp	#140000, ps		; check PSW
		beq	mfpi0			; br if no error
		bic	#usrm, ps		; clear user mode
		mov	#607, -(R2)		; move to mailbox #607
		inc	-(R2)			; set msgtyp to fatal error
		halt				; incorrect PSW from mfpi
mfpi0:		bic	#usrm, ps		; clear user mode
		cmp	#stbot, ustbot-2	; check data on stack
		beq	mfpi0a			; br if no error
		mov	#610, -(R2)		; move to mailbox #610
		inc	-(R2)			; set msgtyp to fatal error
		halt				; incorrect data from mfpi
mfpi0a:						;
;_____________________________________________________________________________
;
; TEST 256 - test mtpi with SP in mode 0
;
ts256:		inc	(R2)			; update test number
		cmp	#256, (R2)		; sequence error?
		bne	ts257-10		; br to error halt on seq error
		mov	#340, ps		; set kernel mode and lock out interrupts
		clr	SP			; initialize kernel SP
		bis	#usrm, ps		; set user mode/previous kernel
		mov	#ustbot, SP		; initialize user stack pointer
		mov	#stbot, -(SP)		; set up target data
		mtpi	SP			; try mode 0 mtpi
		cmp	#140340, ps		; check PSW
		beq	mtpi0			; br if no error
		bic	#usrm, ps		; clear user mode
		mov	#611, -(R2)		; move to mailbox #611
		inc	-(R2)			; set msgtyp to fatal error
		halt				; ps incorrect following mtpi
mtpi0:		bic	#usrm, ps		; set kernel mode
		cmp	SP, #stbot		; check target data
		beq	ts257			;
		mov	#612, -(R2)		; move to mailbox #612
		inc	-(R2)			; set msgtyp to fatal error
		halt				; data incorrect following mtpi
						; or sequence error
;_____________________________________________________________________________
;
; This test executes every possible branch with every possible
; condition code combination.
; The routine uses two tables. the branch table holds all the
; possible branch instructions, the other table (yntab) holds bit maps for
; each branch. a one in the bit map indicates that the corresponding
; branch instruction should branch for the condition code setting which
; corresponds to the bit position within the map. For example if the left
; most bit is a one then the corresponding branch instruction should branch
; when the condition codes are 0.
; The routine consists of nested loops; the outer loop sets up
; all the possible branch instructions. The inner loop sets up every possible
; condition code for each branch.
; The bit map is used to set the address location in two
; jump mode 3 instructions. The addresses are changed to allow the
; program to continue or jump to an error routine depending upon
; whether it handled the branch instruction correctly.
; At any error halt, location, brh, holds the branch instruction
; under test and location, cc. holds the value of the condition codes
; at the time the branch was executed.
;
; TEST 257 - test the branch rom
;
ts257:		inc	(R2)			; update test number
		cmp	#257, (R2)		; sequence error?
		bne	er			; br to error halt on seq error
setup:		mov	#brtab, R0		; initialize branch table pointer
		mov	#yntab, R4		; initialize yes/no branch map pointer
		mov	#15., brct		; initialize branch table count
setbr:		mov	(R0)+, brh		; get next branch inst.
		mov	(R4)+, R1		; get next branch map
		mov	#-1, cc1		; initialize condition code value
		mov	#16., R3		; initialize condition code count
setcc:		inc	cc1			; set for next cc value
		bit	#100000, R1		; see if should br w/ these cc's
		mov	@#177776, R5		; simulate a jne
		bic	#177773, R5		; (jump not equal)
		jmp	.+4(R5)			; to set2br
		jmp	set2br			;
		mov	#cont, nbr		; set to continue if no branch
		mov	#er, ybr		; set to report error if branch
		jmp	aroun			; go around opposite condition
set2br:		mov	#er, nbr		; set to report error if no branch
		mov	#cont, ybr		; set to continue if branch
aroun:		rol	R1			; update bit map
		mov	(PC)+, @(PC)+		; set condition code
cc1:		0				; new cc value goes here
		177776				;
brh:		0				; branch inst. goes here
		jmp	@(PC)+			; this jump if no branch
nbr:		0				; where to go if no branch occurs
		jmp	@(PC)+			; this jump if branch occurs
ybr:		0				; where to go if branch occurs
er:		mov	#$testn, R2		; restore pointer
		mov	#613, -(R2)		; move to mailbox #613
		inc	-(R2)			; set msgtyp to fatal error
		halt				;
brct:		0				;
cont:		dec	R3			; cc's done?
		mov	@#177776, R5		; simulate a jne
		bic	#177773, R5		; (jump not equal)
		jmp	.+4(R5)			; to setcc
		jmp	setcc			;
		dec	brct			; br's done?
		mov	@#177776, R5		; simulate a jne
		bic	#177773, R5		; (jump not equal)
		jmp	.+4(R5)			; to setbr
		jmp	setbr			;
;_____________________________________________________________________________
;
; The following test verifies that no dual addressing of the general
; registers occurs. All registers are cleared, and a unique bit is set
; in each. cmp instructions check that only one bit is set in each
; register.
;
; TEST 260 - dual register addressing test
;
ts260:		inc	(R2)			; update test number
		cmp	#260, (R2)		; sequence error?
		bne	daerr			; br to error halt on seq error
bitclr:		clr	R0			; initialize all registers
		clr	R1			;
		clr	R2			;
		clr	R3			;
		clr	R4			;
		clr	R5			;
bitset:		bis	#1, R0			; set R0=1
		bis	#2, R1			; R1=2
		bis	#4, R2			; R2=4
		bis	#10, R3			; R3=10
		bis	#20, R4			; R4=20
		bis	#40, R5			; R5=40
		bis	#1000, SP		; SP=1000
bitchk:		cmp	#1000, SP		; test that no dual addressing occurred
		bne	daerr			; br to error halt if any other bits are set
		cmp	#40, R5			;
		bne	daerr			;
		cmp	#20, R4			;
		bne	daerr			;
		cmp	#10, R3			;
		bne	daerr			;
		cmp	#4, R2			;
		bne	daerr			;
		cmp	#2, R1			;
		bne	daerr			;
		cmp	#1, R0			;
		beq	bitcon			;
daerr:						;
		mov	#614, -(R2)		; move to mailbox #614
		inc	-(R2)			; set msgtyp to fatal error
		halt				; dual addressing error
bitcon:		mov	#$testn, R2		; restore pointer
;_____________________________________________________________________________
;
; This test verifies that the upper byte of the PSW is not a__________ < ???????
; when the priority level or cc's are changed. All bits are
; initially set in the PSW. And the low byte is cleared. A bit
; instruction verifies the data.
;
; TEST 261 - test byte instruction on PSW
;
ts261:		inc	(R2)			; update test number
		cmp	#261, (R2)		; sequence error?
		bne	bterr			; br to error halt on seq error
		bis	#170357, @#ps		; set all possible bits in PSW
		clrb	@#ps			; clr pr level and cc's
		mov	@#ps, R0		; copy contents of PSW
		cmp	#170004, R0		; test that clrb affected only low byte
		bne	btcon			; continue if ok
bterr:		clr	@#ps			; return to kernel mode
		mov	#615, -(R2)		; move to mailbox #615
		inc	-(R2)			; set msgtyp to fatal error
		halt				; byte instruction altered PSW
btcon:		clr	@#ps			; return to kernel mode
;_____________________________________________________________________________
;
; This test verifies that a jmp instruction does not alter the
; condition codes in the PSW. The cc's are preset, the jmp is
; executed, and conditional branches verify the state of the cc's.
;
; TEST 262 - test that jmp instruction does not affect condition codes
;
ts262:		inc	(R2)			; update test number
		cmp	#262, (R2)		; sequence error?
		bne	ts263-10		; br to error halt on seq error
		scc				;
		+cln!clv			; cc=0101
		jmp	jmpt			; jump to test PSW
jmpt:		bmi	jmperr			; br to error halt if N-bit is set
		bne	jmperr			; br to error halt if Z-bit is clear
		bvs	jmperr			; br to error halt if V-bit if set
		bcs	ts263			;
jmperr:						;
		mov	#616, -(R2)		; move to mailbox #616
		inc	-(R2)			; set msgtyp to fatal error
		halt				; jmp instruction affected cc's
						; or sequence error
;_____________________________________________________________________________
;
; This test verifies the set and clear condition code instructions.
; The test consists of two routines, one to test all clear cc
; instructions, and the second to test all set cc instructions. All
; possible combinations of condition codes are tested, including nop's.
; To test the clear cc instructions, all condition codes are
; initially set. the instruction is executed, and the PSW is checked
; to verify the proper combination of condition codes.
; To test the set cc instructions, the condition codes are
; initially cleared, and only the required bits are set by the set cc
; instruction. The contents of the PSW are checked to verify that
; only the required bits were set.
;
; TEST 263 - test set cc and clear cc instructions
;
ts263:		inc	(R2)			; update test number
		cmp	#263, (R2)		; sequence error?
		bne	ccerr			; br to error halt on seq error
		mov	#240, cc3		; initialize clr cc instruction codes
		mov	#17, cc2		; initialize octal map
		mov	#261, sc3		; initialize set cc instruction codes
		mov	#1, sc4			; initialize octal map
clrcd:		scc				; set all condition codes
cc3:		0				; condition code instruction
		mov	@#ps, R4		; copy the PSW
		bic	#177760, R4		; isolate condition codes
		cmp	(PC)+, R4		; check that proper cc's were cleared
cc2:		0				; octal representation of cc's
		beq	con1			;
		mov	#617, -(R2)		; move to mailbox #617
		inc	-(R2)			; set msgtyp to fatal error
		halt				; clear cc instruction failed
con1:		dec	cc2			; set next octal map of cc's
		inc	cc3			; get next clear cc instruction
		cmp	cc3, #257		; test for ccc instruction
		ble	clrcd			; go test next instruction if not found
		cmp	cc3, #260		; check for nop=260
		bne	setcd			; go test set cc instructions
		mov	#17, cc2		; set octal map to test nop
		br	clrcd			; go test nop
setcd:		ccc				; clear all condition codes
sc3:		0				; condition code instruction
		mov	@#ps, R4		; copy the PSW
		bic	#177760, R4		; clear away unwanted bits
		cmp	(PC)+, R4		; check that proper cc's were set
sc4:		0				; octal representation of cc's
		beq	con2			;
ccerr:		mov	#620, -(R2)		; move to mailbox #620
		inc	-(R2)			; set msgtyp to fatal error
		halt				; set cc failed or sequence error
con2:		inc	sc4			; set next octal map
		inc	sc3			; prepare next set cc instruction
		cmp	sc3, #277		; finished?
		ble	setcd			; br if no
		jmp	mor0			; jump to next tests

		.sbttl	"TEST INSTRUCTIONS USING SAME REGISTER FOR SOURCE & DESTINATION"
;_____________________________________________________________________________
;
; In auto increment (decrement) modes and
; auto increment (decrement) deferred modes,
; contents of the register in used are
; incremented (decremented) by 2
; before used as the source operand.
;
a:		.word	0, 0, 0
mor0:
;_____________________________________________________________________________
;
; TEST 264 - test auto-increment mode, using R0
;
ts264:		inc	(R2)			; update test number
		cmp	#264, (R2)		; sequence error?
		bne	ts265-10		; br to error halt on seq error
		clr	@#a			; clear loc.a
		mov	#a, R0			; R0 stores addr of a
		addR0	(R0)+			; check that R0 is incr by 2 before
						; being used as the source operand
		cmp	#a+2, R0		; R0 incr by 2?
		beq	mor1			;
		mov	#621, -(R2)		; move to mailbox #621
		inc	-(R2)			; set msgtyp to fatal error
		halt				; R0 was not incremented by 2
mor1:		cmp	#a+2, @#a		; check content of R0 was incr by 2 before
						; being used in the "add" instr
						; loc.a contains (a+2)?
		beq	ts265			;
		mov	#622, -(R2)		; move to mailbox #622
		inc	-(R2)			; set msgtyp to fatal error
		halt				; wrong sum in loc.a
						; or sequence error
;_____________________________________________________________________________
;
; TEST 265 - auto-decrement mode. using R0
;
ts265:		inc	(R2)			; update test number
		cmp	#265, (R2)		; sequence error?
		bne	ts266-10		; br to error halt on seq error
		clr	@#a			; clear loc.a
		mov	#a+2, R0		; R0 stores addr of a+2
		addR0	-(R0)			; check that R0 is decr by 2 before
						; being used as the source operand
		cmp	#a, R0			; R0 decr by 2?
		beq	mor2			;
		mov	#623, -(R2)		; move to mailbox #623
		inc	-(R2)			; set msgtyp to fatal error
		halt				; R0 was not decremented by 2
						;
mor2:		cmp	#a, @#a			; content of R0 was decr by 2 before
						; being used in the "add" instr
						; loc.a contains (R0)
		beq	ts266			;
		mov	#624, -(R2)		; move to mailbox #624
		inc	-(R2)			; set msgtyp to fatal error
		halt				; wrong sum in loc.a
						; or sequence error
;_____________________________________________________________________________
;
; TEST 266 - test auto-increment deferred mode, using R0
;
ts266:		inc	(R2)			; update test number
		cmp	#266, (R2)		; sequence error?
		bne	ts267-10		; br to error halt on seq error
		clr	@#a			; clear loc.a
		clr	@#a+4			; clear loc.a+4
		mov	#a, @#a+2		; store addr a in loc.a+2
		mov	#a+2, R0		; R0 stores addr a+2
		addR0	@(R0)+			; check that R0 is incr by 2 before
						; being used as the source operand
		cmp	#a+4, R0		; R0 incr by 2?
		beq	mor3			;
		mov	#625, -(R2)		; move to mailbox #625
		inc	-(R2)			; set msgtyp to fatal error
		halt				; R0 was not incremented by 2
						;
mor3:		cmp	#a, @#a+2		; loc.a+2 still stores addr a?
		beq	mor4			;
		mov	#626, -(R2)		; move to mailbox #626
		inc	-(R2)			; set msgtyp to fatal error
		halt				; loc.a+2 stores wrong data
						;
mor4:		cmp	#a+4, @#a		; check content of R0 was incr by 2 before
						; being used in the "add" instr
		beq	mor5			;
		mov	#627, -(R2)		; move to mailbox #627
		inc	-(R2)			; set msgtyp to fatal error
		halt				; loc.a stores wrong data
						;
mor5:		tst	@#a+4			; loc.a+4 still stores 0?
		beq	ts267			;
		mov	#630, -(R2)		; move to mailbox #630
		inc	-(R2)			; set msgtyp to fatal error
		halt				; loc.a+4 did not stay clear
						; or sequence error
;_____________________________________________________________________________
;
; TEST 267 - test auto-decrement deferred, using R0
;
ts267:		inc	(R2)			; update test number
		cmp	#267, (R2)		; sequence error?
		bne	ts270-10		; br to error halt on seq error
		clr	@#a			; clear loc.a
		clr	@#a+4			; clear loc.a+4
		mov	#a+4, R0		; R0 stores addr a+4
		mov	#a, @#a+2		; store addr a in loc.a+2
		addR0	@-(R0)			; check that R0 is decr by 2 before
						; being used as the source operand
		cmp	#a+2, R0		; R0 decremented by 2?
		beq	mor6			;
		mov	#631, -(R2)		; move to mailbox #631
		inc	-(R2)			; set msgtyp to fatal error
		halt				; R0 was not decremented by 2
						;
mor6:		cmp	#a+2, @#a		; check content of R0 was decr by 2 before
						; being used in the "add" instr
		beq	mor7			;
		mov	#632, -(R2)		; move to mailbox #632
		inc	-(R2)			; set msgtyp to fatal error
		halt				; loc.a stores wrong data
						;
mor7:		cmp	#a, @#a+2		; loc.a+2 still stores a?
		beq	mor8			;
		mov	#633, -(R2)		; move to mailbox #633
		inc	-(R2)			; set msgtyp to fatal error
		halt				; loc.a+2 stores wrong data
						;
mor8:		tst	@#a+4			; loc.a+4 still stores 0?
		beq	ts270			;
		mov	#634, -(R2)		; move to mailbox #634
		inc	-(R2)			; set msgtyp to fatal error
		halt				; loc.a+4 did not stay cleap
						; or sequence error

		.sbttl	"INSTRUCTION USING PC AS SOURCE REGISTER"
;_____________________________________________________________________________
;
; In index, index deferred, relative, and
; relative deferred modes, destination will contain
; the PC count of the current instruction +4.
;
; TEST 270 - test PC as source in mode 0, using R0
;
ts270:		inc	(R2)			; update test number
		cmp	#270, (R2)		; sequence error?
		bne	ts271-10		; br to error halt on seq error
		mov	#-1, R0			; set all 1 in R0
pcn01:		mov	PC, R0			; stores PC in R0
		cmp	#pcn01+2, R0		; R0 stores PC+2?
		beq	ts271			;
		mov	#635, -(R2)		; move to mailbox #635
		inc	-(R2)			; set msgtyp to fatal error
		halt				; R0 stored wrong value
						; or sequence error
;_____________________________________________________________________________
;
; TEST 271 - test PC as source in mode 6, using R0
;
ts271:		inc	(R2)			; update test number
		cmp	#271, (R2)		; sequence error?
		bne	ts272-10		; br to error halt on seq error
		mov	#a, R0			; R0 stores addr a
pcn2:		movpc	4(R0), 4		; effective addr is a+4 movea4
		cmp	#pcn2+4, @#a+4		; loc.a+4 stores PC+4?
		beq	ts272			;
		mov	#636, -(R2)		; move to mailbox #636
		inc	-(R2)			; set msgtyp to fatal error
		halt				; loc.a+4 stored wrong value
						; or sequence error
;_____________________________________________________________________________
;
; TEST 272 - test PC as source in mode 7, using R0
;
ts272:		inc	(R2)			; update test number
		cmp	#272, (R2)		; sequence error?
		bne	ts273-10		; br to error halt on seq error
		mov	#a, @#a+4		; loc.a+4 stores addr a
		mov	#a, R0			; R0 stores addr a
pcn3:		movpc	@4(R0), 4		; effective addr is a
		cmp	#pcn3+4, @#a		; loc.a stores PC+4?
		beq	ts273			;
		mov	#637, -(R2)		; move to mailbox #637
		inc	-(R2)			; set msgtyp to fatal error
		halt				; loc.a stored wrong value
						; or sequence error
;_____________________________________________________________________________
;
; TEST 273 - test PC as source in relative deferred mode, using R0
;
ts273:		inc	(R2)			; update test number
		cmp	#273, (R2)		; sequence error?
		bne	ts274-10		; br to error halt on seq error
		mov	#a+2, @#a		; loc.a stores addr a+2
pcn4:		movpc	@a, a			; effective addr is a+2
		cmp	#pcn4+4, @#a+2		; loc.a+2 stores PC+4?
		beq	ts274			;
		mov	#640, -(R2)		; move to mailbox #640
		inc	-(R2)			; set msgtyp to fatal error
		halt				; loc.a+2 stored wrong value
						; or sequence error
;_____________________________________________________________________________
;
; TEST 274 - test PC as source in relative mode, using R0
;
ts274:		inc	(R2)			; update test number
		cmp	#274, (R2)		; sequence error?
		bne	ts275-10		; br to error halt on seq error
		clr	@#a			; clear a
pcn5:		movpc	a			; effective addr is a
		cmp	#pcn5+4, @#a		; loc.a stores PC+4?
		beq	ts275			;
		mov	#641, -(R2)		; move to mailbox #641
		inc	-(R2)			; set msgtyp to fatal error
		halt				; location a stored wrong value
						; or sequence error

		.sbttl	"THE NEXT THREE TESTS EXERCISE MASKING ACTION OF MICROCODES"
;_____________________________________________________________________________
;
; TEST 275 - test sub instruction, sm=0, dm=2
;
ts275:		inc	(R2)			; update test number
		cmp	#275, (R2)		; sequence error?
		bne	ts276-10		; br to error halt on seq error
		mov	#052525, @#0		; set up loc.0
		mov	#050505, R1		; set up R1
		clr	R0			; clear R0
		sub	R1, (R0)+		; subtraction, sm=0, dm=2
		cmp	#2020, @#0		; check difference at loc.0
		beq	ts276			;
		mov	#642, -(R2)		; move to mailbox #642
		inc	-(R2)			; set msgtyp to fatal error
		halt				; wrong result from subtraction
						; or sequence error
;_____________________________________________________________________________
;
; TEST 276 - test mfpd with R0, in mode 2
;
ts276:		inc	(R2)			; update test number
		cmp	#276, (R2)		; sequence error?
		bne	ts277-10		; br to error halt on seq error
		mov	#052525, @#0		; set up loc.0
		clr	R0			; clear R0
		mov	#170000, ps		; set user mode on, current & previous
		mov	#ustbot, SP		; set user stack pointer
		mfpd	(R0)+			; mode 2, mfpd
		clr	ps			; set kernel mode
		cmp	#052525, ustbot-2	; check data on stack
		beq	brmfpd			; br if no error
		mov	#643, -(R2)		; move to mailbox #643
		inc	-(R2)			; set msgtyp to fatal error
		halt				; incorrect data from mfpd
brmfpd:						;
;_____________________________________________________________________________
;
; TEST 277 - test mtpd with R0, in mode 2
;
ts277:		inc	(R2)			; update test number
		cmp	#277, (R2)		; sequence error?
		bne	end1			; br to error halt on seq error
		mov	#170000, ps		; set user mode on, current i previous
		mov	#ustbot, SP		; set user stack pointer
		mov	#125252, -(SP)		; push data in user stack
		mov	#0, @#0			; clear loc.0
		clr	R0			; clear R0
		mtpd	(R0)+			; mode 2, mtpd
		clr	ps			; set kernel mode
		cmp	#125252, @#0		; check data on loc.0
		beq	secprt			; br to trap test if no error
		mov	#644, -(R2)		; move to mailbox #644
		inc	-(R2)			; set msgtyp to fatal error
		halt				; incorrect data from mtpd
end1:						;
		mov	#645, -(R2)		; move to mailbox #645
		inc	-(R2)			; set msgtyp to fatal error
		halt				; sequence error
brtab:		br	.+6			;
		bne	.+6			;
		beq	.+6			;
		bge	.+6			;
		blt	.+6			;
		bgt	.+6			;
		ble	.+6			;
		bpl	.+6			;
		bmi	.+6			;
		bhi	.+6			;
		blos	.+6			;
		bvc	.+6			;
		bvs	.+6			;
		bcc	.+6			; same as bhis
		bcs	.+6			; same as blo
						;
.radix		2				;
yntab:		1111111111111111		; br
		1111000011110000		; bne: Z=0
		0000111100001111		; beq: Z=1
		1100110000110011		; bge: N xor V=0
		0011001111001100		; blt: N xor V=1
		1100000000110000		; bgt: Z+(N xor V)=0
		0011111111001111		; ble: Z+(N xor V)=1
		1111111100000000		; bpl: N=0
		0000000011111111		; bmi: N=1
		1010000010100000		; bhi: C+Z=0
		0101111101011111		; blos: C+Z=1
		1100110011001100		; bvc: V=0
		0011001100110011		; bvs: V=1
		1010101010101010		; bcc: C=0
		0101010101010101		; bcs: C=1
.radix 8					;
		.even				;
		.blkw	6			;
ustbot:						;

; The following are special CPU trap
; handlers to trap and report special traps.

to4:
		mov	#646, -(R2)		; move to mailbox #646
		inc	-(R2)			; set msgtyp to fatal error
		halt				; trapped thru loc.4
to10:						;
		mov	#647, -(R2)		; move to mailbox #647
		inc	-(R2)			; set msgtyp to fatal error
		halt				; trapped thru loc.10
to14:						;
		mov	#650, -(R2)		; move io mailbox #650
		inc	-(R2)			; set msgtyp to fatal error
		halt				; trapped thru loc.14
to30:						;
		mov	#651, -(R2)		; move to mailbox #651
		inc	-(R2)			; set msgtyp to fatal error
		halt				; trapped thru loc.30
to34:						;
		mov	#652, -(R2)		; move to mailbox #652
		inc	-(R2)			; set msgtyp to fatal error
		halt				; trapped thru loc.34
to114:						;
		mov	#653, -(R2)		; move to mailbox #653
		inc	-(R2)			; set msgtyp to fatal error
		halt				; trapped thru loc.114
to244:						;
		mov	#654, -(R2)		; move to mailbox #654
		inc	-(R2)			; set msgtyp to fatal error
		halt				; trapped thru loc.244
to250:						;
		mov	#655, -(R2)		; move to mailbox #655
		inc	-(R2)			; set msgtyp to fatal error
		halt				; trapped thru loc.250

		.sbttl	"STARTING OF TRAP TEST"

secprt:

;
; part two:				F11 trap test, this is the second
;					part of the main program.
;
; abstract
;
; This is a test of all operations and instructions that cause
; traps. Also tested are trap overflow conditions,
; oddities of register 6. interrupts, the reset and wait instructions.
;

		.list me
		.nlist mc, md, cnd

		tab	= R3			;
		last	= R1			;
		first	= R5			;
		hlt	= halt			;
		trt	= 3			;
		itrap5	= 4			;
		rtrap5	= 4			; reserved inst and illegal addresses
		rtrap4	= 14			; for trace trap
		rtrap3	= 30			; for emulator trap
		rtrap2	= 20			; for iot trap
		rtrap1	= 34			; for trap inst
		ttcsr	= 177564		;
		trcsr	= 177560		;
		tps	= 177564		;
		tpb	= 177566		;
		bell	= 240			;
		nop	= 240			;
		status	= 177776		;
		trapa	= 77			;
		rtrap	= 10			;
		illa	= 004700		;
		illb	= 100			;
		cc	= 177776		;
		buff	= stbot			;
	; special case of odd: .even .byte and register 6
		here	= 0			;
		jmp	testn1			;
k1:		0				;
k2:		0				;
k3:		0				;
k4:		0				;
k5:		0				;
k6:		0				;
k7:		052525				;
k10:		052400				;
k11:		0				;
k12:		0				;
swr:		176				;
testn1:		mov	#176, swr		; point to loc.176 as software switch register
		bit	#1, @#$env		; are we running in APT mode
		beq	1$			; if no use software switch register
		mov	#$swreg, swr		; if yes use APT switch register
1$:		bit	#1, @swr		; if bit is non-zero ship all traps tests
		beq	2$			;
		jmp	thrprt			;
2$:						;
;_____________________________________________________________________________
;
; TEST 300 - test auto increment and decrement of SP for word and bytes
;
ts300:		inc	(R2)			; update test number
		cmp	#300, (R2)		; sequence error?
		bne	ts301-10		; br to error halt on seq error
		clr	SP			;
		movb	(6)+, here		; six should increment by two
		cmp	SP, #2			;
		beq	br1			;
		mov	#656, -(R2)		; move to mailbox #656
		inc	-(R2)			; set msgtyp to fatal error
		halt				; SP did not auto increment by two
br1:		mov	#1000, SP		;
		movb	-(6), #here		; should decrement by two
		cmp	SP, #776		;
		beq	br2			;
		mov	#657, -(R2)		; move to mailbox #657
		inc	-(R2)			; set msgtyp to fatal error
		halt				; SP did not auto decrement by 2
br2:		clr	SP			;
		movb	(6)+, (6)+		; doubles auto increment of SP
		cmp	SP, #4			;
		beq	br3			;
		mov	#660, -(R2)		; move to mailbox #660
		inc	-(R2)			; set msgtyp to fatal error
		halt				; wrong auto increment of SP
br3:		clr	SP			;
		clr	R4			;
		cmpb	(6)+, (4)+		; test increment of SP
		cmp	SP, #2			;
		beq	br4			;
		mov	#661, -(R2)		; move to mailbox #661
		inc	-(R2)			; set msgtyp to fatal error
		halt				; wrong increment of SP
br4:		clr	SP			;
		clr	R4			;
		cmpb	(4)+, (6)+		; test increment of SP
		cmp	SP, #2			;
		beq	br5			;
		mov	#662, -(R2)		; move to mailbox #662
		inc	-(R2)			; set msgtyp to fatal error
		halt				; wrong increment of SP
br5:		clr	SP			;
		clr	R4			;
		cmpb	(6)+, (4)+		; test increment of R4
		cmp	R4, #1			;
		beq	br6			;
		mov	#663, -(R2)		; move to mailbox #$63
		inc	-(R2)			; set msgtyp to fatal error
		halt				; wrong increment of R4
br6:		clr	SP			;
		clr	R4			;
		cmpb	(4)+, (6)+		; test increment of SP
		cmp	SP, #2			;
		beq	br7			;
		mov	#664, -(R2)		; move to mailbox #664
		inc	-(R2)			; set msgtyp to fatal error
		halt				; wrong increment of SP
br7:		clr	SP			;
		clr	R4			;
		cmpb	(4)+, (6)+		; test increment of R4
		cmp	R4, #1			;
		beq	br10			;
		mov	#665, -(R2)		; move to mailbox #665
		inc	-(R2)			; set msgtyp to fatal error
		halt				; wrong increment of R4
br10:		mov	#1000, SP		;
		cmpb	-(6), #here		; test decrement of SP
		cmp	#776, SP		;
		beq	ts301			;
		mov	#666, -(R2)		; move to mailbox #666
		inc	-(R2)			; set msgtyp to fatal error
		halt				; wrong decrement of SP, or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 301 - test transfer of .byte using SP
;
ts301:		inc	(R2)			; update test number
		cmp	#301, (R2)		; sequence error?
		bne	ts302-10		; br to error halt on seq error
		mov	#123456, k5		;
		mov	#050505, k1		;
		mov	#k1, R5			; R5=(050505)k1
		mov	#k5, SP			; SP=(123456)k5
		movb	(6)+, (5)+		; low .byte of SP to R5
		cmp	#050456, k1		;
		beq	br11			;
		mov	#667, -(R2)		; move to mailbox #667
		inc	-(R2)			; set msgtyp to fatal error
		halt				; false transfer of .byte
br11:		mov	#123456, k5		;
		mov	#050505, k1		;
		mov	#k1, R5			; R5(050505)k1
		mov	#k6, SP			; SP(123456)k5
		movb	-(6), (5)+		; low .byte of SP to R5 (decrement)
		cmp	k1, #050456		;
		beq	br12			;
		mov	#670, -(R2)		; move to mailbox #670
		inc	-(R2)			; set msgtyp to fatal error
		halt				; false SP .byte transfer
br12:		mov	#123456, k1		;
		mov	#050505, k5		;
		mov	#k1, R5			; (123456)
		mov	#k5, SP			; (050505)
		movb	(5)+, (6)+		; low of R5 to low of SP
		cmp	#050456, k5		;
		beq	br13			;
		mov	#671, -(R2)		; move to mailbox #671
		inc	-(R2)			; set msgtyp to fatal error
		halt				; false SP .byte transfer
br13:		mov	#123456, k1		;
		mov	#050505, k5		;
		mov	#k1+1, R5		; 123456
		mov	#k5, SP			; 050505
		movb	(5)+, (6)+		; high of R5 to low of SP
		cmp	k5, #050647		;
		beq	br14			;
		mov	#672, -(R2)		; move to mailbox #672
		inc	-(R2)			; set msgtyp to fatal error
		halt				; false SP .byte transfer
br14:		mov	#123456, k1		;
		mov	#050505, k5		;
		mov	#k1+1, R5		; R5-123456-odd address
		mov	#k5, SP			; SP-050505-.even address
		movb	(6)+, (5)+		; low of SP to high of R5
		cmp	#042456, k1		;
		beq	ts302			;
		mov	#673, -(R2)		; move to mailbox #673
		inc	-(R2)			; set msgtyp to fatal error
		halt				; failed low of 6 to high of 5, or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 302 - test byte operation with sequential odd-even address
;
ts302:		inc	(R2)			; update test number
		cmp	#302, (R2)		; sequence error?
		bne	ts303-10		; br to error halt on seq error
		cmpb	k7, k7+1		; same .word low to high
		beq	br15			;
		mov	#674, -(R2)		; move to mailbox #674
		inc	-(R2)			; set msgtyp to fatal error
		halt				; should compare low to high
br15:		cmpb	k7+1, k7		; compare odd to .even same .word
		beq	br16			;
		mov	#675, -(R2)		; move to mailbox #675
		inc	-(R2)			; set msgtyp to fatal error
		halt				; odd to .even .byte failure
br16:		cmpb	k10+1, k7		; sequential .bytes
		beq	br17			;
		mov	#676, -(R2)		; move to mailbox #676
		inc	-(R2)			; set msgtyp to fatal error
		halt				; odd to .even failed
br17:		cmpb	k10, k6			;
		beq	br20			;
		mov	#677, -(R2)		; move to mailbox #677
		inc	-(R2)			; set msgtyp to fatal error
		halt				; .even to even failed
br20:		cmpb	k7+1, k10+1		;
		beq	br21			;
		mov	#700, -(R2)		; move to mailbox #700
		inc	-(R2)			; set msgtyp to fatal error
		halt				; odd to odd failed
br21:		cmpb	k10, k10+1		;
		bne	br22			;
		mov	#701, -(R2)		; move to mailbox #701
		inc	-(R2)			; set msgtyp to fatal error
		halt				; low to high in same .word failed
br22:		cmpb	k10+1, k10+1		;
		beq	br23			;
		mov	#702, -(R2)		; move to mailbox #702
		inc	-(R2)			; set msgtyp to fatal error
		halt				; high to low in same .word failed
br23:		cmpb	k10, k7+1		;
		bne	ts303			;
		mov	#703, -(R2)		; move to mailbox #703
		inc	-(R2)			; set msgtyp to fatal error
		halt				; .even to odd failed, or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 303 - test the cc bits
;
ts303:		inc	(R2)			; update test number
		cmp	#303, (R2)		; sequence error?
		bne	ts304-10		; br to error halt on seq error
		scc				; set status
		clr	status			; clear status
		bcc	br33			;
		mov	#704, -(R2)		; move to mailbox #704
		inc	-(R2)			; set msgtyp to fatal error
		halt				; C not clear
br33:						;
		bvc	br34			;
		mov	#705, -(R2)		; move to mailbox #705
		inc	-(R2)			; set msgtyp to fatal error
		halt				; V not clear
br34:						;
		bne	br35			;
		mov	#706, -(R2)		; move to mailbox #706
		inc	-(R2)			; set msgtyp to fatal error
		halt				; Z not clear
br35:						;
		bpl	br36			;
		mov	#707, -(R2)		; move to mailbox #707
		inc	-(R2)			; set msgtyp to fatal error
		halt				; N not clear
br36:		ccc				; clear condition codes
		bis	#17, status		; set status to ones
		bcs	br37			;
		mov	#710, -(R2)		; move to mailbox #710
		inc	-(R2)			; set msgtyp to fatal error
		halt				; C not set
br37:						;
		bvs	br40			;
		mov	#711, -(R2)		; move to mailbox #711
		inc	-(R2)			; set msgtyp to fatal error
		halt				; V not set
br40:						;
		beq	br41			;
		mov	#712, -(R2)		; move to mailbox #712
		inc	-(R2)			; set msgtyp to fatal error
		halt				; Z not set
br41:						;
		bmi	ts304			;
		mov	#713, -(R2)		; move to mailbox #713
		inc	-(R2)			; set msgtyp to fatal error
		halt				; N not set, or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 304 - test that a trap occurs on a reserved instruction
;
ts304:		inc	(R2)			; update test number
		cmp	#304, (R2)		; sequence error?
		bne	reta			; br to error halt on seq error
		mov	#buff, SP		; stack pointer setup
		mov	#retah, rtrap		; return location
		trapa				; reserved instruction, should trap
reta:						;
		mov	#714, -(R2)		; move to mailbox #714
		inc	-(R2)			; set msgtyp to fatal error
		halt				; reserve instruction didn't trap, or wrong $tstnm
						;
retah:						;
;_____________________________________________________________________________
;
; TEST 305 - test decrement of stack pointer on a trap operation
;
ts305:		inc	(R2)			; update test number
		cmp	#305, (R2)		; sequence error?
		bne	ts306-10		; br to error halt on seq error
		mov	#buff, SP		; stack pointer setup
		mov	#retb, rtrap		; return pointer
		trapa				; reserved instruction
retb:		cmp	SP, #buff-4		; test decrement of SP
		beq	ts306			;
		mov	#715, -(R2)		; move to mailbox #715
		inc	-(R2)			; set msgtyp to fatal error
		halt				; not decremented two words, or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 306 - test that proper p.c. is saved
;
ts306:		inc	(R2)			; update test number
		cmp	#306, (R2)		; sequence error?
		bne	ts307-10		; br to error halt on seq error
		mov	#buff, SP		; stack pointer setup
		mov	#retc, rtrap		; return from trap pointer
instc:		trapa				; trap on this instruction
retc:		cmp	#., buff-4		; check for incremented p.c.
		beq	ts307			;
		mov	#716, -(R2)		; move to mailbox #716
		inc	-(R2)			; set msgtyp to fatal error
		halt				; incorrect p.c., or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 307 - test that "old" cc and priority are placed on stack
;
ts307:		inc	(R2)			; update test number
		cmp	#307, (R2)		; sequence error?
		bne	ts310-10		; br to error halt on seq error
		mov	#buff, SP		; set up
		mov	#retd, rtrap		; set up
		clr	cc			; clear cc and priority
		ccc				;
		trapa				; trap
retd:		cmp	buff-2, #0		; test that old status went to stack
		beq	1$			;
		mov	#717, -(R2)		; move to mailbox #717
		inc	-(R2)			; set msgtyp to fatal error
		halt				; incorrect status
1$:		mov	#buff, SP		; set up
		mov	#rete, rtrap		; set up
		mov	#357, cc		; set priority
		scc				; set cc
		trapa				; trap
rete:		cmp	buff-2, #357		; compares status on stack
		beq	ts310			;
		mov	#720, -(R2)		; move to mailbox #720
		inc	-(R2)			; set msgtyp to fatal error
		halt				; incorrect status on stack, or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 310 - test that "new" status is correct
;
ts310:		inc	(R2)			; update test number
		cmp	#310, (R2)		; sequence error?
		bne	stpp			; br to error halt on seq error
		mov	#buff, SP		;
		mov	#retf, rtrap		;
		clr	rtrap+2			; clear future priority and cc
		trapa				;
retf:						; test for "C" cleared
		bpl 1$				;
		mov	#721, -(R2)		; move to mailbox #721
		inc	-(R2)			; set msgtyp to fatal error
		halt				; N not cleared
1$:						;
		bne	2$			;
		mov	#722, -(R2)		; move to mailbox #722
		inc	-(R2)			; set msgtyp to fatal error
		halt				; Z not cleared
2$:						;
		bvc 3$				;
		mov	#723, -(R2)		; move to mailbox #723
		inc	-(R2)			; set msgtyp to fatal error
		halt				; V not cleared
3$:						;
		bcc 4$				;
		mov	#724, -(R2)		; move to mailbox #724
		inc	-(R2)			; set msgtyp to fatal error
		halt				; C not cleared
4$:		bit	#340, cc		; test priority
		beq	5$			;
		mov	#725, -(R2)		; move to mailbox #725
		inc	-(R2)			; set msgtyp to fatal error
		halt				; priority not zero
5$:		mov	#buff, SP		;
		mov	#retg, rtrap		;
		mov	#357, rtrap+2		; set new "cc" and priority
		trapa				; trap here
retg:						;
		bmi	1$			;
		mov	#726, -(R2)		; move to mailbox #726
		inc	-(R2)			; set msgtyp to fatal error
		halt				; N not set
1$:						;
		beq	2$			;
		mov	#727, -(R2)		; move to mailbox #727
		inc	-(R2)			; set msgtyp to fatal error
		halt				; Z not set
2$:						;
		bvs	3$			;
		mov	#730, -(R2)		; move to mailbox #730
		inc	-(R2)			; set msgtyp to fatal error
		halt				; V not set
3$:						;
		bcs	4$			;
		mov	#731, -(R2)		; move to mailbox #731
		inc	-(R2)			; set msgtyp to fatal error
		halt				; C not set
4$:		mov	cc, SP			;
		bic	#17, SP			;
		cmp	#340, SP		;
		beq	stppa			;
stpp:						;
		mov	#732, -(R2)		; move to mailbox #732
		inc	-(R2)			; set msgtyp to fatal errur
		halt				; priority was changed, or wrong $tstnm
stppa:		mov	#12, 10			;
		clr	12			;
;_____________________________________________________________________________
;
; TEST 311 - test that a trap occurs for a "trap" instruction
;
ts311:		inc	(R2)			; update test number
		cmp	#311, (R2)		; sequence error?
		bne	ts312-10		; br to error halt on seq error
		mov	#12, 10			;
		clr	12			;
		mov	#buff, SP		; stack pointer setup
		mov	#reta1, rtrap1		; return location
		trap				; reserved instruction, should trap
		mov	#733, -(R2)		; move to mailbox #733
		inc	-(R2)			; set msgtyp to fatal error
		halt				; trap didn't trap, or wrong $tstnm
reta1:						;
;_____________________________________________________________________________
;
; TEST 312 - test decrement of stack pointer on a trap operation
;
ts312:		inc	(R2)			; update test number
		cmp	#312, (R2)		; sequence error?
		bne	ts313-10		; br to error halt on seq error
		mov	#buff, SP		; stack pointer setup
		mov	#retb1, rtrap1		; return pointer
		trap				; reserved instruction
retb1:		cmp	SP, #buff-4		; test decrement of SP
		beq	ts313			;
		mov	#734, -(R2)		; move to mailbox #734
		inc	-(R2)			; set msgtyp to fatal error
		halt				; not decremented two words, or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 313 - test that proper p.c. is saved
;
ts313:		inc	(R2)			; update test number
		cmp	#313, (R2)		; sequence error?
		bne	ts314-10		; br to error halt on seq error
		mov	#buff, SP		; stack pointer setup
		mov	#retc1, rtrap1		; return from trap pointer
		trap				; trap on this instruction
retc1:		cmp	#., buff-4		; check incremented p.c.
		beq	ts314			;
		mov	#735, -(R2)		; move to mailbox #735
		inc	-(R2)			; set msgtyp to fatal error
		halt				; incorrect p.c., or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 314 - test that "old" cc and priority are placed on stack
;
ts314:		inc	(R2)			; update test number
		cmp	#314, (R2)		; sequence error?
		bne	ts315-10		; br to error halt on seq error
		mov	#buff, SP		; set up
		mov	#retd1, rtrap1		; set up
		clr	cc			; clear cc and priority
		ccc				;
		trap				; trap
retd1:		cmp	buff-2, #0		; test that old status went to stack
		beq	1$			;
		mov	#736, -(R2)		; move to mailbox #736
		inc	-(R2)			; set msgtyp to fatal error
		halt				; incorrect status
1$:		mov	#buff, SP		; set up
		mov	#rete1, rtrap1		; set up
		mov	#357, cc		;	; set priority
		trap				; set cc
rete1:		cmp	buff-2, #357		; compares status on stack
		beq	ts315			;
		mov	#737, -(R2)		; move to mailbox #737
		inc	-(R2)			; set msgtyp to fatal error
		halt				; incorrect status on stack, or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 315 - test that "new" status is correct
;
ts315:		inc	(R2)			; update test number
		cmp	#315, (R2)		; sequence error?
		bne	ts316-10		; br to error halt on seq error
		mov	#buff, SP		;
		mov	#retf1, rtrap1		;
		clr	rtrap1+2		; clear future priority and cc
		trap				;
retf1:						; test for "C" cleared
		bpl	1$			;
		mov	#740, -(R2)		; move to mailbox #740
		inc	-(R2)			; set msgtyp to fatal error
		halt				; C not cleared
1$:						;
		bne	2$			;
		mov	#741, -(R2)		; move to mailbox #741
		inc	-(R2)			; set msgtyp to fatal error
		halt				; Z not cleared
2$:						;
		bvc 3$				;
		mov	#742, -(R2)		; move to mailbox #742
		inc	-(R2)			; set msgtyp to fatal error
		halt				; V not cleared
3$:						;
		bcc 4$				;
		mov	#743, -(R2)		; move to mailbox #743
		inc	-(R2)			; set msgtyp to fatal error
		halt				; C not cleared
4$:		bit	#340, cc		; test priority
		beq	5$			;
		mov	#744, -(R2)		; move to mailbox #744
		inc	-(R2)			; set msgtyp to fatal error
		halt				; priority not zero
5$:		mov	#buff, SP		;
		mov	#retg1, rtrap1		;
		mov	#357, rtrap1+2		; set new "cc" and priority
		trap				; trap here
retg1:						;
		bmi	1$			;
		mov	#745, -(R2)		; move to mailbox #745
		inc	-(R2)			; set msgtyp to fatal error
		halt				; N not set
1$:						;
		beq	2$			;
		mov	#746, -(R2)		; move to mailbox #746
		inc	-(R2)			; set msgtyp to fatal error
		halt				; Z not set
2$:						;
		bvs	3$			;
		mov	#747, -(R2)		; move to mailbox #747
		inc	-(R2)			; set msgtyp to fatal error
		halt				; V not set
3$:						;
		bcs	4$			;
		mov	#750, -(R2)		; move to mailbox #750
		inc	-(R2)			; set msgtyp to fatal error
		halt				; C not set
4$:		mov	cc, SP			;
		bic	#17, SP			;
		cmp	#340, SP		;
		beq	ts316			;
		mov	#751, -(R2)		; move to mailbox #751
		inc	-(R2)			; set msgtyp to fatal error
		halt				; priority was changed, or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 316 - test that all combination of "trap" will cause a trap
;
ts316:		inc	(R2)			; update test number
		cmp	#316, (R2)		; sequence error?
		bne	br45			; br to error halt on seq error
						; ***** F11 ***** add +376 to shorten test
		mov	#trap+376, rb1		; initialize base trap instruction
		mov	#ra1, 34		; return from trap to ra1
rc1:		mov	#buff, SP		; set up stack pointer
rb1:		trap				; trap inst will be modified to trap+377
br45:						;
		mov	#752, -(R2)		; move to mailbox #752
		inc	-(R2)			; set msgtyp to fatal error
		halt				; previous inst failed to trap, or wrong $tstnm
ra1:		inc	rb1			; increment trap instruction
		cmp	#104777, rb1		; trap+377 to upper limit
		bhis	rc1			; have we tested all
		mov	#36, 34			;
		clr	36			;
;_____________________________________________________________________________
;
; TEST 317 - test that a trap occures on an "iot" instruction
;
ts317:		inc	(R2)			; update test number
		cmp	#317, (R2)		; sequence error?
		bne	ts320-10		; br to error halt on seq error
		mov	#buff, SP		; stack pointer setup
		mov	#reta2, rtrap2		; return location
		iot				; reserve instruction, should trap
		mov	#753, -(R2)		; move to mailbox #753
		inc	-(R2)			; set msgtyp to fatal error
		halt				; iot didn't trap, or wrong $tstnm
reta2:
;_____________________________________________________________________________
;
; TEST 320 - test decrement of stack pointer on a trap operation
;
ts320:		inc	(R2)			; update test number
		cmp	#320, (R2)		; sequence error?
		bne	ts321-10		; br to error halt on seq error
		mov	#buff, SP		; stack pointer setup
		mov	#retb2, rtrap2		; return pointer
		iot				; reserved instruction
retb2:		cmp	SP, #buff-4		; test decrement of SP
		beq	ts321			;
		mov	#754, -(R2)		; move to mailbox #754
		inc	-(R2)			; set msgtyp to fatal error
		halt				; not decremented two words, or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 321 - test that proper p.c. is saved
;
ts321:		inc	(R2)			; update test number
		cmp	#321, (R2)		; sequence error?
		bne	ts322-10		; br to error halt on seq error
		mov	#buff, SP		; stack pointer setup
		mov	#retc2, rtrap2		; return from trap pointer
		iot				; trap on this instruction
retc2:		cmp	#., buff-4		; check for incremented p.c.
		beq	ts322			;
		mov	#755, -(R2)		; move to mailbox #755
		inc	-(R2)			; set msgtyp to fatal error
		halt				; incorrect p.c., or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 322 - test that "old" cc and priority are placed on stack
;
ts322:		inc	(R2)			; update test number
		cmp	#322, (R2)		; sequence error?
		bne	ts323-10		; br to error halt on seq error
		mov	#buff, SP		; set up
		mov	#retd2, rtrap2		; set up
		clr	cc			; clear cc and priority
		ccc				;
		iot				; trap
retd2:		cmp	buff-2, #0		; test that old status went to stack
		beq	1$			;
		mov	#756, -(R2)		; move to mailbox #756
		inc	-(R2)			; set msgtyp to fatal error
		halt				; incorrect status
1$:		mov	#buff, SP		; set up
		mov	#rete2, rtrap2		; set up
		mov	#357, cc		; set priority
		scc				; set cc
		iot				; trap
rete2:		cmp	buff-2, #357		; compares status on stack
		beq	ts323			;
		mov	#757, -(R2)		; move to mailbox #757
		inc	-(R2)			; set msgtyp to fatal error
		halt				; incorrect status on stack, or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 323 - test that "new" status is correct
;
ts323:		inc	(R2)			; update test number
		cmp	#323, (R2)		; sequence error?
		bne	br46			; br to error halt on seq error
		mov	#buff, SP		;
		mov	#retf2, rtrap2		;
		clr	rtrap2+2		; clear future priority and cc
		iot				;
retf2:						; test for "C" cleared
		bpl	1$			;
		mov	#760, -(R2)		; move to mailbox #760
		inc	-(R2)			; set msgtyp to fatal error
		halt				; N not cleared
1$:						;
		bne	2$			;
		mov	#761, -(R2)		; move to mailbox #761
		inc	-(R2)			; set msgtyp to fatal error
		halt				; Z not cleared
2$:						;
		bvc	3$			;
		mov	#762, -(R2)		; move to mailbox #762
		inc	-(R2)			; set msgtyp to fatal error
		halt				; V not cleared
3$:						;
		bcc	4$			;
		mov	#763, -(R2)		; move to mailbox #763
		inc	-(R2)			; set msgtyp to fatal error
		halt				; C not cleared
4$:		bit	#340, cc		; test priority
		beq	5$			;
		mov	#764, -(R2)		; move to mailbox #764
		inc	-(R2)			; set msgtyp to fatal error
		halt				; priority not zero
5$:		mov	#buff, SP		;
		mov	#retg2, rtrap2		;
		mov	#357, rtrap2+2		; set new "cc" and priority
		iot				; trap here
retg2:						;
		bmi	1$			;
		mov	#765, -(R2)		; move to mailbox #765
		inc	-(R2)			; set msgtyp to fatal error
		halt				; N not set
1$:						;
		beq	2$			;
		mov	#766, -(R2)		; move to mailbox #766
		inc	-(R2)			; set msgtyp to fatal error
		halt				; Z not set
2$:						;
		bvs	3$			;
		mov	#767, -(R2)		; move to mailbox #767
		inc	-(R2)			; set msgtyp to fatal error
		halt				; V not set
3$:						;
		bcs	4$			;
		mov	#770, -(R2)		; move to mailbox #770
		inc	-(R2)			; set msgtyp to fatal error
		halt				; C not set
4$:		mov	cc, SP			;
		bic	#17, SP			;
		cmp	#340, SP		;
		beq	br46a			;
br46:						;
		mov	#771, -(R2)		; move to mailbox #771
		inc	-(R2)			; set msgtyp to fatal error
		halt				; priority was changed, or wrong $tstnm
br46a:		mov	#22, 20			; .+2
		clr	22			; halt
;_____________________________________________________________________________
;
; TEST 324 - test that a trap occurs on an emt instruction
;
ts324:		inc	(R2)			; update test number
		cmp	#324, (R2)		; sequence error?
		bne	ts325-10		; br to error halt on seq error
		mov	#buff, SP		; stack pointer setup
		mov	#reta3, rtrap3		; return location
		emt				; reserve instruction, should trap
		mov	#772, -(R2)		; move to mailbox #772
		inc	-(R2)			; set msgtyp to fatal error
		halt				; emt didn't trap, or wrong $tstnm
reta3:						;
;_____________________________________________________________________________
;
; TEST 325 - test decrement of stack pointer on a trap operation
;
ts325:		inc	(R2)			; update test number
		cmp	#325, (R2)		; sequence error?
		bne	ts326-10		; br to error halt on seq error
		mov	#buff, SP		; stack pointer setup
		mov	#retb3, rtrap3		; return pointer
		emt				; reserved instruction
retb3:		cmp	SP, #buff-4		; test decrement of SP
		beq	ts326			;
		mov	#773, -(R2)		; move to mailbox #773
		inc	-(R2)			; set msgtyp to fatal error
		halt				; not decremented two words, or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 326 - test that proper p.c. is saved
;
ts326:		inc	(R2)			; update test number
		cmp	#326, (R2)		; sequence error?
		bne	ts327-10		; br to error halt on seq error
		mov	#buff, SP		; stack pointer setup
		mov	#retc3, rtrap3		; return from trap pointer
		emt				; trap on this instruction
retc3:		cmp	#., buff-4		; check for incremented p.c.
		beq	ts327			;
		mov	#774, -(R2)		; move to mailbox #774
		inc	-(R2)			; set msgtyp to fatal error
		halt				; incorrect p.c., or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 327 - test that "old" cc and priority are placed on stack
;
ts327:		inc	(R2)			; update test number
		cmp	#327, (R2)		; sequence error?
		bne	ts330-10		; br to error halt on seq error
		mov	#buff, SP		; set up
		mov	#retd3, rtrap3		; set up
		clr	cc			; clear cc and priority
		ccc				;
		emt				; trap
retd3:		cmp	buff-2, #0		; test that old status went to stack
		beq	1$			;
		mov	#775, -(R2)		; move to mailbox #775
		inc	-(R2)			; set msgtyp to fatal error
		halt				; incorrect status
1$:		mov	#buff, SP		; set up
		mov	#rete3, rtrap3		; set up
		mov	#357, cc		; set priority
		scc				; set cc
		emt				; trap
rete3:		cmp	buff-2, #357		; compares status on stack
		beq	ts330			;
		mov	#776, -(R2)		; move to mailbox #776
		inc	-(R2)			; set msgtyp to fatal error
		halt				; incorrect status on stack, or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 330 - test that "new" status is correct
;
ts330:		inc	(R2)			; update test number
		cmp	#330, (R2)		; sequence error?
		bne	ts331-10		; br to error halt on seq error
		mov	#buff, SP		;
		mov	#retf3, rtrap3		;
		clr	rtrap3+2		; clear future priority and cc
		emt				;
retf3:						; test for "C" cleared
		bpl 1$				;
		mov	#777, -(R2)		; move 10 mailbox #777
		inc	-(R2)			; set msgtyp to fatal error
		halt				; C not cleared
1$:						;
		bne	2$			;
		mov	#1000, -(R2)		; move to mailbox #1000
		inc	-(R2)			; set msgtyp to fatal error
		halt				; Z not cleared
2$:						;
		bvc	3$			;
		mov	#1001, -(R2)		; move to mailbox #1001
		inc	-(R2)			; set msgtyp to fatal error
		halt				; V not cleared
3$:						;
		bcc	4$			;
		mov	#1002, -(R2)		; move to mailbox #1002
		inc	-(R2)			; set msgtyp to fatal error
		halt				; C not cleared
4$:		bit	#340, cc		; test priority
		beq	5$			;
		mov	#1003, -(R2)		; move to mailbox #1003
		inc	-(R2)			; set msgtyp to fatal error
		halt				; priority not zero
5$:		mov	#buff, SP		;
		mov	#retg3, rtrap3		;
		mov	#357, rtrap3+2		; set new "cc" and priority
		emt				; trap here
retg3:						;
		bmi	1$			;
		mov	#1004, -(R2)		; move to mailbox #1004
		inc	-(R2)			; set msgtyp to fatal error
		halt				; N not set
1$:						;
		beq	2$			;
		mov	#1005, -(R2)		; move to mailbox #1005
		inc	-(R2)			; set msgtyp to fatal error
		halt				; Z not set
2$:						;
		bvs	3$			;
		mov	#1006, -(R2)		; move to mailbox #1006
		inc	-(R2)			; set msgtyp to fatal error
		halt				; V not set
3$:						;
		bcs	4$			;
		mov	#1007, -(R2)		; move to mailbox #1007
		inc	-(R2)			; set msgtyp to fatal error
		halt				; C not sct
4$:		ccc				;
		cmp	#340, cc		;
		beq	ts331			;
		mov	#1010, -(R2)		; move to mailbox #1010
		inc	-(R2)			; set msgtyp to fatal error
		halt				; priority was changed, or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 331 - test that all combination of emt will cause a trap
;
ts331:		inc	(R2)			; update test number
		cmp	#331, (R2)		; sequence error?
		bne	br47			; br to error halt on seq error
						; **** F11 **** add +376 to shorten test
		mov	#emt+376, rb		; initialize base emt instruction
		mov	#ra, 30			; re turn from trap to ra
rc:		mov	#buff, SP		; set up stack pointer
rb:		emt				; trap inst. will be modified to emt+377
br47:						;
		mov	#1011, -(R2)		; move to mailbox #1011
		inc	-(R2)			; set msgtyp to fatal error
		halt				; previous inst failed to trap, or wrong $tstnm
ra:		inc rb				; increment trap instruction
		cmp	#104377, rb		; emt+377 to emt?
		bhis	rc			; have we tested all
						; yes
		mov	#32, 30			; /.+
		clr	32			; halt
;_____________________________________________________________________________
;
; TEST 332 - test that a trap occures on an "trace-trt" instruction
;
ts332:		inc	(R2)			; update test number
		cmp	#332, (R2)		; sequence error?
		bne	ts333-10		; br to error halt on seq error
		mov	#buff, SP		; stack pointer setup
		mov	#reta4, rtrap4		; return location
		trt				; reserved instruction, should trap
		mov	#1012, -(R2)		; move to mailbox #1012
		inc	-(R2)			; set msgtyp to fatal error
		halt				; trt didn't trap, or wrong $tstnm
reta4:
;_____________________________________________________________________________
;
; TEST 333 - test decrement of stack pointer on a trap operation
;
ts333:		inc	(R2)			; update test number
		cmp	#333, (R2)		; sequence error?
		bne	ts334-10		; br to error halt on seq error
		mov	#buff, SP		; stack pointer setup
		mov	#retb4, rtrap4		; return pointer
		trt				; reserved instruction
retb4:		cmp	SP, #buff-4		; test decrement of SP
		beq	ts334			;
		mov	#1013, -(R2)		; move to mailbox #1013
		inc	-(R2)			; set msgtyp to fatal error
		halt				; not decremented two words, or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 334 - test that proper p.c. is saved
;
ts334:		inc	(R2)			; update test number
		cmp	#334, (R2)		; sequence error?
		bne	ts335-10		; br to error halt on seq error
		mov	#buff, SP		; stack pointer setup
		mov	#retc4, rtrap4		; return from trap pointer
		trt				; trap on this instruction
retc4:		cmp	#., buff-4		; check for incremented p.c.
		beq	ts335			;
		mov	#1014, -(R2)		; move to mailbox #1014
		inc	-(R2)			; set msgtyp to fatal error
		halt				; incorrect p.c., or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 335 - test that "old" cc and priority are placed on stack
;
ts335:		inc	(R2)			; update test number
		cmp	#335, (R2)		; sequence error?
		bne	ts336-10		; br to error halt on seq error
		mov	#buff, SP		; set up
		mov	#retd4, rtrap4		; set up
		clr	cc			; clear cc and priority
		ccc				;
		trt				; trap
 retd4:		cmp	buff-2, #0		; test that old status went to stack
						; test for all zeros
		beq	1$			;
		mov	#1015, -(R2)		; move to mailbox #1015
		inc	-(R2)			; set msgtyp to fatal error
		halt				; incorrect status
1$:		mov	#buff, SP		; set up
		mov	#rete4, rtrap4		; set up
		mov	#357, cc		; set priority
		scc				; set-set cc
		trt				; trap
rete4:		cmp	buff-2, #357		; compares status on stack
		beq	ts336			;
		mov	#1016, -(R2)		; move to mailbox #1016
		inc	-(R2)			; set msgtyp to fatal error
		halt				; incorrect status on stack, or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 336 - test that "new" status is correct
;
ts336:		inc	(R2)			; update test number
		cmp	#336, (R2)		; sequence error?
		bne	br51			; br to error halt on seq error
		mov	#buff, SP		;
		mov	#retf4, rtrap4		;
		clr	rtrap4+2		; clear future priority and cc
		trt				;
retf4:						; test for "C" cleared
		bpl	1$			;
		mov	#1017, -(R2)		; move to mailbox #1017
		inc	-(R2)			; set msgtyp to fatal error
		halt				; C not cleared
1$:						;
		bne	2$			;
		mov	#1020, -(R2)		; move to mailbox #1020
		inc	-(R2)			; set msgtyp to fatal error
		halt				; Z not cleared
2$:						;
		bvc	3$			;
		mov	#1021, -(R2)		; move to mailbox #1021
		inc	-(R2)			; set msgtyp to fatal error
		halt				; V not cleared
3$:						;
		bcc	4$			;
		mov	#1022, -(R2)		; move to mailbox #1022
		inc	-(R2)			; set msgtyp to fatal error
		halt				; C not cleared
4$:		bit	#340, cc		; test priority
		beq	5$			;
		mov	#1023, -(R2)		; move to mailbox #1023
		inc	-(R2)			; set msgtyp to fatal error
		halt				; priority not zero
5$:		mov	#buff, SP		;
		mov	#retg4, rtrap4		;
		mov	#357, rtrap4+2		; set new "cc" and priority
		trt				; trap here
retg4:						;
		bmi	1$			;
		mov	#1024, -(R2)		; move to mailbox #1024
		inc	-(R2)			; set msgtyp to fatal error
		halt				; N not set
1$:						;
		beq	2$			;
		mov	#1025, -(R2)		; move to mailbox #1025
		inc	-(R2)			; set msgtyp to fatal error
		halt				; Z not set
2$:						;
		bvs	3$			;
		mov	#1026, -(R2)		; move to mailbox #1026
		inc	-(R2)			; set msgtyp to fatal error
		halt				; V not set
3$:						;
		bcs	4$			;
		mov	#1027, -(R2)		; move to mailbox #1027
		inc	-(R2)			; set msgtyp to fatal error
		halt				; C not set
4$:		mov	cc, SP			;
		bic	#17, SP			;
		cmp	#340, SP		;
		beq	br51a			;
br51:						;
		mov	#1030, -(R2)		; move to mailbox #1030
		inc	-(R2)			; set msgtyp to fatal error
		halt				; priority was changed, or wrong $tstnm
br51a:		mov	#16, 14			;
		clr	16			;
;_____________________________________________________________________________
;
; PDP-11 illegal and address instruction test
; all instructions that are reserved
; should trap to location 4, and the
; PC that points to the trapping instruction
; should be placed on the stack
;
; TEST 337 - test that a trap occurs on an illegal instruction
;
ts337:		inc	(R2)			; update test number
		cmp	#337, (R2)		; sequence error?
		bne	ts340-10		; br to error halt on seq error
		mov	#buff, SP		; stack pointer setup
		mov	#reta5, rtrap5		; return location
		jmp	R0			; illegal instruction, should trap
		mov	#1031, -(R2)		; move to mailbox #1031
		inc	-(R2)			; set msgtyp to fatal error
		halt				; illegal instruction didn't trap, or wrong $tstnm
reta5:						;
;_____________________________________________________________________________
;
; TEST 340 - test decrement of stack pointer on a trap operation
;
ts340:		inc	(R2)			; update test number
		cmp	#340, (R2)		; sequence error?
		bne	ts341-10		; br to error halt on seq error
		mov	#buff, SP		; stack pointer setup
		mov	#retb5, rtrap5		; return pointer
		jmp	R0			; reserved instruction
retb5:		cmp	SP, #buff-4		; test decrement of SP
		beq	ts341			;
		mov	#1032, -(R2)		; move to mailbox #1032
		inc	-(R2)			; set msgtyp to fatal error
		halt				; not decremented two words, or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 341 - test that proper p.c. is saved
;
ts341:		inc	(R2)			; update test number
		cmp	#341, (R2)		; sequence error?
		bne	ts342-10		; br to error halt on seq error
		mov	#buff, SP		; stack pointer setup
		mov	#retc5, rtrap5		; return from trap pointer
		jmp	R0			; trap on this instruction
retc5:		cmp	#., buff-4		; check for incremented p.c.
		beq	ts342			;
		mov	#1033, -(R2)		; move to mailbox #1033
		inc	-(R2)			; set msgtyp to fatal error
		halt				; incorrect p.c., or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 342 - test that "old" cc and priority are placed on stack
;
ts342:		inc	(R2)			; update test number
		cmp	#342, (R2)		; sequence error?
		bne	ts343-10		; br to error halt on seq error
		mov	#buff, SP		; set up
		mov	#retd5, rtrap5		; set up
		clr	cc			; clear cc and priority
		ccc				;
		jmp	R0			; trap
retd5:		cmp	buff-2, #0		; test that old status went to stack
		beq	1$			;
		mov	#1034, -(R2)		; move to mailbox #1034
		inc	-(R2)			; set msgtyp to fatal error
		halt				; incorrect status
1$:		mov	#buff, SP		; set up
		mov	#rete5, rtrap5		; set up
		mov	#357, cc		; set priority
		scc				; set cc
		jmp	R0			; trap
rete5:		cmp	buff-2, #357		; compares status on stack
		beq	ts343			;
		mov	#1035, -(R2)		; move to mailbox #1035
		inc	-(R2)			; set msgtyp to fatal error
		halt				; incorrect status on stack, or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 343 - test that "new" status is correct
;
ts343:		inc	(R2)			; update test number
		cmp	#343, (R2)		; sequence error?
		bne	ts344-10		; br to error halt on seq error
		mov	#buff, SP		;
		mov	#retf5, rtrap5		;
		clr	rtrap5+2		; clear future priority and tc
		jmp	R0			;
retf5:						; test for "C" cleared
		bpl	1$			;
		mov	#1036, -(R2)		; move to mailbox #1036
		inc	-(R2)			; set msgtyp to fatal error
		halt				; C not cleared
1$:						;
		bne	2$			;
		mov	#1037, -(R2)		; move to mailbox #1037
		inc	-(R2)			; set msgtyp to fatal error
		halt				; Z not cleared
2$:						;
		bvc 3$				;
		mov	#1040, -(R2)		; move to mailbox #1040
		inc	-(R2)			; set msgtyp to fatal error
		halt				; V not cleared
3$:						;
		bcc	4$			;
		mov	#1041, -(R2)		; move to mailbox #1041
		inc	-(R2)			; set msgtyp to fatal error
		halt				; C not cleared
4$:		bit	#357, cc		; test priority
		beq	5$			;
		mov	#1042, -(R2)		; move to mailbox #1042
		inc	-(R2)			; set msgtyp to fatal error
		halt				; priority not zero
5$:		mov	#buff, SP		;
		mov	#retg5, rtrap5		;
		mov	#357, rtrap5+2		; set new "cc" and priority
		jmp	R0			; trap here
retg5:						;
		bmi	1$			;
		mov	#1043, -(R2)		; move to mailbox #1043
		inc	-(R2)			; set msgtyp to fatal error
		halt				; N not set
1$:						;
		beq	2$			;
		mov	#1044, -(R2)		; move to mailbox #1044
		inc	-(R2)			; set msgtyp to fatal error
		halt				; Z not set
2$:						;
		bvs	3$			;
		mov	#1045, -(R2)		; move to mailbox #1045
		inc	-(R2)			; set msgtyp to fatal error
		halt				; V not set
3$:						;
		bcs	4$			;
		mov	#1046, -(R2)		; move to mailbox #1046
		inc	-(R2)			; set msgtyp to fatal error
		halt				; C not set
4$:		mov	cc, SP			;
		cmp	#357, SP		;
		beq	ts344			;
		mov	#1047, -(R2)		; move to mailbox #1047
		inc	-(R2)			; set msgtyp to fatal error
		halt				; priority was changed, or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 344 - test that a trap occures on all illegal instructon
;
ts344:		inc	(R2)			; update test number
		cmp	#344, (R2)		; sequence error?
		bne	ts345-10		; br to error halt on seq error
		mov	#buff, SP		; stack pointer setup
		mov	#reth5, rtrap5		; return location
		jsr	R0, R0			; reserved instruction. should trap
		mov	#1050, -(R2)		; move to mailbox #1050
		inc	-(R2)			; set msgtyp to fatal frror
		halt				; didn't trap, or wrong $tstnm
reth5:						;
;_____________________________________________________________________________
;
; TEST 345 - test decrement of stack pointer on a trap operation
;
ts345:		inc	(R2)			; update test number
		cmp	#345, (R2)		; sequence error?
		bne	ts346-10		; br to error halt on seq error
		mov	#buff, SP		; stack pointer setup
		mov	#retj, rtrap5		; return pointer
		jsr	R0, R0			; reserved instruction
retj:		cmp	SP, #buff-4		; test decrement of SP
		beq	ts346			;
		mov	#1051, -(R2)		; move to mailbox #1051
		inc	-(R2)			; set msgtyp to fatal error
		halt				; not decremented two words, or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 346 - test that proper p.c. is saved
;
ts346:		inc	(R2)			; update test number
		cmp	#346, (R2)		; sequence error?
		bne	ts347-10		; br to error halt on seq error
		mov	#buff, SP		; stack pointer setup
		mov	#retk, rtrap5		; return from trap pointer
instk:		jsr	R0, R0			; trap on this instruction
retk:		cmp	#instk+2, buff-4	; check for incremened p.c.
		beq	ts347			;
		mov	#1052, -(R2)		; move to mailbox #1052
		inc	-(R2)			; set msgtyp to fatal error
		halt				; incorrect p.c., or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 347 - test that "old" cc and priority are placed on stack
;
ts347:		inc	(R2)			; update test number
		cmp	#347, (R2)		; sequence error?
		bne	ts350-10		; br to error halt on seq error
		mov	#buff, SP		; set up
		mov	#retl, rtrap5		; set up
		clr	cc			; clear cc and priority
		ccc				;
		jsr	R0, R0			; trap
retl:		cmp	buff-2, #0		; test that old status went to stack
		beq	1$			;
		mov	#1053, -(R2)		; move to mailbox #1053
		inc	-(R2)			; set msgtyp to fatal error
		halt				; incorrct status
1$:		mov	#buff, SP		; set up
		mov	#retm, rtrap5		; set up
		mov	#357, cc		; set priority
		scc				; set cc
		jsr	R0, R0			; trap
retm:		cmp	buff-2, #357		; compares status on stack
		beq	ts350			;
		mov	#1054, -(R2)		; move to mailbox #1054
		inc	-(R2)			; set msgtyp to fatal error
		halt				; incorrect status on stack, or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 350 - test that "new" status is correct
;
ts350:		inc	(R2)			; update test number
		cmp	#350, (R2)		; sequence error?
		bne	ts351-10		; br to error halt on seq error
		mov	#buff, SP		;
		mov	#retn, rtrap5		;
		clr	rtrap5+2		; clear future priority and cc
		jsr	R0, R0			;
retn:						; test for "C" cleared
		bpl	1$			;
		mov	#1055, -(R2)		; move to mailbox #1055
		inc	-(R2)			; set msgtyp to fatal error
		halt				; C not cleared
1$:						;
		bne	2$			;
		mov	#1056, -(R2)		; move to mailbox #1056
		inc	-(R2)			; set msgtyp to fatal error
		halt				; Z not cleared
2$:						;
		bvc 3$				;
		mov	#1057, -(R2)		; move to mailbox #1057
		inc	-(R2)			; set msgtyp to fatal error
		halt				; V not cleared
3$:						;
		bcc 4$				;
		mov	#1060, -(R2)		; move to mailbox #1060
		inc	-(R2)			; set msgtyp to fatal error
		halt				; C not cleared
4$:		mov	cc, R0			; temp storage
		beq	5$			;
		mov	#1061, -(R2)		; move to mailbox #1061
		inc	-(R2)			; set msgtyp to fatal error
		halt				; priority not zero
5$:		mov	#buff, SP		;
		mov	#reto, rtrap5		;
		mov	#357, rtrap5+2		; set new "cc" and priority
		jsr	R0, R0			; trap here
reto:						;
		bmi	1$			;
		mov	#1062, -(R2)		; move to mailbox #1062
		inc	-(R2)			; set msgtyp to fatal error
		halt				; N not set
1$:						;
		beq	2$			;
		mov	#1063, -(R2)		; move to mailbox #1063
		inc	-(R2)			; set msgtyp to fatal error
		halt				; Z not set
2$:						;
		bvs 3$				;
		mov	#1064, -(R2)		; move to mailbox #1064
		inc	-(R2)			; set msgtyp to fatal error
		halt				; V not set
3$:						;
		bcs 4$				;
		mov	#1065, -(R2)		; move to mailbox #1065
		inc	-(R2)			; set msgtyp to fatal error
		halt				; C not set
4$:		mov	cc, R0			;
		cmp	#357, R0		;
		beq	ts351			;
		mov	#1066, -(R2)		; move 10 mailbox #1066
		inc	-(R2)			; set msgtyp to fatal error
		halt				; priority was changed, or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 351 - test that decrement SP to a value less than 400 traps
;
ts351:		inc	(R2)			; update test number
		cmp	#351, (R2)		; sequence error?
		bne	ts352-10		; br to error halt on seq error
		mov	#150, SP		; SP=150
		mov	#tdec1, 4		; stack overflow trap pointer
		tst	-(6)			; with SP=150 should trap
		mov	#1067, -(R2)		; move to mailbox #1067
		inc	-(R2)			; set msgtyp to fatal error
		halt				; should have trapped, or wrong $tstnm
tdec1:						;
;_____________________________________________________________________________
;
; TEST 352 - test for decrement of SP on overflow trap
;
ts352:		inc	(R2)			; update test number
		cmp	#352, (R2)		; sequence error?
		bne	ts353-10		; br to error halt on seq error
		mov	#150, SP		; SP=150
		mov	#tdec2, 4		; trap pointer
		tst	-(6)			; with SP=150 should trap
tdec2:		cmp	SP, #142		; did SP decrement
		beq	ts353			;
		mov	#1070, -(R2)		; move to mailbox #1070
		inc	-(R2)			; set msgtyp to fatal error
		halt				; SP not = 142, or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 353 - test different types of overflow
;
ts353:		inc	(R2)			; update test number
		cmp	#353, (R2)		; sequence error?
		bne	ts354-10		; br to error halt on seq error
		mov	#150, SP		;
		clr	146			; status word of loc.10
		mov	#tdec3, 4		; return to loc.4
		inc	-(6)			;
tdec3:		tst	146			;
		bne	1$			;
		mov	#1071, -(R2)		; move to mailbox #1071
		inc	-(R2)			; set msgtyp to fatal error
		halt				; increment operation not inhibited
1$:		mov	#1000, R5		;
		mov	#400, SP		;
		mov	#tdec4, 4		;
		cmpb	-(6), -(5)		;
		mov	#1072, -(R2)		; move to mailbox #1072
		inc	-(R2)			; set msgtyp to fatal error
		halt				; stack = 400 and decremented. should trap
tdec4:		mov	#400, SP		;
		mov	#tdec7, 4		;
		bitb	-(5), -(6)		;
tdec6:						;
		mov	#1073, -(R2)		; move to mailbox #1073
		inc	-(R2)			; set msgtyp to fatal error
		halt				; no stack overflow, or wrong $tstnm
tdec7:						;
;_____________________________________________________________________________
;
; TEST 354 - test that an 77 causes an overflow trap
;
ts354:		inc	(R2)			; update test number
		cmp	#354, (R2)		; sequence error?
		bne	vdec2			; br to error halt on seq error
		mov	#400, SP		; set up stack to overflow
		mov	#vdec2, 10		; set up 77 vector
		mov	#vdec1, 4		; set up overflow vector
		77				; this trap should cause overflow
vdec2:						;
		mov	#1074, -(R2)		; move to mailbox #1074
		inc	-(R2)			; set msgtyp to fatal error
		halt				; trap flag overflow did not occur, or wrong $tstnm
vdec1:		mov	#10+2, 10		;
;_____________________________________________________________________________
;
; TEST 355 - test that an iot causes an overflow trap
;
ts355:		inc	(R2)			; update test number
		cmp	#355, (R2)		; sequence error?
		bne	vdec4			; br to error halt on seq error
		mov	#400, SP		; set up stack to overflow
		mov	#vdec4, 20		; set up iot vector
		mov	#vdec3, 4		; set up overflow vector
		iot				; this trap should cause overflow
vdec4:						;
		mov	#1075, -(R2)		; move to mailbox #1075
		inc	-(R2)			; set msgtyp to fatal error
		halt				; trap flag overflow did not occur, or wrong $tstnm
vdec3:		mov	#20+2, 20		;
;_____________________________________________________________________________
;
; TEST 356 - test that an emt causes an overflow trap
;
ts356:		inc	(R2)			; update test number
		cmp	#356, (R2)		; sequence error?
		bne	vdec6			; br to error halt on seq error
		mov	#400, SP		; set up stack to overflow
		mov	#vdec6, 30		; set up emt vector
		mov	#vdec5, 4		; set up overflow vector
		emt				; this trap should cause overflow
vdec6:						;
		mov	#1076, -(R2)		; move to mailbox #1076
		inc	-(R2)			; set msgtyp to fatal error
		halt				; trap flag overflow did not occur.or wrong $tstiti
vdec5:		mov	#30+2, 30		;
;_____________________________________________________________________________
;
; TEST 357 - test that an trap causes an overflow trap
;
ts357:		inc	(R2)			; update test number
		cmp	#357, (R2)		; sequence error?
		bne	vdec8			; br to error halt on seq error
		mov	#400, SP		; set up stack to overflow
		mov	#vdec8, 34		; set up trap vector
		mov	#vdec7, 4		; set up overflow vector
		trap				; this trap should cause overflow
vdec8:						;
		mov	#1077, -(R2)		; move to mailbox #1077
		inc	-(R2)			; set msgtyp to fatal error
		halt				; trap flag overflow did not occur, or wrong $tstnm
vdec7:		mov	#34+2, 34		;
;_____________________________________________________________________________
;
; TEST 360 - test that an trt causes an overflow trap
;
ts360:		inc	(R2)			; update test number
		cmp	#360, (R2)		; sequence error?
		bne	vdec10			; br to error halt on seq error
		mov	#400, SP		; set up stack to overflow
		mov	#vdec10, 14		; set up trt vector
		mov	#vdec9, 4		; set up overflow vector
		trt				; this trap should cause overflow
vdec10:						;
		mov	#1100, -(R2)		; move to mailbox #1100
		inc	-(R2)			; set msgtyp to fatal error
		halt				; trap flag overflow did not occur, or wrong $tstnm
vdec9:		mov	#14+2, 14		;
;_____________________________________________________________________________
;
; TEST 361 - test that an illa causes an overflow trap
;
ts361:		inc	(R2)			; update test number
		cmp	#361, (R2)		; sequence error?
		bne	vdec11			; br to error halt on seq error
		mov	#400, SP		; set up stack to overflow
		mov	#vdec11, 10		; set up illa vector
		mov	#vdec12, 4		; set up overflow vector
		illa				; this trap should cause overflow
vdec11:						;
		mov	#1101, -(R2)		; move to mailbox #1101
		inc	-(R2)			; set msgtyp to fatal error
		halt				; trap flag overflow did not occur, or wrong $tstnm
vdec12:		mov	#10+2, 10		;
		cmp	SP, #370		; stack pushed four words
		beq	ts362			;
		mov	#1102, -(R2)		; move to mailbox #1102
		inc	-(R2)			; set msgtyp to fatal error
		halt				; trap overflow did not occur
						; or sequence error
;_____________________________________________________________________________
;
; TEST 362 - test that an illb causes an overflow trap
;
ts362:		inc	(R2)			; update test number
		cmp	#362, (R2)		; sequence error?
		bne	vdec13			; br to error halt on seq error
		mov	#400, SP		; set up stack to overflow
		mov	#vdec13, 10		; set up illb vector
		mov	#vdec14, 4		; set up overflow vector
		illb				; this trap should cause overflow
vdec13:						;
		mov	#1103, -(R2)		; move to mailbox #1103
		inc	-(R2)			; set msgtyp to fatal error
		halt				; trap flag overflow did not occur, or wrong $tstnm
vdec14:		mov	#10+2, 10		;
;_____________________________________________________________________________
;
; TEST 363 - test for false overflow trap
;
ts363:		inc	(R2)			; update test number
		cmp	#363, (R2)		; sequence error?
		bne	fover			; br R0 error halt on seq error
		mov	#fover, 4		; set up overflow pointer
		mov	#1002, SP		;
		tst	-(6)			; should not overflow
		mov	#2002, SP		;
		tst	-(6)			; should not overflow
		mov	#4002, SP		;
		tst	-(6)			; should not overflow
		mov	#10002, SP		;
		tst	-(6)			;
		mov	#20000, SP		; should not overflow
		tst	-(6)			;
		br	stp			;
fover:						;
		mov	#1104, -(R2)		; move to mailbox #1104
		inc	-(R2)			; set msgtyp to fatal error
		halt				; it overflowed, or wrong $tstnm
stp:		mov	#6, 4			;
		clr	6			;
;_____________________________________________________________________________
;
; TEST 364 - test that bit 4 PSW will cause a trap to 14
;
ts364:		inc	(R2)			; update test number
		cmp	#364, (R2)		; sequence error?
		bne	ts365-10		; br to error halt on seq error
		mov	#buff, SP		;
		mov	#retat, rtrap4		; set up to trap to 14
		mov	#20, -(SP)		; push T-bit
		mov	#.+6, -(SP)		; push PC
		rti				; set T-bit
		nop				; trap here
		mov	#1105, -(R2)		; move to mailbox #1105
		inc	-(R2)			; set msgtyp to fatal error
		halt				; trace bit did not trap, or wrong $tstnm
retat:						;
;_____________________________________________________________________________
;
; TEST 365 - test stack pointer decrements
;
ts365:		inc	(R2)			; update test number
		cmp	#365, (R2)		; sequence error?
		bne	ts366-10		; br to error halt on seq error
		mov	#buff, SP		;
		mov	#retbt, rtrap4		;
		mov	#20, -(SP)		; push T-bit
		mov	#.+6, -(SP)		; push PC
		rti				; set T-bit
		nop				; trap here
		mov	#1106, -(R2)		; move to mailbox #1106
		inc	-(R2)			; set msgtyp to fatal error
		halt				; trace bit did not trap!
retbt:		cmp	SP, #buff-4		;
		beq	ts366			;
		mov	#1107, -(R2)		; move to mailbox #1107
		inc	-(R2)			; set msgtyp to fatal error
		halt				; stack pointer was not pushed by trap, or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 366 - test for proper PC on stack
;
ts366:		inc	(R2)			; update test number
		cmp	#366, (R2)		; sequence error?
		bne	ts367-10		; br to error halt on seq error
		mov	#buff, SP		;
		mov	#retct, rtrap4		;
		mov	#20, -(SP)		; push T-bit
		mov	#.+6, -(SP)		; push PC
		rti				; set T-bit
						; trap here
retct:		cmp	#., buff-4		;
		beq	ts367			;
		mov	#1110, -(R2)		; move to mailbox #1110
		inc	-(R2)			; set msgtyp to fatal error
		halt				; correct PC was not saved on stack, or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 367 - test that rtt pops T-bit
;
ts367:		inc	(R2)			; update test number
		cmp	#367, (R2)		; sequence error?
		bne	ts370-10		; br to error halt on seq error
						;
		mov	#buff, SP		;
		clr	R1			; clear R1
		mov	#20, -(SP)		;
		mov	#rtt1, -(SP)		;
		mov	#rtt2, 14		;
		rtt				;
rtt1:		nop				;
		beq	ts370			;
		mov	#1111, -(R2)		; move to mailbox #1111
		inc	-(R2)			; set msgtyp to fatal error
		halt				; T-bit did not trap, or wrong $tstnm
						; or sequence error
rtt2:						;
;_____________________________________________________________________________
;
; TEST 370 - test that rtt allows one inst. before trap
;
ts370:		inc	(R2)			; update test number
		cmp	#370, (R2)		; sequence error?
		bne	ts371-10		; br to error halt on seq error
		mov	#177777, R5		;
rtt5:		mov	#buff, SP		;
		mov	#20, -(SP)		;
		mov	#rtt3, -(SP)		;
		mov	#rtt4, 14		;
		clr	R1			; clear R0
		rtt				; set T-bit
rtt3:		inc	R1			;
		inc	R5			;
		beq	rtt5			; do this test no more than 2 times
		mov	#1112, -(R2)		; move to mailbox #1112
		inc	-(R2)			; set msgtyp to fatal error
		halt				; did not trap
rtt4:		dec	R1			; see if rtt allows 1 inst.
		beq	rtt6			;
		inc	R5			; do this test no more than two times
		beq	rtt5			;
		mov	#1113, -(R2)		; move to mailbox #1113
		inc	-(R2)			; set msgtyp to fatal error
		halt				; rtt did not allow 1 inst., or wrong $tstnm
rtt6:						;
;_____________________________________________________________________________
;
; TEST 371 - test that rti does not allow 1 inst.
;
ts371:		inc	(R2)			; update test number
		cmp	#371, (R2)		; sequence error
		bne	ts372-10		; br to error halt on seq error
		mov	#buff, SP		;
		mov	#20, -(SP)		;
		mov	#rti1, -(SP)		;
		mov	#rti2, 14		;
		clr	R1			;
		rti				; set T-bit
rti1:		inc	R1			; rti should not allow this
		mov	#1114, -(R2)		; move to mailbox #1114
		inc	-(R2)			; set msgtyp to fatal error
		halt				; T-bit did not cause trap
rti2:		tst	R1			;
						; rti should not allow 1 inst. before trap
		beq	ts372			;
		mov	#1115, -(R2)		; move to mailbox #1115
		inc	-(R2)			; set msgtyp to fatal error
		halt				; rti did allow 1 inst. before trap, or wrong $tstnm
						; or sequence error
;_____________________________________________________________________________
;
; TEST 372 - test trap on trap that trace bit traps are inhibited on trap inst
;
ts372:		inc	(R2)			; update test number
		cmp	#372, (R2)		; sequence error?
		bne	br70			; br to error halt on seq error
		mov	#buff, SP		;
		mov	#trace, 14		; trace trap
		clr	#16			;
		clr	#22			;
		mov	#tont1, 20		; iot trap
		mov	#20, -(SP)		; push T-bit
		mov	#.+6, -(SP)		; push rc
		rtt				;
		iot				; trap, new cc have trace reset
trace:						;
		mov	#1116, -(R2)		; move to map box #1116
		inc	-(R2)			; set msgtyp to fatal error
		halt				; trace trap was not inhibited
br70:						;
		mov	#1117, -(R2)		; move to mailbox #1117
		inc	-(R2)			; set msgtyp to fatal error
		halt				; wrong tstnm, or wrong $tstnm
tont1:		mov	#16, 14			;
		mov	#22, 20			;
;_____________________________________________________________________________
;
; TEST 373 - test that the trace bit is saved in the stack
;
ts373:		inc	(R2)			; update test number
		cmp	#373, (R2)		; sequence error?
		bne	stp3			; br to error halt on seq error
		mov	#buff, SP		; set up stack pointer
		mov	#trc1, 14		; trace trap return
		clr	16			;
		mov	#20, -(SP)		; set the T-bit
		mov	#trc1, -(SP)		;
		rti				;
trc1:		bit	buff-2, #20		; check for T-bit on stack
		bne	stp3d			;
stp3:						;
		mov	#1120, -(R2)		; move to mailbox #1120
		inc	-(R2)			; set msgtyp to fatal error
		halt				; T-bit not saved on the stack, or wrong $tstnm
stp3d:		mov	#16, 14			;
;_____________________________________________________________________________
;
; This routine tests that no legal address traps and that an illegal
; address traps to location 4. This will run on 30k system. But if
; switch register bit 1=0, then the memory from 28k-30k is not looked
; at, since it may have i/o devices. If swr bit 1=1, then that area is
; checked. (it should either all trap or all not trap). loc.160000
; is no longer guaranteed to trap, since it may contain memory. Location
; 177700 (the unibus address for R0 on older systems) is used for forcing
; a timeout in the event that there was no timeout from 0k-28k or 30k.
; This routine tests memory until it does a nxm stop
;
; TEST 374 - test non-existent address traps
;
ts374:		inc	(R2)			; iipdate test number
		cmp	#374, (R2)		; sequence error?
		bne	ts375-10		; br to error halt on seq error
		bic	#10000, @#hicore	; set right core limit to 160000
		bit	#2, @swr		; check if bit 1 is cleared
		beq	1$			; branch if it is, leave limit 160000
		bis	#10000, @#hicore	; set upper core limit to 30k (170000)
1$:						;
.if ne memlim					;
		mov	#memlim-10, R0		; to reduce simulation time
.iff						; let's set pointer close to the 
		clr	R0			; real memory limit
.endc						;
		clr	6			;
		mov	#atrap, 4		; set up address trap entrance
		mov	#buff, SP		; set stack pointer
nor:		tstb	(0)+			; if outside of core, trap to 4
		cmp	R0, (PC)+		; is pointer inside 28k (30k) core
hicore:						;
.if ne memlim					;
		.word	memlim			;
.iff						;
		.word	160000			; may be changed to 170000 if 30K
.endc						;
		blo	nor			; test the rest of core
		mov	#rotrap, @#4		; set up new vector pointer
		tstb	@#177700		; should cause a trap
trpadr:						;
		mov	#1121, -(R2)		; move to mailbox #1121
		inc	-(R2)			; set msgtyp to fatal error
		halt				; should have traped
	; trap to here if forcing trap by testing 177700
rotrap:		mfps	status			;
		tst	status			; test PSW
		beq	1$			;
		mov	#1122, -(R2)		; move to mailbox *1122
		inc	-(R2)			; set msgtyp to fatal error
		halt				; new PSW should have been zero
1$:		cmp	buff-4, #trpadr		; test old PC at stack
		beq	trapb			;
		mov	#1123, -(R2)		; move to mailbox #1123
		inc	-(R2)			; set msgtyp to fatal error
		halt				; old PC was not saved
	; return here on an address trap from memory below 28k (or 30k)
atrap:		dec	R0			;
		mov	R0, corh		; move the first nxm location in corh
	; this routine does nxm traps until it finds an existent memory location
		mov	@#hicore, R0		; set up the highest mem location
		dec	R0			; make 1 less than the highest core boundary
		br	nosub			; don't subtract 1k first time
ctrap:		sub	#1000, R0		; subtract 1k octal byte from address
						; to speed up testing
nosub:		mov	#btrap, 4		; set up the vector
		mov	#buff, SP		;
		tst	(R0)			; does this memory exist?
						; if nxm, trap to btrap
dtrap1:		cmp	R0, (PC)+		; if exists. is this the same trap that caused
						; trap to atrap
corh:		.word	0			;
		blos	trapb			;
		mov	#1124, -(R2)		; move to mailbox #1124
		inc	-(R2)			; set msgtyp to fatal error
		halt				; contents of R0 should be less than or equal tc .0rh?????
						; if this comparison fails it means
						; that some legal address trapped, or
						; that an illegal address did not trap
btrap:		mfps	status			;
		tst	status			;
		beq	1$			;
		mov	#1125, -(R2)		; move to mailbox #1125
		inc	-(R2)			; set msgtyp to fatal error
		halt				; new PSW should have been zero
1$:		cmp	buff-4, #dtrap1		; check if trap PC is ok
		beq	ctrap			;
auto1:						;
		mov	#1126, -(R2)		; move to mailbox #1126
		inc	-(R2)			; set msgtyp to fatal error
		halt				; 0ld PC was not saved or wrong $testn
trapb:		mov	#6, 4			; reset trap catcher
		clr	6			; reset trap catcher
	; this routine will figure out if you have a DL11W
		clr	profte			;
		mov	#buff, SP		; set up the stack pointer
		mov	#dl11w, 4		; set up the trap vector
		tst	tps			; test the punch status register
		br	dl11w1			;
profte:		000000				;
dl11w:		inc	profte			; incr if no dl11w
dl11w1:		mov	#6, 4			;
skp104:						;
;_____________________________________________________________________________
;
; TEST 375 - test that a tty interrupt causes an overflow trap
;
ts375:		inc	(R2)			; update test number
		cmp	#375, (R2)		; sequence error?
		bne	tdec8			; br to error halt on seq error
		tst	profte			;
		bne	r7trx			;
		cmpb	#aptenv, $env		; runing in APT mode?
		bne	2$			; if not, do this test
		tst	$pass			; is this the first pass?
		bne	r7trx			; if not first pass, skip test
2$:						;
		reset				;
		mov	#340, status		; lock out interrupt
		mov	#400, SP		; set up stack to overflow
		mov	#tdec77, 4		; set up overflow trap
		mov	#tdec8, 64		; set up interrupt vector
		mov	#100, ttcsr		; set interrupt enable
		clr	status			; allow interrupt to occur
		mov	#1127, -(R2)		; move to mailbox #1127
		inc	-(R2)			; set msgtyp to fatal error
		halt				; no interrupt occurred
tdec8:						;
		mov	#1130, -(R2)		; move to mailbox #1130
		inc	-(R2)			; set msgtyp to fatal error
		halt				; overflow trap did not occur, or wrong $tstnm
tdec77:		clr	ttcsr			; clear interrupt enable
		mov	#6, 4			;
		clr	6			;
r7trx:						;
;_____________________________________________________________________________
;
; TEST 376 - test that a pending interrupt occurs before trap
;
ts376:		inc	(R2)			; update test number
		cmp	#376, (R2)		; sequence error?
		bne	br71			; br to error halt on seq error
		tst	profte			;
		bne	nodl			;
		cmpb	#aptenv, $env		; runing in APT mode?
		bne	2$			; if not, do this test
		tst	$pass			; is this the first pass?
		bne	nodl			; if not first pass. skip test
2$:						;
		mov	#buff, SP		;
		mov	#340, status		; set to a high priority level
		mov	#tR0, 64		;
		mov	#100, ttcsr		; interrupt for tty punch/printer
		mov	#br71, 34		; trap vector
		mov	#tR2, 64		; tty vector
		mov	#340, 36		; if trap traps, move 340 to priority
		clr	status			; should interrupt at end of clr inst
		trap				; tty interrupt should override trap
tR0:						;
		mov	#1131, -(R2)		; move to mailbox #1131
		inc	-(R2)			; set msgtyp to fatal error
		halt				; tty shouldn't have interrupted
br71:						;
		mov	#1132, -(R2)		; move to mailbox #1132
		inc	-(R2)			; set msgtyp to fatal error
		halt				; trap occurred first, or wrong $tstnm
tR2:		clr	36			;
		bic	#100, ttcsr		;
nodl:						;
;_____________________________________________________________________________
;
; TEST 377 - test that a pending interrupt, interrupts between traps
;
ts377:		inc	(R2)			; update test number
		cmp	#377, (R2)		; sequence error?
		bne	tR5			; br to error halt on seq error
		tst	profte			;
		bne	nodl1			;
		cmpb	#aptenv, $env		; runing in APT mode?
		bne	2$			; if not, do this test
		tst	$pass			; is this the first pass?
		bne	nodl1			; if not first pass. skip test
2$:						;
		mov	#buff, SP		;
		mov	#340, status		;
		mov	#100, ttcsr		;
		mov	#tR3, 34		; trap
		mov	#tR4, 64		; tty output
		mov	#340, 66		; tty output priority
		mov	#tR5, 20		; iot
		mov	#340, 22		; iot priority
		trap				; the act of trapping lower priority
tR3:		iot				; interrupt should occur in place of iot trap
tR5:						;
		mov	#1133, -(R2)		; move to mailbox #1133
		inc	-(R2)			; set msgtyp to fatal error
		halt				; no interrupt between traps, or wrong $tstnm
tR4:		clr	22			; clr iot priority
		clr	66			;
		mov	#36, 34			;
		mov	#66, 64			;
		mov	#22, 20			;
		clr	ttcsr			;
nodl1:						;
;_____________________________________________________________________________
;
; TEST 400 - test that "reset" goes to outside world
;
ts400:		inc	(R2)			; update test number
		cmp	#400, (R2)		; sequence error?
		bne	ts401-10		; br to error halt on seq error
		tst	profte			;
		bne	nodl2			;
		cmpb	#aptenv, $env		; running in APT mode?
		bne	1$			; if no do test.
		tst	$pass			; if yes then are we on first fass?
		bne	nodl2			; if in APT mode and first pass. skip test.
1$:		mov	tkb, R0			; make sure receiver done is set
		mov	#100, trcsr		; set interrupt enable
		reset				; should clear interrupt enable
		bit	#100, trcsr		; test for clear
		beq	ts401			;
		mov	#1134, -(R2)		; move to mailbox #1134
		inc	-(R2)			; set msgtyp to fatal error
		halt				; reset failed to clear trcsr
						; or sequence error
		mov	#1135, -(R2)		; move to mailbox #1135
		inc	-(R2)			; set msgtyp to fatal error
		halt				; wrong $tstnm
nodl2:						;
;_____________________________________________________________________________
;
; TEST 401 - test that reset has no effect on the trace trap
;
ts401:		inc	(R2)			; update test number
		cmp	#401, (R2)		; sequence error?
		bne	reset3			; br to error halt on seq error
		cmpb	#aptenv, $env		; running in APT mode?
		bne	2$			; if no do test.
		tst	$pass			; if yes then are we on first pass?
		bne	sktst2			; if in APT mode and first pass, skip test.
2$:		mov	#buff, SP		; set stack
		mov	#reset2, 14		; set up trace vector
		mov	#20, -(SP)		; set the T-bit on stack
		mov	#1$, -(SP)		; move new PC on stack
		rtt				;
1$:		reset				; should have no effect
		reset				; no effect
reset3:						;
		mov	#1136, -(R2)		; move to mailbox #1136
		inc	-(R2)			; set msgtyp to fatal error
		halt				; trace trap failed, or wrong $tstnm
reset2:		clr	status			; clear track
		clr	16			; trace status
		mov	#16, 14			;
sktst2:						;
;_____________________________________________________________________________
;
; TEST 402 - test that when tty interrupts it pops new status
;
ts402:		inc	(R2)			; update test number
		cmp	#402, (R2)		; sequence error?
		bne	tty11			; br to error halt on seq error
		tst	profte			;
		bne	nodl3			;
		cmpb	#aptenv, $env		; runing in APT mode?
		bne	2$			; if not. do this test
		tst	$pass			; is this the first pass?
		bne	nodl3			; if not first pass, skip test
2$:						;
		reset				;
		mov	#buff, SP		; set up stack
		mov	#tty3, 64		; interrupt vector
		clr	status			; drop processor priority
		mov	#357, 66		; high priority on interrupt
		bis	#300, ttcsr		; should set interrupt enable & interrupt
tty3:		cmp	status, #357		;
		beq	1$			;
		mov	#1137, -(R2)		; move to mailbox #1137
		inc	-(R2)			; set msgtyp to fatal error
		halt				; interrupt did not pop correct status
1$:		reset				; clr interrupt enable
		mov	#buff, SP		; stack set up
		mov	#tty4, 64		; interrupt vector
		clr	66			; clr new status
		mov	#157, status		; processor status
		comb	ttcsr			; set interrupt enable
tty4:		tst	status			;
		beq	ttt37			;
tty11:						;
		mov	#1140, -(R2)		; move to mailbox #1140
		inc	-(R2)			; set msgtyp to fatal error
		halt				; incorrect status, or wrong $tstnm
ttt37:		comb	ttcsr			;
nodl3:						;
;_____________________________________________________________________________
;
; TEST 403 - test the "wait" instruction
;
ts403:		inc	(R2)			; update test number
		cmp	#403, (R2)		; sequence error?
		bne	stp4			; br to error halt on seq error
		cmpb	#aptenv, $env		; runing in APT mode?
		bne	1$			; if not, do this test
		tst	$pass			; is this the first pass?
		bne	stp4e			; if not first pass, skip test
1$:						;
		bic	#100, tps		; clear interrupt enable
		mov	#buff, SP		; set up the stack
		mov	#wate, 64		; set up the interrupt vector
		clr	66			;
wate1:		tstb	tps			; wait for ready
		bpl	wate1			; to be up
		mov	#15, tpb		; do a carriage return
wate2:		tstb	tps			; wait for ready to come up
		bpl	wate2			;
		mov	#15, tpb		; do another carriage return
		bis	#100, tps		; set the interrupt enable
		clr	status			; clear the PSW
wate3:		wait				; wait for the interrupt
		mov	#1141, -(R2)		; move to mailbox #1141
		inc	-(R2)			; set msgtyp to fatal error
		halt				; wait instruction did not loop
wate:		tst	status			; is the PSW correct?
		beq	1$			;
		mov	#1142, -(R2)		; move to mailbox #1142
		inc	-(R2)			; set msgtyp to fatal error
		halt				; new PSW should have been zero
1$:		cmp	buff-4, #wate3+2	; is the old PC saved
		beq	stp4e			;
stp4:						;
		mov	#1143, -(R2)		; move to mailbox #1143
		inc	-(R2)			; set msgtyp to fatal error
		halt				; old PC was not saved or wrong $testn
stp4e:						;
;_____________________________________________________________________________
;
; TEST 404 - test that using register addr (177700) causes time out.
;
ts404:		inc	(R2)			; update test number
		cmp	#404, (R2)		; sequence error?
		bne	ts405-10		; br to error halt on seq error
						; register address (177700-177717)
						; cause time out when used
						; as program address by the CPU.
		mov	#buff, SP		; set stack pointer
		mov	#retr1, @#rtrap5	; set trap return addr
pcn1:		tst	@#177700		; bad addr reference, trap to 4
		mov	#1144, -(R2)		; move to mailbox #1144
		inc	-(R2)			; set msgtyp to fatal error
		halt				; referencing 177700 did not cause time out
retr1:		cmp	#pcn1+4, buff-4		; proper PC stored on stack?
		beq	ts405			;
		mov	#1145, -(R2)		; move to mailbox #1145
		inc	-(R2)			; set msgtyp to fatal error
		halt				; old PC was not saved in stack
						; or sequence error
;_____________________________________________________________________________
;
; Odd address used by a "word" instruction should not
; cause a trap, but the low order address bit would be ignored.
;
; TEST 405 - test odd address trap is not implemented.
;
ts405:		inc	(R2)			; update test number
		cmp	#405, (R2)		; sequence error?
		bne	ts406-10		; br to error halt on seq error
		mov	#retr2, @#rtrap5	; set trap return addr
		clr	@#0			; put all 0 in loc.0
		dec	@#1			; decrement odd address, should not trap
		cmp	#-1, @#0		; word loc.0 has all ones?
		beq	ts406			;
retr2:						;
		mov	#1146, -(R2)		; move to mailbox #1146
		inc	-(R2)			; set msgtyp to fatal error
		halt				; loc.0 did not store -1.or odd addr reference cause trap
						; or sequence error
;_____________________________________________________________________________
;
; Using address 177700 in mode 2, causes bus error, but
; the register in use will be incremented.
;
; TEST 406 - test that in mode 2, bad address reference causes bus error.
;
ts406:		inc	(R2)			; update test number
		cmp	#406, (R2)		; sequence error?
		bne	ts407-10		; br to error halt on seq error
		mov	#retr3, @#rtrap5	; set trap return addr
		mov	#177700, R0		; stores bad memory reference
		mov	#1234, (R0)+		; bad addr reference, trap to loc.4
		mov	#1147, -(R2)		; move to mailbox #1147
		inc	-(R2)			; set msgtyp to fatal error
		halt				; addressing 177700 did not cause trap
retr3:		cmp	#177702, R0		; was R0 incremented?
		beq	ts407			;
		mov	#1150, -(R2)		; move to mailbox #1150
		inc	-(R2)			; set msgtyp to fatal error
		halt				; R0 was not incremented
						; or sequence error
;_____________________________________________________________________________
;
; After the first bus error was encountered, an attempt was made
; to push PC and ps into the stack. However, if the stack pointer
; was bad, a bouble bus error occurred. The stack pointer would
; then be set to location 4, old PC and ps were pushed into
; locations 0 and 2. The processor would trap to 4 and continue
; execution.
;
; TEST 407 - test for double bus error.
;
ts407:		inc	(R2)			; update test number
		cmp	#407, (R2)		; sequence error?
		bne	ts410-10		; br to error halt on seq error
		mov	#dbe1, @#rtrap5		; set trap return addr
		mov	#340, @#6		; set up ps
		mov	#dbe2, @#rtrap		; set trap return addr
		mov	#340, @#12		; set up ps
		mov	#177700, SP		; set illegal SP
dbe:		trapa				; illegal instruction
		mov	#1151, -(R2)		; move to mailbox #1151
		inc	-(R2)			; set msgtyp to fatal error
		halt				; double bus error did not cause trap
dbe2:						;
		mov	#1152, -(R2)		; move to mailbox #1152
		inc	-(R2)			; set msgtyp to fatal error
		halt				; trap to wrong location
dbe1:		cmp	#dbe+2, @#0		; old PC got saved?
		beq	dbe3			;
		mov	#1153, -(R2)		; move to mailbox #1153
		inc	-(R2)			; set msgtyp to fatal error
		halt				; old PC did not get saved?
dbe3:		cmp	#340, @#2		; correct ps saved?
		beq	dbe4			;
		mov	#1154, -(R2)		; move to mailbox #1154
		inc	-(R2)			; set msgtyp to fatal error
		halt				; correct ps did not get save
dbe4:		cmp	#0, SP			; SP points to loc.0?
		beq	dbe5			;
		mov	#1155, -(R2)		; move to mailbox #1155
		inc	-(R2)			; set msgtyp to fatal error
		halt				; SP is not pointing to loc.0
dbe5:		mov	#to4, @#rtrap5		; reset timeout vector
		mov	#to10, @#rtrap		; reset illegal inst. vector
		mov	#stbot, SP		; reset SP
;_____________________________________________________________________________
;
; This tests the mfpt instruction - move from processor type
; upon execution. R0 will receive the processor model code
; which is "000003" for F11.
		mfpt	= 000007
;_____________________________________________________________________________
;
; TEST 410 - test mfpt
;
ts410:		inc	(R2)			; update test number
		cmp	#410, (R2)		; sequence error?
		bne	ts411-10		; br to error halt on seq error
		mov	#stbot, SP		; init. SP
		mov	@#10, -(SP)		; save trap vector
		mov	#1$, @#10		; set up illegal instruction trap
		mov	R0, -(SP)		; save R0
		mfpt				; get processor model
		mov	R0, @#cputyp		; store it
		mov	(SP)+, R0		; restore R0
		cmp	#3, @#cputyp		; check model type
		beq	xxt			;
1$:						;
		mov	#1156, -(R2)		; move to mailbox #1156
		inc	-(R2)			; set msgtyp to fatal error
		halt				; illegal instr trap or wrong model type
cputyp:		.word	0			;
xxt:						;
		mov	(SP)+, @#10		; restore trap vector
;_____________________________________________________________________________
;
; This test will check the service routine for a control chip error.
; This is done by executing instructions which jump to non-existent
; control-chip, the test therefore does a "fis" instruction. The
; ctlerr traps to location 10.
; the reset line is also asserted for 1 cycle.
;
; TEST 411 - test ctlerr service routine
;
ts411:		inc	(R2)			; update test number
		cmp	#411, (R2)		; sequence error?
		bne	ts412-10		; br to error halt on seq error
		mov	#stbot, SP		; init stack pointer
		mov	#1$, @#10		; set up return addr from trap
		mov	#340, @#12		; set trap priority=7
		fadd	SP			; execute fis instr.. should cause ctlerr
		mov	#1157, -(R2)		; move to mailbox #1157
		inc	-(R2)			; set msgtyp to fatal error
		halt				;
1$:		mov	#stbot, SP		; re-init stack pointer
;_____________________________________________________________________________
;
; TEST 412 - test that all reserved instructions trap
;
ts412:		inc	(R2)			; update test number
		cmp	#412, (R2)		; sequence error?
		bne	ret4			; br to error halt on seq error
		bic	#100, tps		;
		mov	#trap244, @#244		; set up to see if
		mov	@#10, tensave		; this processor has the
		mov	#trap10, @#10		; floating point option
		.word	170007			; an illegal fpp instruction
		br	around			; the following
trap244:					; if fpp in--
		mov	@#fpp, finish		; reset end of table pointer
		rti				; and return
trap10:						; leave the table alone
		rti				; and return
						; if no cis option trap to here
cistrp:		bic	#4, @swr		; clear cis option bit in swr
		mov	#concis, (SP)		; change return address to concis location
		rti				; return
cisadr:		.word	0			; data for cis instruction
		.word	0			;
tensave:	.word	0			; a place to store contents of 10
around:						; continuation point
.if ne noill					;
		mov	@#table+4, finish	;
.endc						;
		mov	#246, @#244		; restore the trap vector
		mov	#cistrp, @#10		; set up to see if
						; this processor has the cis option
		.word	076144			; execute a cmpci instruction
		.word	cisadr			; operands
		.word	cisadr			; for cis
		.word	0			; instruction
		bis	#4, @swr		; set cis present flag in swr
concis:						;
		mov	tensave, @#10		; restore the illegal inst. vector
		mov	#table, tab		; table pointer
gin1:		mov	(tab)+, first		; first or current instruction
		mov	(tab)+, last		; last instruction or group
		cmp	first, @#cis		; have we tested up to the cis instruction space
		bne	1$			; if no continue testing
		bit	#4, @swr		; if yes, check if cis chips present
		beq	1$			; if they are not continue testing
		mov	#fpp, tab		; if cis here skip cis instruction space
		br	gin1			;
1$:		cmp	first, finish		; tested all
		beq	gin3			; yes branch
		mov	first, inst		; set up inst
gin2:		inc	inst			;
		mov	#ret, 10		; set up return from trap
		mov	#buff, SP		; set up stack pointer
		clr	cc			; clear priority
		jmp	inst			; execute reserved instruction
gin3:		mov	#370, R0		; reset reserved area 370-402
		jmp	thrprt			; jump to EIS test
						; trapping should send you here
ret:		cmp	SP, #buff-4		; test decrement of SP
		beq	ret1			;
		mov	#1160, -(R2)		; move to mailbox #1160
		inc	-(R2)			; set msgtyp to fatal error
		halt				; wrong decrement
ret1:		cmp	buff-4, #inst+2		; loc.of inst unincremented
		beq	ret2			;
		mov	#1161, -(R2)		; move to mailbox #1161
		inc	-(R2)			; set msgtyp to fatal error
		halt				; inst. inc on trap ????
ret2:		tst	buff-2			;
		beq	ret3			;
ret4:						;
		mov	#1162, -(R2)		; move to mailbox #1162
		inc	-(R2)			; set msgtyp to fatal error
		halt				; condition codes set on trap, or wrong $tstnm
ret3:		cmp	inst, last		;
		beq	gin1			; set up new groud
		jmp	gin2			; finish old group
						; end of instruction group
table:		.word	7, 77			; end of operate
		.word	207, 227 		;
		.word	6777, 7777		;
		.word	75037, 76017		;
		.word	76032, 76037		;
		.word	76045, 76047		;
		.word	76077, 76127		;
		.word	76132, 76137		;
		.word	76145, 76147		;
		.word	76157, 76167		;
		.word	76177, 76777		;
						;
cis:		.word	76017, 76032		; start of cis instructions
		.word	76037, 76045		;
		.word	76047, 76077		;
		.word	76127, 76132		;
		.word	76137, 76145		;
		.word	76147, 76157		;
		.word	76167, 76177		;
						;
fpp:		.word	167777, 177700		; start of the fpp instructions
		.word	177716, 177777		;
finish:		.				; end flag
inst:		halt				; will continue reserved inst
		halt				; should trap to loc.10
		halt				; loc.10 should send you to
		halt				; ret
		halt				;

		.sbttl	"STARTING OF EIS TEST"
;
;		Part three: EIS instruction tests
;
;		Abstract
;		This program tests the F11 extended instruction set
;		ash, ashc, mul, and div, using registers 0-5 at-
;		least once with each instruction.
;
;		Switch settings
;		If no hardware switch register is available, the program
;		automatically uses the contents of loc.176 as the software
;		switch register. The user should set this location before
;		starting the program.
;
;		bit #		octal value		function
;		15		100000............ halt on error
;		13		020000............ inhibit error printout
;		an 8 bit byte $envm [i.e. location 321] has been used to define
;		the operating mode. All typeouts can be suppressed by making
;		bit 5 of byte $envm high, in other words by placing a 20000 in
;		location 320
;
		dummy	= 0			;
		errnm	= 1			;
		f	= 51			;
		n	= 176			;
		sw09	= 1000			;
		sw10	= 2000			;
		sw11	= 4000			;
		sw12	= 10000			;
count:						;
		. = count+2			;
psword:						;
		. = psword+2			;
temp1:						;
		. = temp1+2			;
temp2:						;
		. = temp2+2			;
temp3:						;
		. = temp3+2			;
temp4:						;
		. = temp4+2			;
temp5:		.word				;
temp6:		.word				;
typcnt:		.byte				;
$tpcnt:		.byte				;
s0:		7				;
s1:		-7				;
s2:		s1				;
s3:		-6				;
s4:		-1				;
s5:		40000				;
s6:		s5				;
s7:		40000				;
s8:		-2				;
s9:		2				;
s10:		s9				;
s11:		2				;
ttyout:		64				;
$tpb:		177566				;
$tps:		177564				;
		cr	= 15			;
		lf	= 12			;
		ht	= 11			;
		crlf	= 200			;
		$xoff	= 23			;
		$xon	= 21			;
$crlf:		.asciz	<15><12>/   /		; <cr><lf>
power:		.asciz	<12><15>/POWER/		;
thrprt:		mov	#$testn, R5		; make R5 point to the location $testn
		clr	@#count			; clear the counter
		mov	#1, (R5)		; initialize tfst number
		mov	#stbot, SP		; ** stack at stbot **
		mov	#1, @#temp1		; temp1=1
		clr	@#temp2			; temp2=0
		mov	#1, @#temp3		; temp3=1
		clr	@#temp4			; temp4=0
		mov	#$trap, @#34		; set up trap instruction vector
		mov	#340, @#36		; and vector plus two
		mtps	#0			; clear processor priority bits in PSW
;_____________________________________________________________________________
;
; ash instruction tests
;_____________________________________________________________________________
;
; TESTs 1-36
;
astart:		movpc	lpadr			; store error loop address
		mov	@#temp1, R0		; load R0 with the contents of temp1
		bit	#1, @#$pass		; is it an even pass?
		bne	2$			; if not then go to 2$
		mov	@#temp2, R1		; otherwise execute the instruction
						; in mode 0 using R1
		ash	R1, R0			;
		br	4$			;
2$:		ash	temp2, R0		; shift R0 by the number specified by temp2
4$:		mfps	@#psword		; save ps
		cmpb	@#temp4, @#psword	; is the ps = temp4?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 0
		1				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	@#count			; increment the counter
		cmp	@#temp3, R0		; is the result in R0 equal to temp3?
		beq	.+10			;
6$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; either incorrect R0 or incorrect sequence
		2				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), @#count		; is the test number equal to the
						; counter?
		bne	6$			; if not go to the hlt above
		inc	(R5)			;
		movpc	lpadr			; store error loop address
		cmp	(R5), #37		; has the contents of registers been shifted left
						; by 14. and right by 14.?
		bge	8$			;
		inc	@#temp2			;
		asl	temp3			; shift temp3 left
		cmp	(R5), #20		; has the contents of registers been shifted left by 14.?
		bne	regR1			;
		jmp	negat			; if so go to negat and initiate right shift
8$:		jsr	PC, tst37		; if so go and continue the rest of the program
regR1:		movpc	lpadr			; store error loop address
		mov	@#temp1, R1		; load R1 with the contents of temp1
		bit	#1, @#$pass		; is it an even pass?
		bne	2$			; if not then go to 2$
		mov	@#temp2, R2		; otherwise execute ash instruction in mode 0
		ash	R2, R1			; using R1
		br	4$			;
2$:		ash	temp2, R1		; shift R1 by the number specified by temp?
4$:		mfps	@#psword		; save ps
		cmpb	@#temp4, @#psword	; is the ps=temp4?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 0
		3				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	@#count			; increment the counter
		cmp	@#temp3, R1		; is the result in R1 equal to temp3?
		beq	.+10			;
6$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; either incorrect R1 or incorrect sequence
		4				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), @#count		; is the test number equal to the counter?
		bne	6$			; if not go to the hlt above
		inc	(R5)			;
		movpc	lpadr			; store error loop address
		cmp	(R5), #37		; has the contents of registers been shifted left
						; by 14. and right by 14.?
		bge	8$			;
		inc	@# temp2		;
		asl	temp3			; shift temp3 left
		cmp	(R5), #20		; has the contents of registers been shifted left by 14.?
		bne	regR2			;
		jmp	negat			; if so go to negat and initiate right shift
8$:		jsr	PC, tst37		; if so go and continue the rest of the program
regR2:		movpc	lpadr			; store error loop address
		mov	@#temp1, R2		; load R2 with the contents of temp1
		bit	#1, @#$pass		; is it an even pass?
		bne	2$			; if not then go to 2$
		mov	@#temp2, R3		; otherwise execute ash instruction in mode 0
		ash	R3, R2			; using R2
		br	4$			;
2$:		ash	temp2, R2		; shift R2 by the number specified by temp2
4$:		mfps	@#psword		; save ps
		cmpb	@#temp4, @#psword	; is the ps = temp4?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 0
		5				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	@#count			;
		cmp	@#temp3, R2		; is the result in R2 equal to temp3?
		beq	.+10			;
6$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; either incorrect R2 or incorrect sequence
		6				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), @#count		; is the test number fqual to the counter?
		bne	6$			; if not go to the hlt above
		inc	(R5)			;
		movpc	lpadr			; store error loop address
		cmp	(R5), #37		; has the contents of registers been shifted
						; left by 14, and right by 14.?
		bge	8$			;
		inc	@#temp2			;
		asl	temp3			; shifted temp3 left
		cmp	(R5), #20		; has the contents of registers been shifted left by 14.?
		bne	regR3			;
		jmp	negat			; if so go to negat and initiate right shift
8$:		jsr	PC, tst37		; if so go and continue the rest of the program
regR3:		movpc	lpadr			; store error loop address
		mov	@#temp1, R3		; load R3 with the contents of temp1
		bit	#1, @#$pass		; is it an even pass?
		bne	2$			; if not then go to 2$
		mov	@#temp2, R4		; otherwise execute ash instruction in mode 0
		ash	R4, R3			; using R3
		br	4$			;
2$:		ash	temp2, R3		; shift R3 by the number specified by temp2
4$:		mfps	@#psword		; save ps
		cmpb	@#temp4, @#psword	; is the ps = temp4?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 0.
		7				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	@#count			;
		cmp	@#temp3, R3		; is the result in R3 equal to temp3?
		beq	.+10			;
6$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; either incorrect R3 or incorrect sequence
		10				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), @#count		; is the test number equal to the counter?
		bne	6$			; if not go to the hlt above
		inc	(R5)			;
		movpc	lpadr			; store error loop address
		cmp	(R5), #37		; has the contents of registers been shifted
						; left by 14, and right by 14.?
		bge	8$			;
		inc	@#temp2			;
		asl	temp3			; shift temp3 left?
		cmp	(R5), #20		; has the contents of registers been shifted left by 14.
		bne	regR4			;
		br	negat			; if so go to negat and initiate right shift
8$:		jsr	PC, tst37		; if so go and continue the rest of the program
regR4:		movpc	lpadr			; store error loop address
		mov	@#temp1, R4		; load R4 with the contents of temp1
		mov	R5, R1			; save R5
		bit	#1, @#$pass		; is it an even pass?
		bne	2$			; if not then go to 2$
		mov	@#temp2, R5		; otherwise execute ash instruction in mode 0
		ash	R5, R4			; using R4
		br	4$			;
2$:		ash	temp2, R4		; shift R4 by the number specified by temp2
4$:		mfps	@#psword		; save ps
		cmpb	@#temp4, @#psword	; is ps = temp4?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 0
		11				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	@#count			;
		cmp	@#temp3, R4		; is the result in R4 equal to temp3?
		beq	.+10			;
6$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; either incorrect R4 or incorrect sequence
		12				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		mov	R1, R5			; restore R5
		cmp	(R5), @#count		; is the test number equal to the counter?
		bne	6$			; if not go to the hlt above
		inc	(R5)			;
		movpc	lpadr			; store error loop address
		cmp	(R5), #37		; has the contents of registers been
						; shifted left by 14. and right by 14;
		bge	8$			;
		inc	@#temp2			;
		asl	temp3			; shift temp3 left
		cmp	(R5), #20		; has the contents of register been shifted by 14.
		bne	regR5			;
		br	negat			; if so go to negat and initiate right shift
8$:		jsr	PC, tst37		; if so go and continue the rest of the program
regR5:		movpc	lpadr			; store error loop address
		mov	R5, R1			; save R5
		mov	@#temp1, R5		; load R5 with the contents of temp1
		bit	#1, @#$pass		; is it an even pass?
		bne	2$			; if not then go to 2$
		mov	@#temp2, R0		; otherwise execute ash instruction in mode 0
		ash	R0, R5			; using R5
		br	4$			;
2$:		ash	temp2, R5		; shift R5 by the number specified by temp2
4$:		mfps	@#psword		; save ps
		cmpb	@#temp4, @#psword	; is ps=temp4?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 0.
		13				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	@#count			;
		cmp	@#temp3, R5		; is the result in R5 equal to temp3?
		beq	.+10			;
6$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; either incorrect R5 or incorrect sequence
		14				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R1), @#count		; is the test number equal to the counter?
		bne	6$			; if not go to the hlt above
		mov	R1, R5			; restore R5
		inc	(R5)			;
		movpc	lpadr			; store error loop address
		cmp	(R5), #37		; has the contents of registers been shifted
						; left by 14. and right by 14.?
		bge	8$			; if so go and continue the rest of the program
		inc	@#temp2			;
		asl	temp3			; shift temp3 left
		cmp	(R5), #20		; has the contents of registers been shifted left by 14.?
		beq	negat			; if so go to negat and initiate right shift
		br	10$			;
8$:		jsr	PC, tst37		;
10$:		jmp	astart			; go back to start
negat:		mov	#40000, @#temp1		; temp1=40000
		mov	#177762, @#temp2	; temp2=177762
		mov	#1, @#temp3		; temp3=1
		jmp	astart			;
tst37:		cmp	(R5), #37		; is it test 37?
		bne	tst40			; if not then try test 40
		clr	@#temp1			; 0
		mov	#16., @#temp2		; shifted by 16
		clr	@#temp3			; is=0
		mov	#4, @#temp4		; and ps=4
		rts	PC			;
tst40:		cmp	(R5), #40		; is it test 40?
		bne	tst41			; if not then try test 41
		clr	@#temp2			; 0 shifted by 0=0 and ps=4
		rts	PC			;
tst41:		cmp	(R5), #41		; is it test 41?
		bne	tst42			; if not then try test 42
		mov	#-16., @#temp2		; 0 shifted by -16.=0 and ps=4
		rts	PC			;
tst42:		cmp	(R5), #42		; is it test 42?
		bne	tst43			; if not then try test 43
		mov	#100000, @#temp1	; 100000
		inc	@#temp2			; shifted by -15
		dec	@#temp3			; is=-1
		mov	#10, @#temp4		; and ps=10
		rts	PC			;
tst43:		cmp	(R5), #43		; is it test 43?
		bne	tst44			; if not then if not then try test 44
		mov	#125252, @#temp1	; 125252
		mov	#-1, @#temp2		; shifted by -1
		mov	#152525, @#temp3	; is=152525 and ps=10
		rts	PC			;
tst44:		cmp	(R5), #44		; is it test 44?
		bne	tst45			; if not then try test 45
		mov	#1, @#temp2		; 125252 shifted by 1
		mov	#52524, @#temp3		; is=52524
		mov	#3, @#temp4		; and ps=3
		rts	PC			;
tst45:		cmp	(R5), #45		; is it test 45?
		bne	tst46			; if not then try test 46
		mov	#-2, @#temp2		; 125252 shifted by -2
		mov	#165252, @#temp3	; is=165252
		mov	#11, @#temp4		; and ps=11
		rts	PC			;
tst46:		cmp	(R5), #46		; is it test 46?
		bne	tst47			; if not then try test 47
		mov	#-1, @#temp1		; -1
		mov	#16., @#temp2		; shifted by 15.
		clr	@#temp3			; is=0
		mov	#7, @#temp4		; and ps=7
		rts	PC			;
tst47:		cmp	(R5), #47		; is it test 47?
		bne	tst50			; if not then try test 50
		dec	@#temp2			; -1 shifted by 15
		mov	#100000, @#temp3	; is=100000
		mov	#11, @#temp4		; and ps=11
		rts	PC			;
tst50:		cmp	(R5), #50		; is it test 50
		bne	ent51			; if not then try test 51
		mov	#137777, @#temp1	; 137777 shifted by 15. is=100000
		mov	#13, @#temp4		; and ps=13
		rts	PC			;
ent51:		cmp	(R5), #51		; is it entering test 51?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test number goofed
		15				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		tst	(SP)+			; restore stack pointer
		mov	#-7, R4			;
		mov	#s1, R2			;
		mov	#s2, R3			;
;_____________________________________________________________________________
;
; TEST 51 - ash 125252 shifted by #5 = 52500 ps = 3
;
tst51:		movpc	lpadr			; store error loop address
		mov	#125252, R1		; load R1 with 125252
		ash	#5, R1			; shift R1 by #5
		mfps	@#psword		; save ps
		cmpb	#3, @#psword		; is the ps 3?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 3
		16				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#52500, R1		; is the result 52500?
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R1 is not equal to 52s00 or incorrect sequence
		17				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #51		; is $testn = #51
		bne	1$			; if not then go to hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 52 - ash 125252 shifted by @s2 = 177525 ps = 10
;
tst52:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load R0 with 125252
		ash	@s2, R0			; shift R0 by @s2
		mfps	@#psword		; save ps
		cmpb	#10, @#psword		; is the ps=10?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 10
		20				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#177525, R0		; is the result 177525?
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0 is not equal to 177525 or incorrect sequence
		21				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #52		; is $testn = #52
		bne	1$			; if not then go to hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 53 - ash 125252 shifted by @#s1 = 177525 ps = 10
;
tst53:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load R0 with 125252
		ash	@#s1, R0		; shift R0 by by s1
		mfps	@#psword		; save ps
		cmpb	#10, @#psword		; is the ps=10?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 10
		22				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#177525, R0		; is the result 177525?
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0 is not equal to 177525 or incorrect sequence
		23				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #53		; is $testn = #53
		bne	1$			; if not then go to hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 54 - ash 125252 shifted by (2) = 177525 ps = 10
;
tst54:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load R0 with 125252
		ash	(2), R0			; shift R0 by (2)
		mfps	@#psword		; save ps
		cmpb	#10, @#psword		; is the ps=10?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 10
		24				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#177525, R0		; is the result 177525?
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0 is not equal to 177525 or incorrect sequence
		25				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #54		; js $testn = #54
		bne	1$			; if not then go to hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 55 - ash 125252 shifted by (2)+ = 177525 ps = 10
;
tst55:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load R0 with 125252
		ash	(2)+, R0		; shift R0 by (2)+
		mfps	@#psword		; save ps
		cmpb	#10, @#psword		; is the ps=10?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 10
		26				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#177525, R0		; is the result 177525?
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0 is not equal to 177525 or incorrect sequence
		27				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #55		; is $testn = #55
		bne	1$			; if not then go to hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 56 - ash 125252 shifted by -(2) = 177525 ps = 10
;
tst56:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load R0 with 125252
		ash	-(2), R0		; shift R0 by -(2)
		mfps	@#psword		; save ps
		cmpb	#10, @#psword		; is the ps=10?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 10
		30				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#177525, R0		; is the result 177525?
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0 is not equak to 177525 or incorrect sequence
		31				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #56		; is $testn = #56
		bne	1$			; if not then go to hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 57 - ash 125252 shifted by 2(3) = 177252 ps = 11
;
tst57:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load R0 with 125252
		ash	2(3), R0		; shift R0 by 2(3)
		mfps	@#psword		; save ps
		cmpb	#11, @#psword		; is the ps=11?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 11
		32				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#177252, R0		; is the result 177252?
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0 is not equal to 177252 or incorrect sequence
		33				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #57		; is $tfstn = #57
		bne	1$			; if not then go to hlt above
		inc	(R5)			;
;_______________________________________________;_____________________________
;
; TEST 60 - ash 125252 shifted by @(3) = 177525 ps = 10
;
tst60:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load R0 with 125252
		ash	@(3), R0		; shift R0 by @(3)
		mfps	@#psword		; save ps
		cmpb	#10, @#psword		; is the ps=10?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 10
		34				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#177525, R0		; is the result 177525?
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0 is not equal to 177525 or incorrect sequence
		35				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #60		; is $testn = #60
		bne	1$			; if not then go to hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 61 - ash 125252 shifted by @(3)+ = 177525 ps = 10
;
tst61:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load R0 with 125252
		ash	@(3)+, R0		; shift R0 by @(3)+
		mfps	@#psword		; save ps
		cmpb	#10, @#psword		; is the ps=10?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 10
		36				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#177525, R0		; is the result 177525?
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0 is not equal to 177525 or incorrect sequence
		37				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #61		; is $testn = #61
		bne	1$			; if not then go to hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 62 - ash	125252 shifted by @-(3) = 177525 ps = 10
;
tst62:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load R0 with 125252
		ash	@-(3), R0		; shift R0 by @-(3)
		mfps	@#psword		; save ps
		cmpb	#10, @#psword		; is the ps=10?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 10
		40				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#177525, R0		; is the result 177525?
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0 is not equal to 177525 or incorrect sequence
		41				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #62		; is $testn = #62
		bne	1$			; if not then go to hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; ashc instruction tests
;_____________________________________________________________________________
;
; TESTs 63-157
;
		movpc	lpadr			; store error loop address
		mov	#62, @#count		;
		clr	@#temp1			; temp1=0
		mov	#1, @#temp2		; temp2=1
		clr	@#temp3			; temp3=0
		clr	@#temp4			; temp4=0
		mov	#1, @#temp5		; temp5=1
		clr	@#temp6			; 0 1 shifted by 0=0 1, ps=0
reg01:		mov	R5, R2			; save R5
		mov	@#temp1, R0		; place the contents of temp1 in register 0
		mov	@#temp2, R0!1		; place the contents of temp2 in register 1
		clc				;
		bit	#1, @#$pass		; is it an even pass?
		bne	2$			; if not then go to 2$
		mov	@#temp3, R5		; otherwise execute ashc instruction in mode 0
		ashc	R5, R0			; using R0
		br	4$			;
2$:		ashc	temp3, R0		; ashc register 0 by the contents of temp3
4$:		mfps	@#psword		; save ps
		cmpb	@#temp6, @#psword	; compare ps with the contents of temp6
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong ps
		42				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	@#count			;
		cmp	@#temp4, R0		; is the result in R0 same as temp4?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong result in R0
		43				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	@#temp5, R1		; is the result in R1 same as temp5?
		beq	.+10			; temp1 temp2 shifted by temp3=temp4 temp5
						; and ps=temp6
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong result in R1
		44				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		mov	R2, R5			; restore R5
		cmp	(R5), @#count		; is test number=counter?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; no
		45				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
		cmp	(R5), #160		; have the first 159 test been executed?
		bge	6$			; yes
		inc	@#temp3			;
		clc				;
		rol	@#temp5			; rotate temp5 left by 1 place
		rol	@#temp4			; introduce carry from temp 4 in temp5
		cmp	(R5), #121		; is it test 121?
		bne	regR23			;
		jsr	R4, ritsh		; if so then go and initiate right shift
6$:		jsr	PC, tst160		;
regR23:		movpc	lpadr			; store error loop address
		mov	@#temp1, R2		; place the contents of temp1 in register 2
		mov	@#temp2, R3		; place the contents of temp2 in register 3
		clc				;
		bit	#1, @#$pass		; is it an even pass?
		bne	2$			; if not then go to 2$
		mov	@#temp3, R4		; otherwise execute ashc instruction in mode 0
		ashc	R4, R2			; using R2
		br	4$			;
2$:		ashc	temp3, R2		; ashc register 2 by the contents of temp3
4$:		mfps	@#psword		; save ps
		cmpb	@#temp6, @#psword	; compare ps with the contents of temp6
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong ps
		46				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	@#count			;
		cmp	@#temp4, R2		; is the result in R2 same as temp4?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong result in R2
		47				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	@#temp5, R3		; is the result in R3 same as temp5?
		beq	.+10			; temp1 temp2 shifted by temp3 temp4 temp5
						; and ps=temp6
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong result in R1
		50				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), @#count		; is test number=counter?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, to to the halt routine
						; no
		51				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
		cmp	(R5), #160		; have the first 159 test been executed?
		bge	6$			; yes
		inc	@#temp3			;
		clc				;
		rol	@#temp5			; rotate temp5 left by 1 place
		rol	@#temp4			; introduce carry from temp5 in temp4
		cmp	(R5), #121		; is it test 121?
		bne	reg45			;
		jsr	R4, ritsh		; if so then go and initiate right shift
6$:		jsr	PC, tst160		;
reg45:		movpc	lpadr			; store error loop address
		mov	R5, R1			; save R5
		mov	@#temp1, R4		; place the contents of temp1 in register 4
		mov	@#temp2, R5		; place the contents of temp2 in register 5
		clc				;
		bit	#1, @#$pass		; is it an even pass?
		bne	2$			; if not then go to 2$
		mov	@#temp3, R0		; otherwise execute ashc instruction in mode 0
		ashc	R0, R4			; using R4
		br	4$			;
2$:		ashc	temp3, R4		; ashc register 4 by the contents of temp3
4$:		mfps	@#psword		; save ps
		cmpb	@#temp6, @#psword	; compare ps with the contents of temp6
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong ps
		52				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	@#count			;
		cmp	@#temp4, R4		; is the result in R4 same as temp4?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong result in R4
		53				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	@#temp5, R5		; is the result in R5 same as temp5?
		beq	.+10			; temp1 temp2 shifted by temp3 temp4 temp5
						; and ps=temp6
		jsr	PC, $hlt		; seen an ehror, go to the halt routine
						; wrong result in R5
		54				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R1), @#count		; is test number=counter?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; no
		55				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		mov	R1, R5			; restore R5
		inc	(R5)			;
		cmp	(R5), #160		; have the first 159 test been executed?
		bge	6$			; yes
		inc	@#temp3			;
		clc				;
		rol	@#temp5			; rotate temp5 left by 1 place
		rol	@#temp4			; introduce carry from temp5 in temp4
		cmp	(R5), #121		; is it test 121?
		bne	8$			;
		jsr	R4, ritsh		; if so then go and initiate right shift
6$:		jsr	PC, tst160		;
8$:		jmp	reg01			;
ritsh:		cmp	(R4)+, (R4)+		; make R4 point to the next reg tag
		mov	#40000, @#temp1		; temp1=4000
		clr	@#temp2			; temp2=0
		mov	#-30., @#temp3		; temp3=-30
		clr	@#temp4			; temp4=0
		inc	@#temp5			; temp5=1
		rts	R4			;
tst160:		cmp	(R5), #160		; is it test 160
		bne	tst161			; if not then try test 161
		clr	@#temp1			; 0 0 shifted by 0
		clr	@#temp4			; is equal to 0 0
		mov	#4, @#temp6		; and ps=4
		rts	PC			;
tst161:		cmp	(R5), #161		; is it test 161
		bne	tst162			;
		mov	#-32, @#temp3		; 0 0 shifted by -32=0 0, ps=4
		rts	PC			;
tst162:		cmp	(R5), #162		; is it test 162
		bne	tst163			; if not then try test 163
		mov	#32, @#temp3		; 0 0 shifted by 32=0 0. ps=4
		rts	PC			;
tst163:		cmp	(R5), #163		; is it test 163?
		bne	tst164			; if not then try test 164
		mov	#52525, @#temp1		; 52525 0
		mov	#-16., @#temp3		; shifted by -16.
		clr	@#temp4			;
		mov	#52525, @#temp5		; is equal to 0 52525
		clr	@#temp6			; and ps = 0
		rts	PC			;
tst164:		cmp	(R5), #164		; is it test 164?
		bne	tst165			; if not then try test 165
		mov	#125252, @#temp1	; 125252 0 shifted by -16.
		dec	@#temp4			;
		mov	#125252, @#temp5	; is equal to -1 125252
		mov	#10, @#temp6		; and ps=10
		rts	PC			;
tst165:		cmp	(R5), #165		; is it test 165?
		bne	tst166			; if not then try test 166
		mov	#-1, @#temp1		; 1 0 shifted by -16
		mov	#-1, @#temp5		; is equal to -1 -1. and ps=10
		rts	PC			;
tst166:		cmp	(R5), #166		; is it test 166?
		bne	tst167			; if not then try test 167
		mov	#100000, @#temp1	; 100000 0
		mov	#-32., @#temp3		; shifted by -32 is equal to -1 -1
		inc	@#temp6			; and ps=11
		rts	PC			;
tst167:		cmp	(R5), #167		; is it test 167?
		bne	tst170			; if not then try test 170
		clr	@#temp1			;
		dec	@#temp2			; 0 -1
		mov	#16., @#temp3		; shifted by 16.
		clr	@#temp5			; is equal to -1 0
		inc	@#temp6			; and ps=12
		rts	PC			;
tst170:		cmp	(R5), #170		; is it test 170?
		bne	tst171			; if not then try test 171
		mov	#125252, @#temp2	; 0 125252 shifted by 16
		mov	#125252, @#temp4	; is equal to 125252 0, and ps=12
		rts	PC			;
tst171:		cmp	(R5), #171		; is it test 171?
		bne	tst172			; if not then try test 172
		dec	@#temp3			; o 125252 shifted by 15
		mov	#52525, @#temp4		; is equal to 52525 0
		clr	@#temp6			; and ps-0
		rts	PC			;
tst172:		cmp	(R5), #172		; is it test 172?
		bne	tst173			; if not then try test 173
		mov	#52525, @#temp2		; 0 52525
		inc	@#temp3			; shifted by 16. is equal to 52525 0, and ps=0
		rts	PC			;
tst173:		cmp	(R5), #173		; is it test 173?
		bne	tst174			; if not then try test 174
		mov	#-1, @#temp2		; 0 -1
		dec	@#temp3			; shifted by 15.
		mov	#77777, @#temp4		;
		mov	#100000, @#temp5	; is equal to 77777 100000. and ps=0
		rts	PC			;
tst174:		cmp	(R5), #174		; is it test 174?
		bne	tst175			; if not then try test 175
		mov	#100000, @#temp1	;
		dec	@#temp2			; 100000 -2 shifted by 15.
		clr	@#temp5			; is equal to 77777 0
		mov	#2, @#temp6		; and ps=2
		rts	PC			;
tst175:		cmp	(R5), #175		; is it test 175?
		bne	ent176			; if not then try test 176
		mov	#-1, @#temp1		;
		clr	@#temp2			; -1 0
		inc	@#temp3			; shifted by 16.
		clr	@#temp4			; is equal to 0 0
		mov	#7, @#temp6		; and ps=7
		rts	PC			;
ent176:		cmp	(R5), #176		; is the program entering test 176?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test number goofed
		56				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		tst	(SP)+			; restore stack pointer
;_____________________________________________________________________________
;
; TEST 176 -	1 shifted by 8. = 400 ps = 0
;
tst176:		movpc	lpadr			; store error loop address
		mov	#dummy, R1		; load R1 with dummy
		mov	#1, R1			; load R1!1 with 1
		clc				;
		ashc	#8., R1			; shift R1, R1! by 8.
		mfps	@#psword		; save ps
		cmpb	#0, @#psword		; is the ps 0?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 0
		57				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#400, R1		; is the result 400?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R1 is not equal to 400
		60				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #176		; is $testn = #176?
		beq	.+10			; if not then go to hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		61				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 177 -	-1 shifted by 15. = 100000 ps = 11
;
tst177:		movpc	lpadr			; store error loop address
		mov	#dummy, R3		; load R3 with dummy
		mov	#-1, R3			; load R3!1 with -1
		clc				;
		ashc	#15., R3		; shift R3, R3!1 by 15.
		mfps	@#psword		; save ps
		cmpb	#11, @#psword		; is the ps=11?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 11
		62				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#100000, R3		; is the result 100000?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R3 is not equal to 100000
		63				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #177		; is $testn = #177?
		beq	.+10			; if not then go to hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		64				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 200 -	52525 shifted by 0 = 52525 ps = 0
;
tst200:		movpc	lpadr			; store error loop address
		mov	R5, R1			; save R5
		mov	#dummy, R5		; load R5 with dummy
		mov	#52525, R5		; load R5!1 with 52525
		clc				;
		ashc	#0, R5			; shift R5, R5!1 by 0
		mfps	@#psword		; save ps
		cmpb	#0, @#psword		; is the ps 0?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 0
		65				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#52525, R5		; is the result 52525?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R5 is not equal to 52525
		66				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		mov	R1, R5			; restore R5
		cmp	(R5), #200		; is $testn = #200?
		beq	.+10			; if not then go to hlt
		jsr	PC, $hlt		; seen an error, 60 to the halt routine
						; test is in wrong sequence
		67				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 00020?)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 201 -	20010 shifted by -13. = 101 ps = 0
;
tst201:		movpc	lpadr			; store error loop address
		mov	#dummy, R1		; load R1 with dummy
		mov	#20010, R1		; load R1!1 with 20010
		clc				;
		ashc	#-13., R1		; shift R1, R1!1 by -13.
		mfps	@#psword		; save ps
		cmpb	#0, @#psword		; is the ps 0?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 0
		70				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#101, R1		; is the result 101?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R1 is not equal to 101
		71				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #201		; is $testn = #201?
		beq	.+10			; if not then go to hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		72				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 202 -	-1 shifted by 16. = 0 ps = 11
;
tst202:		movpc	lpadr			; store error loop address
		mov	#dummy, R3		; load R3 with dummy
		mov	#-1, R3			; load R3!1 with -1
		clc				;
		ashc	#16., R3		; shift R3, R3!1 by 16.
		mfps	@#psword		; save ps
		cmpb	#11, @#psword		; is the ps=11?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 11
		73				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#0, R3			; is the result 0?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R3 is not equal to 0
		74				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #202		; is $testn = #202?
		beq	.+10			; if not then go to hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		75				; to scope, replace last; beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 203 -	1 shifted by -1 = 100000 ps = 1
;
tst203:		movpc	lpadr			; store error loop address
		mov	R5, R1			; save R5
		mov	#dummy, R5		; load R5 with dummy
		mov	#1, R5			; load R5!1 with 1
		clc				;
		ashc	#-1, R5			; shift R5, R5!1 by -1
		mfps	@#psword		; save ps
		cmpb	#1, @#psword		; is the ps=1?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 1
		76				; to scope, replace i ast: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#100000, R5		; is the result 100000?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R5 is not equal to 100000
		77				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		mov	R1, R5			; restore R5
		cmp	(R5), #203		; is $testn = #203?
		beq	.+10			; if not then go to hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		100				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 204 -	125252 shifted by -16. = 125252 ps = 11
;
tst204:		movpc	lpadr			; store error loop address
		mov	#dummy, R1		; load R1 with dummy
		mov	#125252, R1		; load R1!1 with 125252
		clc
		ashc	#-16., R1		; shift R1, R1!1 by -16.
		mfps	@#psword		; save ps
		cmpb	#11, @#psword		; is the ps=11?
		beq	.+10
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 11
		101				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#125252, R1		; is the result 125252?
		beq	.+10
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R1 is not equal to 125252
		102				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #204		; is $testn = #204?
		beq	.+10			; if not then go to hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		103				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)
;_____________________________________________________________________________
;
; TEST 205 -	125252 125252 shifted by 21. = 52500 000000 ps = 3
;
tst205:		movpc	lpadr			; store error loop address
		mov	#125252, R2		; load R2 with 125252
		mov	#125252, R3		; load R2!1 with 125252
		clc				;
		ashc	#21., R2		; shift R2, R2!1 by 21.
		mfps	@#psword		; save ps
		cmpb	#3, @#psword		; is the ps=3?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 3
		104				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#52500, R2		; is the result 52500?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R2 is not equal to 52500
		105				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#000000, R3		; is the result 000000?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R2!1 is not equal to 000000
		106				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #205		; is $testn = #205?
		beq	.+10			; if not then go to hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		107				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
		mov	#-7, R2			;
		mov	#s1, R3			;
		mov	#s2, R4			;
;_____________________________________________________________________________
;
; TEST 206 -	125252 125252 shifted by s1 = 177525 52525 ps = 10
;
tst206:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load R0 with 125252
		mov	#125252, R0!1		; load R0!1 with 125252
		clc				;
		ashc	s1, R0			; shift R0, R0!1 by s1
		mfps	@#psword		; save ps
		cmpb	#10, @#psword		; is the ps=10?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 10
		110				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#177525, R0		; is the result 177525?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0 is not equal to 177525
		111				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#52525, R0!1		; is the result 52525?
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0!1 is not equal to 52525 or incorrect sequence
		112				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #206		; is the $testn = #206?
		bne	1$			; if not then go to halt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 207 -	125252 125252 shifted by @s2 = 177525 52525 ps = 10
;
tst207:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load R0 with 125252
		mov	#125252, R0!1		; load R0!1 with 125252
		clc				;
		ashc	@s2, R0			; shift R0, R0!1 by @s2
		mfps	@#psword		; save ps
		cmpb	#10, @#psword		; is the ps=10?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 10
		113				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#177525, R0		; is the result 177525?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0 is not equal to 177525
		114				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#52525, R0!1		; is the result 52525?
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0!1 is not equal to 52525 or incorrect sequence
		115				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #207		; is the $testn = #207?
		bne	1$			; if not then go to hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 210 -	125252 125252 shifted by @#s1 = 177525 52525 ps = 10
;
tst210:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load R0 with 12525?
		mov	#125252, R0!1		; load R0!1 with 125252
		clc				;
		ashc	@#s1, R0		; shift R0, R0!1 by @#s1
		mfps	@#psword		; save ps
		cmpb	#10, @#psword		; is the ps=10?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 10
		116				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#177525, R0		; is the result 177525?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0 is not equal to 177525
		117				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#52525, R0!1		; is the result 52525?
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0!1 is not equal to 52525 or incorrect sequence
		120				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #210		; is the $testn = #210?
		bne	1$			; if not then go to hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 211 -	125252 125252 shifted by (3) = 177525 52525 ps = 10
;
tst211:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load R0 with 125252
		mov	#125252, R0!1		; load R0!1 with 125252
		clc				;
		ashc	(3), R0			; shift R0, R0!1 by (3)
		mfps	@#psword		; save ps
		cmpb	#10, @#psword		; is the ps=10?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 10
		121				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#177525, R0		; is the result 177525?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0 is not equal to 177525
		122				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#52525, R0!1		; is the result 52525?
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0!1 is not equal to 52525 or incorrect sequence
		123				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #211		; is the $testn = #211?
		bne	1$			; if not then go to hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 212 -	125252 125252 shifted by (3)+ = 177525 5252s ps = 10
;
tst212:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load R0 with 125252
		mov	#125252, R0!1		; load R0!1 with 125252
		clc				;
		ashc	(3)+, R0		; shift R0, R0!1 by (3)+
		mfps	@#psword		; save ps
		cmpb	#10, @#psword		; is the ps=10?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 10
		124				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#177525, R0		; is the result 177525?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0 is not equal to 177525
		125				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#52525, R0!1		; is the result 52525?
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0!1 is not equal to 52525 or incorrect sequence
		126				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #212		; is the $testn = #212?
		bne	1$			; if not then go to hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 213 -	125252 125252	shifted by -(3) = 177525 52525 ps = 10
;
tst213:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load R0 with 125252
		mov	#125252, R0!1		; load R0!1 with 125252
		clc				;
		ashc	-(3), R0		; shift R0, R0!1 by -(3)
		mfps	@#psword		; save ps
		cmpb	#10, @#psword		; is the ps=10?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 10
		127				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#177525, R0		; is the result 177525?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0 is not equal to 177525
		130				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#52525, R0!1		; is the result 52525?
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0!1 is not equal to 52525 or incorrect sequence
		131				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #213		; is the $testn = #213?
		bne	1$			; if not then go to hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 214 -	125252	125252 shifted by 2(4) = 177252 125252 ps = 11
;
tst214:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load R0 with 125252
		mov	#125252, R0!1		; load R0!1 with 125252
		clc				;
		ashc	2(4), R0		; shift R0, R0!1 by 2(4)
		mfps	@#psword		; save ps
		cmpb	#11, @#psword		; is the ps=11?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 11
		132				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#177252, R0		; is the result 177252?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0 is not equal to 177252
		133				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#125252, R0!1		; is the result 125252?
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0!1 is not equal to 125252 or incorrect sequence
		134				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #214		; is the $testn = #214?
		bne	1$			; if not then go to hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 215 -	125252 125252 shifted by @(4) = 177525 52525 ps = 10
;
tst215:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load R0 with 125252
		mov	#125252, R0!1		; load R0!1 with 125252
		clc				;
		ashc	@(4), R0		; shift R0, R0!1 by @(4)
		mfps	@#psword		; save ps
		cmpb	#10, @#psword		; is the ps=10?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 10
		135				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#177525, R0		; is the result 177525?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0 is not equal to 177525
		136				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#52525, R0!1		; is the result 52525?
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0!1 is not equal to 52525 or incorrect sequence
		137				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #215		; is the $testn = #215?
		bne	1$			; if not then go to hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 216 -	125252 125252 shifted by @(4)+ = 177525 52525 ps = 10
;
tst216:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load R0 with 125252
		mov	#125252, R0!1		; load R0!1 with 125252
		clc				;
		ashc	@(4)+, R0		; shift R0, R0!1 by @(4)+
		mfps	@#psword		; save ps
		cmpb	#10, @#psword		; is the ps=10?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 10
		140				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#177525, R0		; is the result 177525?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0 is not equal to 177525
		141				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#52525, R0!1		; is the result 52525?
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0!1 is not equal to 52s25 or incorrect sequence
		142				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #216		; is the $testn = #216?
		bne	1$			; if not then go to hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 217 -	125252 125252 shifted by @-(4) = 177525 52525 ps = 10
;
tst217:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load R0 with 125252
		mov	#125252, R0!1		; load R0!1 with 125252
		clc				;
		ashc	@-(4), R0		; shift R0, R0!1 by @-(4)
		mfps	@#psword		; save ps
		cmpb	#10, @#psword		; is the ps=10?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; the ps is not equal to 10
		143				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#177525, R0		; is the result 177525?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0 is not equal to 177525
		144				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#52525, R0!1		; is the result 52525?
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; R0!1 is not equal to 52525 or incorrect sequence
		145				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #217		; is the $testn = #217?
		bne	1$			; if not then go to hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; mul instruction tests
;_____________________________________________________________________________
;
; TEST 220 - mul 1 * #0 = 0 0 ps = 4
;
tst220:		movpc	lpadr			; store error loop address
		mov	#1, R0			; load multiplicand with 1
		mul	#0, R0			; multiply 1 * #0
		mfps	@#psword		; save ps
		cmpb	#4, @#psword		; is ps=4?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		146				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#0, R0			; is high order = 0
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; high order is wrong
		147				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#0, R0!1		; is low order = 0
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong or wrong sequence
		150				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #220		;
		bne	1$			; if in wrong sequence go to the hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 221 - mul -1 * #1 = -1 -1 ps = 10
;
tst221:		movpc	lpadr			; store error loop address
		mov	#-1, R0			; load multiplicand with -1
		mul	#1, R0			; multiply -1 * #1
		mfps	@#psword		; save ps
		cmpb	#10, @#psword		; is ps=10?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		151				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#-1, R0			; is high order = -1
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; high order is wrong
		152				; to scope, replace last; beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#-1, R0!1		; is low order = -1
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong or wrong sequence
		153				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #221		;
		bne	1$			; if in wrong sequence go to the hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 222 - mul 2 * #2 = 0 4 ps = 0
;
tst222:		movpc	lpadr			; store error loop address
		mov	#2, R2			; load multiplicand with 2
		mul	#2, R2			; multiply 2 * #2
		mfps	@#psword		; save ps
		cmpb	#0, @#psword		; is ps=0?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		154				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#0, R2			; is high order = 0
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; high order is wrong
		155				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#4, R3			; is low order = 4
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong or wrong sequence
		156				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #222		;
		bne	1$			; if in wrong sequence go to the hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 223 - mul 1000 * #200 = 1 0 ps = 1
;
tst223:		movpc	lpadr			; store error loop address
		mov	R5, R1			; save R5
		mov	#1000, R4		; load multiplicand with 1000
		mul	#200, R4		; multiply 1000 * #200
		mfps	@#psword		; save ps
		cmpb	#1, @#psword		; is ps=1?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		157				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#1, R4			; is high order = 1
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; high order is wrong
		160				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#0, R5			; is low order = 0
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong lr wrong sequence
		161				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R1), #223		; check the test number
		bne	1$			; if in wrong sequence go to the hlt above
		mov	R1, R5			; restore R5
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 224 - mul 2 * #77777 = 0 177776 ps = 1
;
tst224:		movpc	lpadr			; store error loop address
		mov	#2, R0			; load multiplicand with 2
		mul	#77777, R0		; multiply 2 * #77777
		mfps	@#psword		; save ps
		cmpb	#1, @#psword		; is ps=1?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		162				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#0, R0			; is high order = 0
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; high order is wrong
		163				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#177776, R0!1		; is low order = 177776
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong or wrong sequence
		164				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #224		;
		bne	1$			; if in wrong sequence go to the hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 225 - mul 7777 * #10 = 0 77770 ps = 0
;
tst225:		movpc	lpadr			; store error loop address
		mov	#7777, R2		; load multiplicand with 7777
		mul	#10, R2			; multiply 7777 * #10
		mfps	@#psword		; save ps
		cmpb	#0, @#psword		; is ps=0?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		165				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#0, R2			; is high order = 0
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; high order is wrong
		166				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#77770, R3		; is low order = 77770
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong or wrong sequence
		167				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #225		;
		bne	1$			; if in wrong sequence go to the hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 226 - mul 77777 * 77777 = 37777 1 ps = 1
;
tst226:		movpc	lpadr			; store error loop address
		mov	R5, R1			; save R5
		mov	#77777, R4		; load multiplicand with 77777
		mul	#77777, R4		; multiply 77777 * #77777
		mfps	@#psword		; save ps
		cmpb	#1, @#psword		; is ps=1?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		170				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#37777, R4		; is high order = 37777
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; high order is wrong
		171				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#1, R5			; is low order = 1
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong or wrong sequence
		172				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R1), #226		; check the test number
		bne	1$			; if in wrong sequence go to the hlt above
		mov	R1, R5			; restore R5
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 227 - mul -1 * #77777 = -1 100001 ps = 10
;
tst227:		movpc	lpadr			; store error loop address
		mov	#-1, R2			; load multiplicand with -1
		mul	#77777, R2		; multiply -1 * #77777
		mfps	@#psword		; save ps
		cmpb	#10, @#psword		; is ps=10?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		173				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#-1, R2			; is high order = -1
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; high order is wrong
		174				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#100001, R3		; is low order = 100001
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong or wrong sequence
		175				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #227		;
		bne	1$			; if in wrong sequence go to the halt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 230 - mul -2 * #77777 = -1 2 ps = 11
;
tst230:		movpc	lpadr			; store error loop address
		mov	#-2, R0			; load multiplicand with -2
		mul	#77777, R0		; multiply -2 * #77777
		mfps	@#psword		; save ps
		cmpb	#11, @#psword		; is ps=11?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		176				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#-1, R0			; is high order = -1
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; high order is wrong
		177				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#2, R0!1		; is low order = 2
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong or wrong sequence
		200				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #230		;
		bne	1$			; if in wrong sequence go to the hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 231 - mul 125252 * #2 = -1 52524 ps = 11
;
tst231:		movpc	lpadr			; store error loop address
		mov	#125252, R2		; load multiplicand with 125252
		mul	#2, R2			; multiply 125252 * #2
		mfps	@#psword		; save ps
		cmpb	#11, @#psword		; is ps=11?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		201				; to scope, replace last; beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#-1, R2			; is high order = -1
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; high order is wrong
		202				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207'
						;
		cmp	#52524, R3		; is low ordfr = 52524
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong or wrong sequence
		203				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #231		;
		bne	1$			; if in wrong sequence go to the hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 232 - mul 125252 * #40000 = 165252 100000 ps = 11
;
tst232:		movpc	lpadr			; store error loop address
		mov	R5, R1			; save R5
		mov	#125252, R4		; load multiplicand with 125252
		mul	#40000, R4		; multiply 125252 * #40000
		mfps	@#psword		; save ps
		cmpb	#11, @#psword		; is ps=11?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		204				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#165252, R4		; is high order = 165252
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; high order is wrong
		205				; to scope, replace last; beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#100000, R5		; is low order = 100000
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong or wrong sequence
		206				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R1), #232		; check the test number
		bne	1$			; if in wrong sequence go to the hlt above
		mov	R1, R5			; restore R5
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 233 - mul 107070 * #107070 = 31222 26100 ps = 1
;
tst233:		movpc	lpadr			; store error loop address
		mov	#107070, R0		; load multiplicand with 107070
		mul	#107070, R0		; multiply 107070 * #107070
		mfps	@#psword		; save ps
		cmpb	#1, @#psword		; is ps=1?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		207				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#31222, R0		; is high order = 31222
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; high order is wrong
		210				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#26100, R0!1		; is low order = 26100
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong or wrong sequence
		211				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #233		;
		bne	1$			; if in wrong sequence go to the hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 234 - mul -1 * #1 = -1 -1 ps = 10
;
tst234:		movpc	lpadr			; store error loop address
		mov	#-1, R1			; load multiplicand with -1
		mul	#1, R1			; multiply -1 * #1
		mfps	@#psword		; save ps
		cmpb	#10, @#psword		; is ps=10?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		212				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#-1, R1			; is high order = -1
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; high order is wrong
		213				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#-1, R1			; is low order = -1
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong or wrong sequence
		214				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #234		;
		bne	1$			; if in wrong sequence go to the hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 235 - mul -1 * #0 = 0 0 ps = 4
;
tst235:		movpc	lpadr			; store error loop address
		mov	#-1, R3			; load multiplicand with -1
		mul	#0, R3			; multiply -1 * #0
		mfps	@#psword		; save ps
		cmpb	#4, @#psword		; is ps=4?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		215				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#0, R3			; is high order = 0
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; h1gh order is wrong
		216				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#0, R3			; is low order = 0
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong or wrong sequence
		217				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #235		;
		bne	1$			; if in wrong sequence go to the hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 236 - mul 77777 * #100000 = 100000 100000 ps = 11
;
tst236:		movpc	lpadr			; store error loop address
		mov	R5, R1			; save R5
		mov	#77777, R5		; load multiplicand with 77777
		mul	#100000, R5		; multiply 77777 * #100000
		mfps	@#psword		; save ps
		cmpb	#11, @#psword		; is ps=11?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		220				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#100000, R5		; is high order = 100000
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; high order is wrong
		221				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#100000, R5		; is low order = 100000
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong or wrong sequence
		222				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R1), #236		; check the test number
		bne	1$			; if in wrong sequence go to the hlt above
		mov	R1, R5			; restore R5
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 237 - mul -1 * #77777 = 100001 100001 ps = 10
;
tst237:		movpc	lpadr			; store error loop address
		mov	#-1, R1			; load multiplicand with -1
		mul	#77777, R1		; multiply -1 * #77777
		mfps	@#psword		; save ps
		cmpb	#10, @#psword		; is ps=10?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		223				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#100001, R1		; is high order = 100001
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; h1gh order is wrong
		224				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#100001, R1		; is low order = 100001
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong or wrong sequence
		225				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #237		;
		bne	1$			; if in wrong sequence go to the hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 240 - mul 77777 * #77777 = 1 1 ps = 1
;
tst240:		movpc	lpadr			; store error loop address
		mov	#77777, R3		; load multiplicand with 77777
		mul	#77777, R3		; multiply 77777 * #77777
		mfps	@#psword		; save ps
		cmpb	#1, @#psword		; is ps=1?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		226				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#1, R3			; js high order = 1
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; high order is wrong
		227				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#1, R3			; is low order = 1
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong or wrong sequence
		230				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #240		;
		bne	1$			; if in wrong sequence go to the hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 241 - mul 2 * #2 = 4 4 ps = 0
;
tst241:		movpc	lpadr			; store error loop address
		mov	R5, R1			; save R5
		mov	#2, R5			; load multiplicand with 2
		mul	#2, R5			; multiply 2 * #2
		mfps	@#psword		; save ps
		cmpb	#0, @#psword		; is ps=0?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		231				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#4, R5			; is high order = 4
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; h1gh order is wrong
		232				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#4, R5			; is low order = 4
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong or wrong sequence
		233				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R1), #241		; check the test number
		bne	1$			; if in wrong sequence go to the hlt above
		mov	R1, R5			; re store R5
		inc	(R5)			;
		mov	#40000, R2		;
		mov	#s5, R3			;
		mov	#s6, R4			;
;_____________________________________________________________________________
;
; TEST 242 - mul 125252 * s5 = 165252 100000 ps = 11
;
tst242:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load multiplicand with 125252
		mul	s5, R0			; multiply 125252 * s5
		mfps	@#psword		; save ps
		cmpb	#11, @#psword		; is ps=11?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		234				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#165252, R0		; is high order = 165252
		beq	.+10			;
		jsr	PC, $hlt		; seen an err jr, go to the halt routine
						; high order is wrong
		235				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#100000, R0!1		; is low order = 100000
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong or wrong sequence
		236				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #242		;
		bne	1$			; if in wrong sequence go to the hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 243 - mul 125252 * @s6 = 165252 100000 ps = 11
;
tst243:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load multiplicand with 125252
		mul	@s6, R0			; multiply 125252 * @s6
		mfps	@#psword		; save ps
		cmpb	#11, @#psword		; is ps=11?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		237				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#165252, R0		; is high order = 165252
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; high order is wrong
		240				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#100000, R0!1		; is low order = 100000
		beq	.+10			;
 1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong or wrong sequence
		241				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #243		;
		bne	1$			; if in wrong sequence go to the hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 244 - mul 125252 * @#s5 = 165252 100000 ps = 11
;
tst244:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load multiplicand with 125252
		mul	@#s5, R0		; multiply 125252 * @#s5
		mfps	@#psword		; save ps
		cmpb	#11, @#psword		; is ps=11?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		242				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#165252, R0		; is high order = 165252
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; high order is wrong
		243				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#100000, R0!1		; is low order = 100000
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong or wrong sequence
		244				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #244		;
		bne	1$			; if in wrong sequence go to the hlt above
		inc	(R5)			;
;_______________________________________________;_____________________________
;
; TEST 245 - mul 125252 * R2 = 165252 100000 ps = 11
;
tst245:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load multiplicand with 125252
		mul	R2, R0			; multiply 125252 * R2
		mfps	@#psword		; save ps
		cmpb	#11, @#psword		; is ps=11?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		245				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#165252, R0		; is high order = 165252
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to tme halt routine
						; high order is wrong
		246				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#100000, R0!1		; is low order = 100000
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong or wrong sequence
		247				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #245		;
		bne	1$			; if in wrong sequence go to the hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 246 - mul 125252 * (3)+ = 165252 100000 ps = 11
;
tst246:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load multiplicand with 125252
		mul	(3)+, R0		; multiply 125252 * (3)+
		mfps	@#psword		; save ps
		cmpb	#11, @#psword		; is ps=11?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		250				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#165252, R0		; is high order = 165252
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; high order is wrong
		251				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#100000, R0!1		; is low order = 100000
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong or wrong sequence
		252				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #246		;
		bne	1$			; if in wrong sequence go to the hlt above
		inc	(R5)			;
;_______________________________________________;_____________________________
;
; TEST 247 - mul 125252 * -(3) = 165252 100000 ps = 11
;
tst247:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load multiplicand with 125252
		mul	-(3), R0		; multiply 125252 * -(3)
		mfps	@#psword		; save ps
		cmpb	#11, @#psword		; is ps=11?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		253				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#165252, R0		; is high order = 165252
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; high order is wrong
		254				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#100000, R0!1		; is low order = 100000
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong or wrong sequence
		255				; to scope, replace last: req .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #247		;
		bne	1$			; if in wrong sequence go to the hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 250 - mul 125252 * 2(4) = 165252 100000 ps = 11
;
tst250:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load multiplicand with 125252
		mul	2(4), R0		; multiply 125252 * 2(4)
		mfps	@#psword		; save ps
		cmpb	#11, @#psword		; is ps=11?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		256				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#165252, R0		; is high order = 165252
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; high order is wrong
		257				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#100000, R0!1		; is low order 100000
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong or wrong sequence
		260				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #250		;
		bne	1$			; if in wrong sequence go to the hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 251 - mul 125252 * @(4) = 165252 100000 ps = 11
;
tst251:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load multiplicand with 125252
		mul	@(4), R0		; multiply 125252 * @(4)
		mfps	@#psword		; save ps
		cmpb	#11, @#psword		; is ps=11?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		261				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#165252, R0		; is high order = 165252
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; high order is wrong
		262				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#100000, R0!1		; is low order 100000
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong or wrong sequence
		263				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #251		;
		bne	1$			; if in wrong sequence go to the hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 252 - mul 125252 * @(4)+ = 165252 100000 ps = 11
;
tst252:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load multiplicand with 125252
		mul	@(4)+, R0		; multiply 125252 * @(4)+
		mfps	@#psword		; save ps
		cmpb	#11, @#psword		; is ps=11?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps ts wrong
		264				; to replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#165252, R0		; is high order - 165252
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; high order is wrong
		265				; to scope, replace last: beq .+10 (001403)
						; by (013746 00017? 000207)
						;
		cmp	#100000, R0!1		; is low order = 100000
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong or wrong sequence
		266				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #252		;
		bne	1$			; if in wrong sequence go to the hlt above
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 253 - mul	125252 * @-(4) = 165252 100000 ps = 11
;
tst253:		movpc	lpadr			; store error loop address
		mov	#125252, R0		; load multiplicand with 125252
		mul	@-(4), R0		; multiply 125252 * @-(4)
		mfps	@#psword		; save ps
		cmpb	#11, @#psword		; is ps=11?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		267				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#165252, R0		; is high order = 165252
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; high order is wrong
		270				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#100000, R0!1		; is low order = 100000
		beq	.+10			;
1$:						;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; low order is wrong or wrong sequence
		271				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #253		;
		bne	1$			; if in wrong sequence go to the hi above
		inc	(R5)			;
;_____________________________________________________________________________
;
; div instruction tests
;_____________________________________________________________________________
;
; TEST 254 - div 0 4 / #2 = 2 rem = 0 ps = 0
;
tst254:		movpc	lpadr			; store error loop address
		mov	#0, R0			; load high order with 0
		mov	#4, R0+1		; load low order with 4
		div	#2, R0			; divide by #2
		mfps	@#psword		; save ps
		cmpb	#0, @#psword		; is ps=0?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		272				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#2, R0			; is quotient = 2
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; quotient is wrong
		273				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#0, R0+1		; is remainder = 0
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong remainder
		274				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #254		;
		beq	.+10			; if in wrong sequence go to the hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		275				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 255 - div -1 -9. / #3 = -3 rem = 0 ps = 10
;
tst255:		movpc	lpadr			; store error loop address
		mov	#-1, R2			; load high order with -1
		mov	#-9., R3		; load low order with -9.
		div	#3, R2			; divide by #3
		mfps	@#psword		; save ps
		cmpb	#10, @#psword		; is ps=10?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		276				; to scope, replace last: beq .+10 (00143)
						; by (013746 000172 000207)
		cmp	#-3, R2			; is quotient = -3
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; quotient is wrong
		277				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#0, R3			; is remainder = 0
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong remainder
		300				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #255		;
		beq	.+10			; if in wrong sequence go to the hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		301				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 256 - div 0 9. / #2 = 4 rem = 1 ps = 0
;
tst256:		movpc	lpadr			; store error loop address
		mov	R5, R1			; save R5
		mov	#0, R4			; load high order with 0
		mov	#9., R5			; load low order with 9.
		div	#2, R4			; divide by #2
		mfps	@#psword		; save ps
		cmpb	#0, @#psword		; is ps=0?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		302				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#4, R4			; is quotient = 4
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; quotient is wrong
		303				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#1, R5			; is remainder = 1
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong remainder
		304				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		mov	R1, R5			; restore R5
		cmp	(R5), #256		;
		beq	.+10			; if in wrong sequence go to the hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		305				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 257 - div -1 -9. / #2 = -4 rem = -1 ps = 10
;
tst257:		movpc	lpadr			; store error loop address
		mov	#-1, R0			; load high order with -1
		mov	#-9., R0+1		; load low order with -9.
		div	#2, R0			; divide by #2
		mfps	@#psword		; save ps
		cmpb	#10, @#psword		; is ps=10?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		306				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#-4, R0			; is quotient = -4
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; quotient is wrong
		307				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#-1, R0+1		; is remainder = -1
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong remainder
		310				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #257		;
		beq	.+10			; if in wrong sequence go to the hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		311				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 260 - div 0 2 / #-3 = 0 rem = 2 ps = 4
;
tst260:		movpc	lpadr			; store error loop address
		mov	#0, R2			; load high order with 0
		mov	#2, R3			; load low order with 2
		div	#-3, R2			; divide by #-3
		mfps	@#psword		; save ps
		cmpb	#4, @#psword		; is ps=4?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		312				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#0, R2			; is quotient = 0
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; quotient is wrong
		313				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#2, R3			; is remainder = 2
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong remainder
		314				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #260		;
		beq	.+10			; if in wrong sequence go to the hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		315				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 261 - div -1 -2 / #3 = 0 rem = -2 ps = 4
;
tst261:		movpc	lpadr			; store error loop address
		mov	R5, R1			; save R5
		mov	#-1, R4			; load high order with -1
		mov	#-2, R5			; load low order with -2
		div	#3, R4			; divide by #3
		mfps	@#psword		; save ps
		cmpb	#4, @#psword		; is ps=4?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		316				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#0, R4			; is quotient = 0
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; quotient is wrong
		317				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#-2, R5			; is remainder = -2
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong remainder
		320				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		mov	R1, R5			; restore R5
		cmp	(R5), #261		;
		beq	.+10			; if in wrong sequence go to the hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		321				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 262 - div -1 -1 / #1 = -1 rem = 0 ps = 10
;
tst262:		movpc	lpadr			; store error loop address
		mov	#-1, R0			; load high order with -1
		mov	#-1, R0+1		; load low order with -1
		div	#1, R0			; divide by #1
		mfps	@#psword		; save ps
		cmpb	#10, @#psword		; is ps=10?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		322				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#-1, R0			; is quotient = -1
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; quotient is wrong
		323				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#0, R0+1		; is remainder = 0
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong remainder
		324				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #262		;
		beq	.+10			; if in wrong sequence go to the hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		325				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 263 - div 0 0 / #1 = 0 rem = 0 ps = 4
;
tst263:		movpc	lpadr			; store error loop address
		mov	#0, R0			; load high order with 0
		mov	#0, R0+1		; load low order with 0
		div	#1, R0			; divide by #1
		mfps	@#psword		; save ps
		cmpb	#4, @#psword		; is ps=4?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		326				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#0, R0			; is quotient = 0
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; quotient is wrong
		327				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#0, R0+1		; is remainder = 0
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong remainder
		330				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #263		;
		beq	.+10			; if in wrong sequence go to the hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		331				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 264 - div -1 125252 / #2 = 152525 rem = 0 ps = 10
;
tst264:		movpc	lpadr			; store error loop address
		mov	#-1, R2			; load high order with -1
		mov	#125252, R3		; load low order with 125252
		div	#2, R2			; divide by #2
		mfps	@#psword		; save ps
		cmpb	#10, @#psword		; is ps=10?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		332				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#152525, R2		; is quotient = 152525
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; quotient is wrong
		333				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#0, R3			; is remainder = 0
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong remainder
		334				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #264		;
		beq	.+10			; if in wrong sequence go to the hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		335				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 265 - div -1 -1 / #-1 = 1 rem = 0 ps = 0
;
tst265:		movpc	lpadr			; store error loop address
		mov	R5, R1			; save R5
		mov	#-1, R4			; load high order with -1
		mov	#-1, R5			; load low order with -1
		div	#-1, R4			; divide by #-1
		mfps	@#psword		; save ps
		cmpb	#0, @#psword		; is ps=0?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		336				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#1, R4			; is quotient = 1
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; quotient is wrong
		337				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#0, R5			; is remainder = 0
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong remainder
		340				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		mov	R1, R5			; restore R5
		cmp	(R5), #265		;
		beq	.+10			; if in wrong sequence go to the hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		341				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 266 - div 25253 1 / #125252 = 100000 rem = 1 ps = 10
;
tst266:		movpc	lpadr			; store error loop address
		mov	#25253, R0		; load high order with 25253
		mov	#1, R0+1		; load low order with 1
		div	#125252, R0		; divide by #125252
		mfps	@#psword		; save ps
		cmpb	#10, @#psword		; is ps=10?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		342				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#100000, R0		; is quotient = 100000
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; quotient is wrong
		343				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#1, R0+1		; is remainder = 1
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong remainder
		344				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #266		;
		beq	.+10			; if in wrong sequence go to the hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		345				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 267 - div 37777 77777 / #77777 = 77777 rem = 77776 ps = 0
;
tst267:		movpc	lpadr			; store error loop address
		mov	#37777, R2		; load high order with 37777
		mov	#77777, R3		; load low order with 77777
		div	#77777, R2		; divide by #77777
		mfps	@#psword		; save ps
		cmpb	#0, @#psword		; is ps=0?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		346				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#77777, R2		; is quotient = 77777
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; quotient is wrong
		347				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#77776, R3		; is remainder = 77776
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong remainder
		350				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #267		;
		beq	.+10			; if in wrong sequence go to the hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		351				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 270 - div 0 100000 / #2 = 40000 rem 0 ps = 0
;
tst270:		movpc	lpadr			; store error loop address
		mov	R5, R1			; save R5
		mov	#0, R4			; load high order with c
		mov	#100000, R5		; load low order with 100000
		div	#2, R4			; divide by #2
		mfps	@#psword		; save ps
		cmpb	#0, @#psword		; is ps=0?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		352				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#40000, R4		; is quotient = 40000
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; quotient is wrong
		353				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#0, R5			; is remainder = 0
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong remainder
		354				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		mov	R1, R5			; restore R5
		cmp	(R5), #270		;
		beq	.+10			; if in wrong sequence go to the hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		355				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 271 - div 177777 77777 / #177776 = 40000 rem = 177777 ps = 0
;
tst271:		movpc	lpadr			; store error loop address
		mov	#177777, R0		; load high order with 177777
		mov	#77777, R0+1		; load low order with 77777
		div	#177776, R0		; divide by #177776
		mfps	@#psword		; save ps
		cmpb	#0, @#psword		; is ps=0?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		356				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#40000, R0		; is quotient = 40000
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; quotient is wrong
		357				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#177777, R0+1		; is remainder = 177777
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong remainder
		360				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #271		;
		beq	.+10			; if in wrong sequence go to the hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		361				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 272 - div 0 52525 / #52525 = 1 rem = 0 ps = 0
;
tst272:		movpc	lpadr			; store error loop address
		mov	#0, R2			; load high order with 0
		mov	#52525, R3		; load low order with 52525
		div	#52525, R2		; divide by #52525
		mfps	@#psword		; save ps
		cmpb	#0, @#psword		; is ps=0?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		362				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#1, R2			; is quotient = 1
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; quotient is wrong
		363				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#0, R3			; is remainder = 0
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong remainder
		364				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #272		;
		beq	.+10			; if in wrong sequence go to the hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		365				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 273 - div 0 77777 / #0 = dummy rem = duwmy ps = 3
;
tst273:		movpc	lpadr			; store error loop address
		mov	R5, R1			; save R5
		mov	#0, R4			; load high order with 0
		mov	#77777, R5		; load low order with 77777
		div	#0, R4			; divide by #0
		mfps	@#psword		; save ps
		bic	#14, @#psword		;
		cmpb	#3, @#psword		; is ps=3?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		366				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 00020?)
						;
		mov	R1, R5			; restore R5
		cmp	(R5), #273		;
		beq	.+10			; if in wrong sequence go to the hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		367				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 274 - div 77777 177777 / #2 = dummy rem = dummy ps = 2
;
tst274:		movpc	lpadr			; store error loop address
		mov	#77777, R0		; load high order with 77777
		mov	#177777, R0+1		; load low order with 177777
		div	#2, R0			; divide by #2
		mfps	@#psword		; save ps
		bic	#14, @#psword		;
						;
		cmpb	#2, @#psword		; is ps=2?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		370				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #274		;
		beq	.+10			; if in wrong sequence go to the hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		371				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
		mov	#2, R2			;
		mov	#s9, R3			;
		mov	#s10, R4		;
;_____________________________________________________________________________
;
; TEST 275 - div 0 52525 / s9 = 25252 rem = 1 ps = 0
;
tst275:		movpc	lpadr			; store error loop address
		mov	#0, R0			; load high order with 0
		mov	#52525, R0+1		; load low order with 52525
		div	s9, R0			; divide by s9
		mfps	@#psword		; save ps
		cmpb	#0, @#psword		; is ps=0?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		372				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#25252, R0		; is quotient = 25252
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; quotient is wrong
		373				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#1, R0+1		; is remainder = 1
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong remainder
		374				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #275		;
		beq	.+10			; if in wrong sequence go to the hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		375				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 276 - div 0 52525 / @s10 = 25252 rem = 1 ps = 0
;
tst276:		movpc	lpadr			; store error loop address
		mov	#0, R0			; load high order with 0
		mov	#52525, R0+1		; load low order with 52525
		div	@s10, R0		; divide by @s10
		mfps	@#psword		; save ps
		cmpb	#0, @#psword		; is ps=0?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		376				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#25252, R0		; is quotient = 25252
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; quotient is wrong
		377				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#1, R0+1		; is remainder = 1
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong remainder
		400				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #276		;
		beq	.+10			; if in wrong sequence go to the hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		401				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 277 - div 0 52525 / @#s9 = 25252 rem = 1 ps = 0
;
tst777:		movpc	lpadr			; store error loop address
		mov	#0, R0			; load high order with 0
		mov	#52525, R0+1		; load low order with 52525
		div	@#s9, R0		; divide by @#s9
		mfps	@#psword		; save ps
		cmpb	#0, @#psword		; is ps=0?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		402				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#25252, R0		; is quotient = 25252
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; quotient is wrong
		403				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#1, R0+1		; is remainder = 1
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong remainder
		404				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #277		;
		beq	.+10			; if in wrong sequence go to the hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		405				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 300 - div 0 52525 / R2 = 25252 rem = 1 ps = 0
;
tst300:		movpc	lpadr			; store error loop address
		mov	#0, R0			; load high order with 0
		mov	#52525, R0+1		; load low order with 52525
		div	R2, R0			; divide by R2
		mfps	@#psword		; save ps
		cmpb	#0, @#psword		; is ps=0?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		406				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#25252, R0		; is quotient = 25252
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; quotient is wrong
		407				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#1, R0+1		; is remainder = 1
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong remainder
		410				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #300		;
		beq	.+10			; if in wrong sequence go to the hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		411				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 301 - div 0 52525 / (3)+ = 25252 rem = 1 ps = 0
;
tst301:		movpc	lpadr			; store error loop address
		mov	#0, R0			; load high order with 0
		mov	#52525, R0+1		; load low order with 52525
		div	(3)+, R0		; divide by (3)+
		mfps	@#psword		; save ps
		cmpb	#0, @#psword		; is ps=0?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		412				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#25252, R0		; is quotient = 25252
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; quotient is wrong
		413				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#1, R0+1		; is remainder = 1
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong remainder
		414				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #301		;
		beq	.+10			; if in wrong sequence go to the hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		415				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 302 - div 0 52525 / -(3) = 25252 rem = 1 ps = 0
;
tst302:		movpc	lpadr			; store error loop address
		mov	#0, R0			; load high order with 0
		mov	#52525, R0+1		; load low order with 52525
		div	-(3), R0		; divide by -(3)
		mfps	@#psword		; save ps
		cmpb	#0, @#psword		; is ps=0?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		416				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#25252, R0		; is quotient = 25252
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; quotient is wrong
		417				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#1, R0+1		; is remainder = 1
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong remainder
		420				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #302		;
		beq	.+10			; if in wrong sequence go to the hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		421				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 303 - div 0 52525 / 2(4) = 25252 rem = 1 ps = 0
;
tst303:		movpc	lpadr			; store error loop address
		mov	#0, R0			; load high order with 0
		mov	#52525, R0+1		; load low order with 52525
		div	2(4), R0		; divide by 2(4)
		mfps	@#psword		; save ps
		cmpb	#0, @#psword		; is ps=0?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		422				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#25252, R0		; is quotient = 25252
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; quotient is wrong
		423				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#1, R0+1		; is remainder = 1
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong remainder
		424				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #303		;
		beq	.+10			; if in wrong sequence go to the hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		425				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 304 - div 0 52525 / @(4) = 25252 rem = 1 ps = 0
;
tst304:		movpc	lpadr			; store error loop address
		mov	#0, R0			; load high order with 0
		mov	#52525, R0+1		; load low order with 52525
		div	@(4), R0		; divide by 3(4)
		mfps	@#psword		; save ps
		cmpb	#0, @#psword		; is ps=0?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		426				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#25252, R0		; is quotient = 25252
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; quotient is wrong
		427				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#1, R0+1		; is remainder = 1
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong remainder
		430				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #304		;
		beq	.+10			; if in wrong sequence go to the hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		431				; to scope, replace last: bec .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 305 - div 0 52525 / @(4)+ = 25252 rem = 1 ps = 0
;
tst305:		movpc	lpadr			; store error loop address
		mov	#0, R0			; load high order with 0
		mov	#52525, R0+1		; load low order with 52525
		div	@(4)+, R0		; divide by @(4)+
		mfps	@#psword		; save ps
		cmpb	#0, @#psword		; is ps=0?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		432				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#25252, R0		; is quotient = 25252
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; quotient is wrong
						;
		433				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#1, R0+1		; is remainder = 1
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong remainder
		434				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #305		;
		beq	.+10			; if in wrong sequence go to the hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		435				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;
;_____________________________________________________________________________
;
; TEST 306 - div 0 52525 / @-(4) = 25252 rem = 1 ps = 0
;
tst306:		movpc	lpadr
						; store error loop address
		mov	#0, R0			; load high order with 0
		mov	#52525, R0+1		; load low order with 52525
		div	@-(4), R0		; divide by @-(4)
		mfps	@#psword		; save ps
		cmpb	#0, @#psword		; is ps=0?
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; ps is wrong
		436				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#25252, R0		; is quotient = 25252
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; quotient is wrong
		437				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	#1, R0+1		; is remainder = 1
		beq	.+10			;
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; wrong remainder
		440				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		cmp	(R5), #306		;
		beq	.+10			; if in wrong sequence go to the hlt
		jsr	PC, $hlt		; seen an error, go to the halt routine
						; test is in wrong sequence
		441				; to scope, replace last: beq .+10 (001403)
						; by (013746 000172 000207)
		inc	(R5)			;

		.sbttl	"END OF PASS ROUTINE"
;_____________________________________________________________________________
;
; increment the pass number ($pass) in APT mailbox
; type "end pass #xxxxx" (where xxxxx is a decimal number)
; if there is a monitor go to it
; if there isn't jump to restart
;
$eop:		inc	#-1			; type id only on first pass
		bne	skpmsg			; branch around after first pass
		type	, msg1			; type title
skpmsg:		inc	$pass			; increment the pass number
		bic	#100000, $pass		; don't let count go negative
		dec	(PC)+			; loop?
$eopct:		.word	1			;
		bgt	$doagn			; yes
		mov	(PC)+, @(PC)+		; restore loop counter
$endct:		.word	16			;
		$eopct				;
		type	, $endmg		; type "end pass #"
		mov	$pass, -(SP)		; save pass count for typeout
		typds				; go type pass count in decimal
		type	, $enull		; type a few null characters
						;
.if ne HOEP                     		;
		halt				; halt on end-of-pass
.endc						;
						;
$get42:		mov	@#42, R0		; get monitor address
		beq	doagin			; branch if no monitor
		reset				; clear the world
$endad:		jsr	PC, (R0)		; go to monitor
		nop				; save room
		nop				; for
		nop				; act11
doagin:		mov	@#4, -(SP)		; save contents of location 4
		mov	#1$, @#4		; set up in case of trap
		mov	#1, @#164000		; notify multitester we're done
		br	2$			; no trap so don't reset stack
1$:		add	#4, SP			; reset stack after trap
2$:		mov	(SP)+, @#4		; restore location 4 for testing
$doagn:		jmp	@(PC)+			; return to test
$rtnad:		.word	restrt			;
$enull:		.byte	-1, -1, 0		; null character string
$endmg:		.asciz	<15><12>/END PASS #/
msg1:		.asciz	<15><12>/CJKDBD0 DCF11-AA CPU DIAGNOSTIC/
		.even				;

		.sbttl	"HALT ROUTINE"
;_____________________________________________________________________________
;
; Halt routine
; Program comes here on encountering any error
;
$hlt:		mov	@(SP), @#$fatal		; place the error number at location $fatal
		mov	(SP), @#contin		; save error number address
		bit	#20000, @swr		; has the operator asked to supress error type outs
		bne	6$			;
		type	, $crlf			; go and type a cr, lf, followed by 3 spaces
		type	, msgerr		; inform error
		type	, $crlf			; go and type a cr, lf, followed by 3 spaces
		mov	@#contin, -(SP)		; retreive error number addr
		sub	#4, (SP)		; calculate error PC
		typoc				; type PC
		type	, $crlf			; go and type a cr, lf, followed by 3 spaces
		mov	@#$fatal, -(SP)		; retreive error number
		typos				; type error number
		.byte	3			;
		.byte	0			;
6$:		tstb	$env			; if we are not under APT. then go to
		beq	8$			; 8$
		inc	@#$msgty		; otherwise inform APT. about seeing the error
		br	.			; and loop
8$:		type	, $crlf			; go and type a cr, lf, followed by 3 spaces
		tst	@swr			; is it required to halt on error?
		bpl	10$			; if not then go to 10$
		halt				;
10$:		mov	@#contin, -(SP)		;
		add	#2, (SP)		; calculate return address
		rts	PC			; return
msgerr:		.asciz	/ ERROR!   PC, AND ERROR # ARE: /
		.even				;
contin:		.word 0				;

		.sbttl	"POWER FAIL ROUTINE"

pwrdn:		mov	#pwrup, 24		;
		halt				;
pwrup:		mov	#pwrdn, 24		;
		mov	#buff, SP		;
		bitb	#40, $envm		; will APT allow printing?
		bne	pfres			; no
		mov	#msgpwf, R0		; get msg addr.
pwait:		tstb	@#tps			; tty ready
		bpl	pwait			; no wait
		movb	(R0)+, @#tpb		; print character
		bne	pwait			; next if not done.
pwait1:		tstb	@#tps			;
		bpl	pwait1			;
pfres:		jmp	restrt			;
msgpwf:		.asciz	<15><12>/POWER FAILED!/	;
		.even				;

		.sbttl	"TYPE ROUTINE"
;_____________________________________________________________________________
;
; Routine to type asciz message. message must terminate with a 0 byte.
; The routine will insert a number of null characters after a line feed.
; Note1:		$null contains the character to be used as the filler character.
; Note2:		$fillb contains the number of filler characters required.
; Note3:		$f1llc contains the character to fill after.
;
; Call:
; 1) Using a trap instruction
;		type	, mesadr		; mesadr is first address of an asciz string
; or						;
;		type				;
;		mesadr				;
;
$type:		tstb	$tpflg			; is there a terminal?
		bpl	1$			; br if yes
		halt				; halt here if no terminal
		br	3$			; leave
1$:		mov	R0, -(SP)		; save R0
		mov	@2(SP), R0		; get address of asciz string
		cmpb	#aptenv, $env		; running in APT mode
		bne	62$			; no, go check for APT console
		bitb	#aptspo0l, $envm	; spool message to APT
		beq	62$			; no, go check for console
		mov	R0, 61$			; setup message address for APT
		jsr	PC, $aty3		; spool message to APT
61$:		.word	0			; message address
62$:		bitb	#aptcsup, $envm		; APT console suppressed
		bne	60$			; yes, skip type out
2$:		movb	(R0)+, -(SP)		; push character to be typed onto stack
		bne	4$			; br if it isn't the terminator
		tst	(SP)+			; if terminator pop it off the stack
60$:		mov	(SP)+, R0		; restore R0
3$:		add	#2, (SP)		; adjust return PC
		rti				; return
4$:		cmpb	#ht, (SP)		; branch if <ht>
		beq	8$			;
		cmpb	#crlf, (SP)		; branch if not <crlf>
		bne	5$			;
		tst	(SP)+			; pop <cr><lf> equiv
		type				; type a cr and lf
		$crlf				;
		clrb	$charcnt		; clear character count
		br	2$			; get next character
5$:		jsr	PC, $typec		; go type this character
6$:		cmpb	$fillc, (SP)+		; is it time for filler chars.?
		bne	2$			; if no go get next char.
		mov	$null, -(SP)		; get # of filler chars, needed,
						; and the null char.
7$:		decb	1(SP)			; does a null need to be typed?
		blt	6$			; br if no-go pop the null off of stack
		jsr	PC, $typec		; go type a null
		decb	$charcnt		; do not count as a count
		br	7$			; loop
	; horizontal tab processor
8$:		movb	#' , (SP)		; replace tab with space
9$:		jsr	PC, $typec		; type a space
		bitb	#7, $charcnt		; branch if not at
		bne	9$			; tab stop
		tst	(SP)+			; pop space off stack
		br	2$			; get next character
$typec:						;
		tstb	@$tks			; char in kbd buffer?
		bpl	10$			; br if not
		mov	@$tkb, -(SP)		; get char
		bic	#177600, (SP)		; strip extraneous bits
		cmpb	#$xoff, (SP)		; was char xoff
		bne	102$			; br if not
101$:						;
		tstb	@$tks			; wait for char
		bpl	101$			;
		movb	@$tkb, (SP)		; get char
		bic	#177600, (SP)		; strip it
		cmpb	#$xon, (SP)		; was it xon?
		bne	101$			; br if not
102$:						;
		tst	(SP)+			; fix stack
10$:						;
		tstb	@$tps			; wait until printer is ready
		bpl	10$			;
		movb	2(SP), @$tpb		; load char to be typed into data reg.
		cmpb	#cr, 2(SP)		; is character a carriage return?
		bne	1$			; branch if no
		clrb	$charcnt		; yes-clear character count
		br	$typex			; exit
1$:		cmpb	#lf, 2(SP)		; is character a line feed <lf>?
		beq	$typex			; branch if yes
		incb	(PC)+			; count the character
$charcnt:	.word	0			; character count storage
$typex:		rts	PC			;
$tks:		.word	177560			; tty kbd status
$tkb:		.word	177562			; ttv kbd buffer
$null:		.byte	0			; contains null character for fills
$fills:		.byte	2			; contains # of filler characters required
$fillc:		.byte	12			; insert fill chars. after a "line feed"
$tpflg:		.byte	0			; "terminal available" flag (bit<07>=0-yes)
$ques:		.ascii	"?"			; question mark
$lf:		.asciz	<12>			; linefeed <lf>
		.even				;

		.sbttl	"APT COMMUNICATIONS ROUTINE"

$aty1:		movb	#1, $fflg		; to report fatal error
$aty3:		movb	#1, $mflg		; to type a message
		br	$atyc			;
$aty4:		movb	#1, $fflg		; to only report fatal error
$atyc:						;
		mov	R0, -(SP)		; push R0 on stack
		mov	R1, -(SP)		; push R1 on stack
		tstb	$mflg			; should type a message
		beq	5$			; if not: br
		cmpb	#aptenv, $env		; operating under APT?
		bne	3$			; if not: br
		bitb	#aptspool, $envm	; should spool messages?
		beq	3$			; if not: br
		mov	@4(SP), R0		; get message addr.
		add	#2, 4(SP)		; bump return addr.
1$:		tst	$msgtype		; see if done w/ last xmission?
		bne	1$			; if not: wait
		mov	R0, $msgad		; put addr in mailbox
2$:		tstb	(R0)+			; find end of message
		bne	2$			;
		sub	$msgad, R0		; sub start of message
		asr	R0			; get message lngth in words
		mov	R0, $msglgt		; put length in mailbox
		mov	#4, $msgtype		; tell APT to take msg.
		br	5$			;
3$:		mov	@4(SP), 4$		; put msg addr in jsr linkage
		add	#2, 4(SP)		; return address
		mov	177776, -(SP)		; push 177776 on stack
		jsr	PC, $type		; call type macro
4$:		.word	0			;
5$:						;
10$:		tstb	$fflg			; should report fatal error?
		beq	12$			; if not: br
		tst	$env			; running under APT?
		beq	12$			; if not: br
11$:		tst	$msgtype		; finished last message?
		bne	11$			; if not: wait
		mov	@4(SP), $fatal		; get error #
		add	#2, 4(SP)		; bump return addr.
		inc	$msgtype		; tell APT to take error
12$:		clrb	$fflg			; clear fatal flag
		clrb	$lflg			; clear log flag
		clrb	$mflg			; clear message flag
		mov	(SP)+, R1		; pop stack into R1
		mov	(SP)+, R0		; pop stack into R0
		rts	PC			; return
						;
$mflg:		.byte	0			; message flag
$lflg:		.byte	0			; log flag
$fflg:		.byte	0			; fatal flag
		.even				;
;_____________________________________________________________________________
;
		aptsize	= 200			;
		aptenv	= 001			;
		aptspool= 100			;
		aptcsup = 040			;
;
; This routine is used to change a 16-bit binary number to a 5-digit
; signed decimal (asch) number and type it. Depending on whether the
; number is positive or negative a space or a minus sign will be typed
; before the first digit of the number. Leading zeros will always be
; replaced with spaces.
; Call:
;		mov	num, -(SP)		; put the binary number on the stack
;		typds				; go to the routine
;
		.sbttl	"CONVERT BINARY TO DECIMAL AND TYPE ROUTINE"

$typds:		mov	R0, -(SP)		; push R0 on stack
		mov	R1, -(SP)		; push R1 on stack
		mov	R2, -(SP)		; push R2 on stack
		mov	R3, -(SP)		; push R3 on stack
		mov	R5, -(SP)		; push R5 on stack
		mov	#20200, -(SP)		; set blank switch and sign
		mov	20(SP), R5		; get the input number
		bpl	1$			; br if input is pos.
		neg	R5			; make the binary number pos.
		movb	#'-, 1(SP)		; make the asch number neg.
1$:		clr	R0			; zero the constants index
		mov	#$dblk, R3		; setup the output pointer
		movb	#' , (R3)+		; set the first character to a blank
2$:		clr	R2			; clear the bcd number
		mov	$dtbl(R0), R1		; get the constant
3$:		sub	R1, R5			; form this bcd digit
		blt	4$			; br if done
		inc	R2			; increase the bcd digit by 1
		br	3$			;
4$:		add	R1, R5			; add back the constant
		tst	R2			; check if bcd digit 0
		bne	5$			; fall through if 0
		tstb	(SP)			; still doing leading o's?
		bmi	7$			; br if yes
5$:		aslb	(SP)			; msd?
		bcc	6$			; br if no
		movb	1(SP), -1(R3)		; yes-set the sign
6$:		bis	#'0, R2			; make the bcd digit ascii
7$:		bis	#' , R2			; make it a space if not already a digit
		movb	R2, (R3)+		; put this character in the output buffer
		tst	(R0)+			; just incrementing
		cmp	R0, #10			; check the table index
		blt	2$			; go do the next digit
		bgt	8$			; go to exit
		mov	R5, R2			; get the lsd
		br	6$			; go change to ascii
8$:		tstb	(SP)+			; was the lsd the first non-zero
		bpl	9$			; br if no
		movb	-1(SP), -2(R3)		; yes-set the sign for typing
9$:		clrb	(R3)			; set the terminator
		mov	(SP)+, R5		; pop stack into rr
		mov	(SP)+, R3		; pop stack into R3
		mov	(SP)+, R2		; pop stack into R2
		mov	(SP)+, R1		; pop stack into R1
		mov	(SP)+, R0		; pop stack into R0
		type	, $dblk			; now type the number
		mov	2(SP), 4(SP)		; adjust the stack
		mov	(SP)+, (SP)		;
		rti				; return to user
$dtbl:		10000.,	1000., 100., 10.	;
$dblk:		.blkw	4			;
;_____________________________________________________________________________
;
; This routine is used to change a 16-bit binary number to a 6-digit octal
; (ascii) number and type it.
;
; $typos - enter here to setup suppress zeros and number of digits to type
; Call:
;		mov	num, -(SP)		; number to be typed
;		typos				; call for typeout
;		.byte	n			; n=1 to 6 for number of digits to type
;		.byte	m			; m=1 or 0
;						; 1=type leading zeros
;						; 0=suppress leading zeros
;
; $typon - enter here to type out with the same parameters as the last
; $typos or $typoc
; Call:
;		mov num, -(SP)			; number to be typed
;		typon				; call for typeout
;
; $typoc - enter here for typeout of a 16-bit number
; Call:
;		mov	num, -(SP)		; number to be typed
;		typoc				; call for typeout
;
		.sbttl	"BINARY TO OCTAL (ASCII) AND TYPE"

$typos:		mov	@(SP), -(SP)		; pickup the mode
		movb	1(SP), $ofill		; load zero fill switch
		movb	(SP)+, $omode+1		; number of digits to type
		add	#2, (SP)		; adjust return address
		br	$typon			;
$typoc:		movb	#1, $ofill		; set the zero fill switch
		movb	#6, $omode+1		; set for six(6) digits
$typon:		movb	#5, $ocnt		; set the iteration count
		mov	R3, -(SP)		; save R3
		mov	R4, -(SP)		; save R4
		mov	R5, -(SP)		; save R5
		movb	$omode+1, R4		; get the number of digits to type
		neg	R4			;
		add	#6, R4			; subtract it for max. allowed
		movb	R4, $omode		; save it for use
		movb	$ofill, R4		; get the zero fill switch
		mov	12(SP), R5		; pickup the input number
		clr	R3			; clear the output word
1$:		rol	R5			; rotate msb into "C"
		br	3$			; go do msb
2$:		rol	R5			; form this digit
		rol	R5			;
		rol	R5			;
		mov	R5, R3			;
3$:		rol	R3			; get lsb of this digit
		decb	$omode			; type this digit?
		bpl	7$			; br if no
		bic	#177770, R3		; get rid of junk
		bne	4$			; test for 0
		tst	R4			; suppress this 0?
		beq	5$			; br if yes
4$:		inc	R4			; don't suppress anymore o's
		bis	#'0, R3			; make this digit ascii
5$:		bis	#' , R3			; make ascii if not already
		movb	R3, 8$			; save for typing
		type	, 8$			; go type this digit
7$:		decb	$ocnt			; count by 1
		bgt	2$			; br if more to do
		blt	6$			; br if done
		inc	R4			; insure last digit isn't a blank
		br	2$			; go do the last digit
6$:		mov	(SP)+, R5		; restore R5
		mov	(SP)+, R4		; restore R4
		mov	(SP)+, R3		; restore R3
		mov	2(SP), 4(SP)		; set the stack for returning
		mov	(SP)+, (SP)		;
		rti				; return
8$:		.byte	0			; storage for ascii digit
		.byte	0			; terminator for type routine
$ocnt:		.byte	0			; octal digit counter
$ofill:		.byte	0			; zero fill switch
$omode:		.word	0			; number of digits to type
;_____________________________________________________________________________
;
; This routine will pickup the lower byte of the "trap" instruction
; and use it to index through the trap table for the starting address
; of the desired routine. Then using the address obtained it will
; go to that routine.

		.sbttl	"TRAP DECODER"
						;
$trap:		mov	R0, -(SP)		; save R0
		mov	2(SP), R0		; get trap address
		tst	-(R0)			; backup by 2
		movb	(R0), R0		; get right byte of trap
		asl	R0			; position for indexing
		mov	$trpad(R0), R0		; index to table
		rts	R0			; go to routine
	; This is use to handle the "getpri" macro
$trap2:		mov	(SP), -(SP)		; move the PC down
		mov	4(SP), 2(SP)		; move the PSW down
		rti				; restore the PSW
;_____________________________________________________________________________
;
; This table contains the starting addresses of the routines called
; by the "trap" instruction.
;
		.sbttl	"TRAP TABLE"

$trpad:		.word	$trap2			;
		.word	$type			; trap+1(104401) tty typeout routine
		.word	$typoc			; trap+2(104402) type octal number (with leading zeros)
		.word	$typos			; trap+3(104403) type octal number (no leading zeros)
		.word	$typon			; trap+4(104404) type octal number (as per last call)
		.word	$typds			; trap+5(104405) type decimal number (with sign)
passpt:		.word	-1			;
;_____________________________________________________________________________
;
		.end
